<!DOCTYPE HTML>
<html lang="zh-TW" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hyperledger Fabric - DLTDOJO3 第三新熵熱踢道場</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="../index.html"><strong aria-hidden="true">1.</strong> DLTDOJO3</a></li><li><a href="../poc.html"><strong aria-hidden="true">2.</strong> POC 概念驗證</a></li><li><a href="../taichu-raw/index.html"><strong aria-hidden="true">3.</strong> POC TAICHU-RAW</a></li><li><ol class="section"><li><a href="../taichu-raw/apache-big5.html"><strong aria-hidden="true">3.1.</strong> HTTPS: Apache Big5</a></li><li><a href="../taichu-raw/openapiv3.html"><strong aria-hidden="true">3.2.</strong> HTTPS: OpenAPI v3</a></li><li><a href="../taichu-raw/others.html"><strong aria-hidden="true">3.3.</strong> 其他</a></li></ol></li><li><a href="../mad-white/index.html"><strong aria-hidden="true">4.</strong> POC MAD-WHITE</a></li><li><ol class="section"><li><a href="../mad-white/code-server.html"><strong aria-hidden="true">4.1.</strong> VS Code Server</a></li></ol></li><li><a href="../mad-red/index.html"><strong aria-hidden="true">5.</strong> POC MAD-RED</a></li><li><ol class="section"><li><a href="../mad-red/veloren/index.html"><strong aria-hidden="true">5.1.</strong> Veloren 多人RPG體素遊戲</a></li><li><a href="../mad-red/veloren/chat-dltdojo-bip39/index.html"><strong aria-hidden="true">5.2.</strong> 聊天測試 BIP39</a></li><li><a href="../mad-red/vox/index.html"><strong aria-hidden="true">5.3.</strong> Voxel 組件開發編輯</a></li><li><a href="../mad-red/vox/projects.html"><strong aria-hidden="true">5.4.</strong> Voxel 相關專案</a></li></ol></li><li><a href="../crypto-assets.html"><strong aria-hidden="true">6.</strong> Virtual Asset</a></li><li><ol class="section"><li><a href="../virtual-asset/aec.html"><strong aria-hidden="true">6.1.</strong> Anonymity-Enhanced Cryptocurrency</a></li></ol></li><li><a href="../dlt.html"><strong aria-hidden="true">7.</strong> DLT</a></li><li><ol class="section"><li><a href="../dlt/hl-fabric.html" class="active"><strong aria-hidden="true">7.1.</strong> Hyperledger Fabric</a></li><li><a href="../dlt/hl-sawtooth.html"><strong aria-hidden="true">7.2.</strong> Hyperledger Sawtooth</a></li><li><a href="../dlt/hl-burrow.html"><strong aria-hidden="true">7.3.</strong> HyperLedger Burrow</a></li><li><a href="../dlt/hl-besu.html"><strong aria-hidden="true">7.4.</strong> HyperLedger Besu</a></li><li><a href="../dlt/libra19.html"><strong aria-hidden="true">7.5.</strong> Libra</a></li><li><a href="../dlt/lnrpc.html"><strong aria-hidden="true">7.6.</strong> lightning network</a></li><li><a href="../dlt/exonum.html"><strong aria-hidden="true">7.7.</strong> exonum</a></li><li><a href="../dlt/trisa.html"><strong aria-hidden="true">7.8.</strong> TRISA</a></li><li><a href="../dlt/xuperchain.html"><strong aria-hidden="true">7.9.</strong> xuperchain</a></li><li><a href="../dlt/trustwallet.html"><strong aria-hidden="true">7.10.</strong> TrustWallet</a></li><li><a href="../dlt/openbazaar.html"><strong aria-hidden="true">7.11.</strong> OpenBazaar</a></li></ol></li><li><a href="../dao.html"><strong aria-hidden="true">8.</strong> DAO</a></li><li><ol class="section"><li><a href="../dao/aragon.html"><strong aria-hidden="true">8.1.</strong> Aragon</a></li><li><a href="../dao/joystream.html"><strong aria-hidden="true">8.2.</strong> JoyStream</a></li><li><a href="../dao/edgeware.html"><strong aria-hidden="true">8.3.</strong> Edgeware</a></li></ol></li><li><a href="../did.html"><strong aria-hidden="true">9.</strong> DID</a></li><li><a href="../defi/index.html"><strong aria-hidden="true">10.</strong> DeFi</a></li><li><ol class="section"><li><a href="../defi/openbanking.html"><strong aria-hidden="true">10.1.</strong> Open Banking</a></li></ol></li><li><a href="../services/index.html"><strong aria-hidden="true">11.</strong> Services</a></li><li><ol class="section"><li><a href="../services/amazon-qldb.html"><strong aria-hidden="true">11.1.</strong> Amazon QLDB</a></li></ol></li><li><a href="../LRE.html"><strong aria-hidden="true">12.</strong> Ledger Reliability Engineering(LRE)</a></li><li><a href="../web/index.html"><strong aria-hidden="true">13.</strong> Web Tech</a></li><li><ol class="section"><li><a href="../web/extensions.html"><strong aria-hidden="true">13.1.</strong> Browser Extensiions</a></li><li><a href="../web/example-page.html"><strong aria-hidden="true">13.2.</strong> Example Pages</a></li><li><a href="../web/tls.html"><strong aria-hidden="true">13.3.</strong> TLS</a></li><li><a href="../webauthn.html"><strong aria-hidden="true">13.4.</strong> WebAuthn</a></li><li><a href="../webassembly.html"><strong aria-hidden="true">13.5.</strong> WebAssembly</a></li><li><a href="../web/openssl.html"><strong aria-hidden="true">13.6.</strong> OpenSSL</a></li></ol></li><li><a href="../k8s.html"><strong aria-hidden="true">14.</strong> Kubernetes</a></li><li><a href="../p2p.html"><strong aria-hidden="true">15.</strong> P2P</a></li><li><a href="../rust.html"><strong aria-hidden="true">16.</strong> Rust</a></li><li><a href="../plantuml.html"><strong aria-hidden="true">17.</strong> PlantUML</a></li><li><ol class="section"><li><a href="../puml/hyperledger-fabric.html"><strong aria-hidden="true">17.1.</strong> Hyperledger Fabric</a></li><li><a href="../puml/ethereum.html"><strong aria-hidden="true">17.2.</strong> Ethereum</a></li></ol></li><li><a href="../messaging.html"><strong aria-hidden="true">18.</strong> Messaging</a></li><li><a href="../mdbook/index.html"><strong aria-hidden="true">19.</strong> mdbook</a></li><li><ol class="section"><li><a href="../mdbook/preprocessors.html"><strong aria-hidden="true">19.1.</strong> preprocessors</a></li><li><a href="../mdbook/others.html"><strong aria-hidden="true">19.2.</strong> 其他</a></li></ol></li><li><a href="../resources.html"><strong aria-hidden="true">20.</strong> 學習資源</a></li><li><a href="../book.html"><strong aria-hidden="true">21.</strong> 書籍與文獻</a></li><li><a href="../job.html"><strong aria-hidden="true">22.</strong> 工作</a></li><li><a href="../appendix.html"><strong aria-hidden="true">23.</strong> 附錄</a></li><li><ol class="section"><li><a href="../cmd-help.html"><strong aria-hidden="true">23.1.</strong> 命令列 tc.sh</a></li><li><a href="../license.html"><strong aria-hidden="true">23.2.</strong> 授權條款</a></li><li><a href="../testpage.html"><strong aria-hidden="true">23.3.</strong> 測試頁面</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">DLTDOJO3 第三新熵熱踢道場</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#hyperledger-fabric" id="hyperledger-fabric">HyperLedger Fabric</a></h1>
<h1><a class="header" href="#toc" id="toc">TOC</a></h1>
<ul>
<li><a href="#%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90-google-protocol-buffers-%E6%96%87%E4%BB%B6">如何生成 Google Protocol Buffers 文件</a></li>
<li><a href="#generated-date2019-09-12t1431570800">Generated Date:2019-09-12T14:31:57+08:00</a></li>
<li><a href="#protocol-documentation">Protocol Documentation</a>
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#peertransactionproto">peer/transaction.proto</a>
<ul>
<li><a href="#chaincodeactionpayload">ChaincodeActionPayload</a></li>
<li><a href="#chaincodeendorsedaction">ChaincodeEndorsedAction</a></li>
<li><a href="#processedtransaction">ProcessedTransaction</a></li>
<li><a href="#signedtransaction">SignedTransaction</a></li>
<li><a href="#transaction">Transaction</a></li>
<li><a href="#transactionaction">TransactionAction</a></li>
<li><a href="#metadatakeys">MetaDataKeys</a></li>
<li><a href="#txvalidationcode">TxValidationCode</a></li>
</ul>
</li>
<li><a href="#peerconfigurationproto">peer/configuration.proto</a>
<ul>
<li><a href="#acls">ACLs</a></li>
<li><a href="#aclsaclsentry">ACLs.AclsEntry</a></li>
<li><a href="#apiresource">APIResource</a></li>
<li><a href="#anchorpeer">AnchorPeer</a></li>
<li><a href="#anchorpeers">AnchorPeers</a></li>
</ul>
</li>
<li><a href="#peersigned_cc_dep_specproto">peer/signed_cc_dep_spec.proto</a>
<ul>
<li><a href="#signedchaincodedeploymentspec">SignedChaincodeDeploymentSpec</a></li>
</ul>
</li>
<li><a href="#peerchaincodeproto">peer/chaincode.proto</a>
<ul>
<li><a href="#cdsdata">CDSData</a></li>
<li><a href="#chaincodedata">ChaincodeData</a></li>
<li><a href="#chaincodedeploymentspec">ChaincodeDeploymentSpec</a></li>
<li><a href="#chaincodeid">ChaincodeID</a></li>
<li><a href="#chaincodeinput">ChaincodeInput</a></li>
<li><a href="#chaincodeinputdecorationsentry">ChaincodeInput.DecorationsEntry</a></li>
<li><a href="#chaincodeinvocationspec">ChaincodeInvocationSpec</a></li>
<li><a href="#chaincodespec">ChaincodeSpec</a></li>
<li><a href="#lifecycleevent">LifecycleEvent</a></li>
<li><a href="#chaincodespectype">ChaincodeSpec.Type</a></li>
</ul>
</li>
<li><a href="#peerproposal_responseproto">peer/proposal_response.proto</a>
<ul>
<li><a href="#endorsement">Endorsement</a></li>
<li><a href="#proposalresponse">ProposalResponse</a></li>
<li><a href="#proposalresponsepayload">ProposalResponsePayload</a></li>
<li><a href="#response">Response</a></li>
</ul>
</li>
<li><a href="#peerqueryproto">peer/query.proto</a>
<ul>
<li><a href="#chaincodeinfo">ChaincodeInfo</a></li>
<li><a href="#chaincodequeryresponse">ChaincodeQueryResponse</a></li>
<li><a href="#channelinfo">ChannelInfo</a></li>
<li><a href="#channelqueryresponse">ChannelQueryResponse</a></li>
</ul>
</li>
<li><a href="#peerresourcesproto">peer/resources.proto</a>
<ul>
<li><a href="#chaincodeendorsement">ChaincodeEndorsement</a></li>
<li><a href="#chaincodeidentifier">ChaincodeIdentifier</a></li>
<li><a href="#chaincodevalidation">ChaincodeValidation</a></li>
<li><a href="#configtree">ConfigTree</a></li>
<li><a href="#vsccargs">VSCCArgs</a></li>
</ul>
</li>
<li><a href="#peereventsproto">peer/events.proto</a>
<ul>
<li><a href="#blockandprivatedata">BlockAndPrivateData</a></li>
<li><a href="#blockandprivatedataprivatedatamapentry">BlockAndPrivateData.PrivateDataMapEntry</a></li>
<li><a href="#deliverresponse">DeliverResponse</a></li>
<li><a href="#filteredblock">FilteredBlock</a></li>
<li><a href="#filteredchaincodeaction">FilteredChaincodeAction</a></li>
<li><a href="#filteredtransaction">FilteredTransaction</a></li>
<li><a href="#filteredtransactionactions">FilteredTransactionActions</a></li>
<li><a href="#deliver">Deliver</a></li>
</ul>
</li>
<li><a href="#peerproposalproto">peer/proposal.proto</a>
<ul>
<li><a href="#chaincodeaction">ChaincodeAction</a></li>
<li><a href="#chaincodeheaderextension">ChaincodeHeaderExtension</a></li>
<li><a href="#chaincodeproposalpayload">ChaincodeProposalPayload</a></li>
<li><a href="#chaincodeproposalpayloadtransientmapentry">ChaincodeProposalPayload.TransientMapEntry</a></li>
<li><a href="#proposal">Proposal</a></li>
<li><a href="#signedproposal">SignedProposal</a></li>
</ul>
</li>
<li><a href="#peerpolicyproto">peer/policy.proto</a>
<ul>
<li><a href="#applicationpolicy">ApplicationPolicy</a></li>
</ul>
</li>
<li><a href="#peerlifecyclechaincode_definitionproto">peer/lifecycle/chaincode_definition.proto</a>
<ul>
<li><a href="#chaincodeendorsementinfo">ChaincodeEndorsementInfo</a></li>
<li><a href="#chaincodevalidationinfo">ChaincodeValidationInfo</a></li>
</ul>
</li>
<li><a href="#peerlifecyclelifecycleproto">peer/lifecycle/lifecycle.proto</a>
<ul>
<li><a href="#approvechaincodedefinitionformyorgargs">ApproveChaincodeDefinitionForMyOrgArgs</a></li>
<li><a href="#approvechaincodedefinitionformyorgresult">ApproveChaincodeDefinitionForMyOrgResult</a></li>
<li><a href="#chaincodesource">ChaincodeSource</a></li>
<li><a href="#chaincodesourcelocal">ChaincodeSource.Local</a></li>
<li><a href="#chaincodesourceunavailable">ChaincodeSource.Unavailable</a></li>
<li><a href="#checkcommitreadinessargs">CheckCommitReadinessArgs</a></li>
<li><a href="#checkcommitreadinessresult">CheckCommitReadinessResult</a></li>
<li><a href="#checkcommitreadinessresultapprovalsentry">CheckCommitReadinessResult.ApprovalsEntry</a></li>
<li><a href="#commitchaincodedefinitionargs">CommitChaincodeDefinitionArgs</a></li>
<li><a href="#commitchaincodedefinitionresult">CommitChaincodeDefinitionResult</a></li>
<li><a href="#getinstalledchaincodepackageargs">GetInstalledChaincodePackageArgs</a></li>
<li><a href="#getinstalledchaincodepackageresult">GetInstalledChaincodePackageResult</a></li>
<li><a href="#installchaincodeargs">InstallChaincodeArgs</a></li>
<li><a href="#installchaincoderesult">InstallChaincodeResult</a></li>
<li><a href="#querychaincodedefinitionargs">QueryChaincodeDefinitionArgs</a></li>
<li><a href="#querychaincodedefinitionresult">QueryChaincodeDefinitionResult</a></li>
<li><a href="#querychaincodedefinitionresultapprovalsentry">QueryChaincodeDefinitionResult.ApprovalsEntry</a></li>
<li><a href="#querychaincodedefinitionsargs">QueryChaincodeDefinitionsArgs</a></li>
<li><a href="#querychaincodedefinitionsresult">QueryChaincodeDefinitionsResult</a></li>
<li><a href="#querychaincodedefinitionsresultchaincodedefinition">QueryChaincodeDefinitionsResult.ChaincodeDefinition</a></li>
<li><a href="#queryinstalledchaincodeargs">QueryInstalledChaincodeArgs</a></li>
<li><a href="#queryinstalledchaincoderesult">QueryInstalledChaincodeResult</a></li>
<li><a href="#queryinstalledchaincoderesultchaincode">QueryInstalledChaincodeResult.Chaincode</a></li>
<li><a href="#queryinstalledchaincoderesultreferences">QueryInstalledChaincodeResult.References</a></li>
<li><a href="#queryinstalledchaincoderesultreferencesentry">QueryInstalledChaincodeResult.ReferencesEntry</a></li>
<li><a href="#queryinstalledchaincodesargs">QueryInstalledChaincodesArgs</a></li>
<li><a href="#queryinstalledchaincodesresult">QueryInstalledChaincodesResult</a></li>
<li><a href="#queryinstalledchaincodesresultchaincode">QueryInstalledChaincodesResult.Chaincode</a></li>
<li><a href="#queryinstalledchaincodesresultinstalledchaincode">QueryInstalledChaincodesResult.InstalledChaincode</a></li>
<li><a href="#queryinstalledchaincodesresultinstalledchaincodereferencesentry">QueryInstalledChaincodesResult.InstalledChaincode.ReferencesEntry</a></li>
<li><a href="#queryinstalledchaincodesresultreferences">QueryInstalledChaincodesResult.References</a></li>
</ul>
</li>
<li><a href="#peerlifecycledbproto">peer/lifecycle/db.proto</a>
<ul>
<li><a href="#statedata">StateData</a></li>
<li><a href="#statemetadata">StateMetadata</a></li>
</ul>
</li>
<li><a href="#peerchaincode_eventproto">peer/chaincode_event.proto</a>
<ul>
<li><a href="#chaincodeevent">ChaincodeEvent</a></li>
</ul>
</li>
<li><a href="#peerchaincode_shimproto">peer/chaincode_shim.proto</a>
<ul>
<li><a href="#chaincodemessage">ChaincodeMessage</a></li>
<li><a href="#delstate">DelState</a></li>
<li><a href="#gethistoryforkey">GetHistoryForKey</a></li>
<li><a href="#getqueryresult">GetQueryResult</a></li>
<li><a href="#getstate">GetState</a></li>
<li><a href="#getstatebyrange">GetStateByRange</a></li>
<li><a href="#getstatemetadata">GetStateMetadata</a></li>
<li><a href="#putstate">PutState</a></li>
<li><a href="#putstatemetadata">PutStateMetadata</a></li>
<li><a href="#querymetadata">QueryMetadata</a></li>
<li><a href="#queryresponse">QueryResponse</a></li>
<li><a href="#queryresponsemetadata">QueryResponseMetadata</a></li>
<li><a href="#queryresultbytes">QueryResultBytes</a></li>
<li><a href="#querystateclose">QueryStateClose</a></li>
<li><a href="#querystatenext">QueryStateNext</a></li>
<li><a href="#statemetadata">StateMetadata</a></li>
<li><a href="#statemetadataresult">StateMetadataResult</a></li>
<li><a href="#chaincodemessagetype">ChaincodeMessage.Type</a></li>
<li><a href="#chaincodesupport">ChaincodeSupport</a></li>
</ul>
</li>
<li><a href="#peerpeerproto">peer/peer.proto</a>
<ul>
<li><a href="#endorser">Endorser</a></li>
</ul>
</li>
<li><a href="#mspmsp_configproto">msp/msp_config.proto</a>
<ul>
<li><a href="#fabriccryptoconfig">FabricCryptoConfig</a></li>
<li><a href="#fabricmspconfig">FabricMSPConfig</a></li>
<li><a href="#fabricnodeous">FabricNodeOUs</a></li>
<li><a href="#fabricouidentifier">FabricOUIdentifier</a></li>
<li><a href="#idemixmspconfig">IdemixMSPConfig</a></li>
<li><a href="#idemixmspsignerconfig">IdemixMSPSignerConfig</a></li>
<li><a href="#keyinfo">KeyInfo</a></li>
<li><a href="#mspconfig">MSPConfig</a></li>
<li><a href="#signingidentityinfo">SigningIdentityInfo</a></li>
</ul>
</li>
<li><a href="#mspmsp_principalproto">msp/msp_principal.proto</a>
<ul>
<li><a href="#combinedprincipal">CombinedPrincipal</a></li>
<li><a href="#mspidentityanonymity">MSPIdentityAnonymity</a></li>
<li><a href="#mspprincipal">MSPPrincipal</a></li>
<li><a href="#msprole">MSPRole</a></li>
<li><a href="#organizationunit">OrganizationUnit</a></li>
<li><a href="#mspidentityanonymitymspidentityanonymitytype">MSPIdentityAnonymity.MSPIdentityAnonymityType</a></li>
<li><a href="#mspprincipalclassification">MSPPrincipal.Classification</a></li>
<li><a href="#msprolemsproletype">MSPRole.MSPRoleType</a></li>
</ul>
</li>
<li><a href="#mspidentitiesproto">msp/identities.proto</a>
<ul>
<li><a href="#serializedidemixidentity">SerializedIdemixIdentity</a></li>
<li><a href="#serializedidentity">SerializedIdentity</a></li>
</ul>
</li>
<li><a href="#ledgerrwsetrwsetproto">ledger/rwset/rwset.proto</a>
<ul>
<li><a href="#collectionhashedreadwriteset">CollectionHashedReadWriteSet</a></li>
<li><a href="#collectionpvtreadwriteset">CollectionPvtReadWriteSet</a></li>
<li><a href="#nspvtreadwriteset">NsPvtReadWriteSet</a></li>
<li><a href="#nsreadwriteset">NsReadWriteSet</a></li>
<li><a href="#txpvtreadwriteset">TxPvtReadWriteSet</a></li>
<li><a href="#txreadwriteset">TxReadWriteSet</a></li>
<li><a href="#txreadwritesetdatamodel">TxReadWriteSet.DataModel</a></li>
</ul>
</li>
<li><a href="#ledgerrwsetkvrwsetkv_rwsetproto">ledger/rwset/kvrwset/kv_rwset.proto</a>
<ul>
<li><a href="#hashedrwset">HashedRWSet</a></li>
<li><a href="#kvmetadataentry">KVMetadataEntry</a></li>
<li><a href="#kvmetadatawrite">KVMetadataWrite</a></li>
<li><a href="#kvmetadatawritehash">KVMetadataWriteHash</a></li>
<li><a href="#kvrwset">KVRWSet</a></li>
<li><a href="#kvread">KVRead</a></li>
<li><a href="#kvreadhash">KVReadHash</a></li>
<li><a href="#kvwrite">KVWrite</a></li>
<li><a href="#kvwritehash">KVWriteHash</a></li>
<li><a href="#queryreads">QueryReads</a></li>
<li><a href="#queryreadsmerklesummary">QueryReadsMerkleSummary</a></li>
<li><a href="#rangequeryinfo">RangeQueryInfo</a></li>
<li><a href="#version">Version</a></li>
</ul>
</li>
<li><a href="#ledgerqueryresultkv_query_resultproto">ledger/queryresult/kv_query_result.proto</a>
<ul>
<li><a href="#kv">KV</a></li>
<li><a href="#keymodification">KeyModification</a></li>
</ul>
</li>
<li><a href="#discoveryprotocolproto">discovery/protocol.proto</a>
<ul>
<li><a href="#authinfo">AuthInfo</a></li>
<li><a href="#chaincodecall">ChaincodeCall</a></li>
<li><a href="#chaincodeinterest">ChaincodeInterest</a></li>
<li><a href="#chaincodequery">ChaincodeQuery</a></li>
<li><a href="#chaincodequeryresult">ChaincodeQueryResult</a></li>
<li><a href="#configquery">ConfigQuery</a></li>
<li><a href="#configresult">ConfigResult</a></li>
<li><a href="#configresultmspsentry">ConfigResult.MspsEntry</a></li>
<li><a href="#configresultorderersentry">ConfigResult.OrderersEntry</a></li>
<li><a href="#endorsementdescriptor">EndorsementDescriptor</a></li>
<li><a href="#endorsementdescriptorendorsersbygroupsentry">EndorsementDescriptor.EndorsersByGroupsEntry</a></li>
<li><a href="#endpoint">Endpoint</a></li>
<li><a href="#endpoints">Endpoints</a></li>
<li><a href="#error">Error</a></li>
<li><a href="#layout">Layout</a></li>
<li><a href="#layoutquantitiesbygroupentry">Layout.QuantitiesByGroupEntry</a></li>
<li><a href="#localpeerquery">LocalPeerQuery</a></li>
<li><a href="#peer">Peer</a></li>
<li><a href="#peermembershipquery">PeerMembershipQuery</a></li>
<li><a href="#peermembershipresult">PeerMembershipResult</a></li>
<li><a href="#peermembershipresultpeersbyorgentry">PeerMembershipResult.PeersByOrgEntry</a></li>
<li><a href="#peers">Peers</a></li>
<li><a href="#query">Query</a></li>
<li><a href="#queryresult">QueryResult</a></li>
<li><a href="#request">Request</a></li>
<li><a href="#response">Response</a></li>
<li><a href="#signedrequest">SignedRequest</a></li>
<li><a href="#discovery">Discovery</a></li>
</ul>
</li>
<li><a href="#ordererconfigurationproto">orderer/configuration.proto</a>
<ul>
<li><a href="#batchsize">BatchSize</a></li>
<li><a href="#batchtimeout">BatchTimeout</a></li>
<li><a href="#channelrestrictions">ChannelRestrictions</a></li>
<li><a href="#consensustype">ConsensusType</a></li>
<li><a href="#kafkabrokers">KafkaBrokers</a></li>
<li><a href="#consensustypestate">ConsensusType.State</a></li>
</ul>
</li>
<li><a href="#ordererkafkaproto">orderer/kafka.proto</a>
<ul>
<li><a href="#kafkamessage">KafkaMessage</a></li>
<li><a href="#kafkamessageconnect">KafkaMessageConnect</a></li>
<li><a href="#kafkamessageregular">KafkaMessageRegular</a></li>
<li><a href="#kafkamessagetimetocut">KafkaMessageTimeToCut</a></li>
<li><a href="#kafkametadata">KafkaMetadata</a></li>
<li><a href="#kafkamessageregularclass">KafkaMessageRegular.Class</a></li>
</ul>
</li>
<li><a href="#ordererabproto">orderer/ab.proto</a>
<ul>
<li><a href="#broadcastresponse">BroadcastResponse</a></li>
<li><a href="#deliverresponse">DeliverResponse</a></li>
<li><a href="#seekinfo">SeekInfo</a></li>
<li><a href="#seeknewest">SeekNewest</a></li>
<li><a href="#seekoldest">SeekOldest</a></li>
<li><a href="#seekposition">SeekPosition</a></li>
<li><a href="#seekspecified">SeekSpecified</a></li>
<li><a href="#seekinfoseekbehavior">SeekInfo.SeekBehavior</a></li>
<li><a href="#seekinfoseekerrorresponse">SeekInfo.SeekErrorResponse</a></li>
<li><a href="#atomicbroadcast">AtomicBroadcast</a></li>
</ul>
</li>
<li><a href="#ordererclusterproto">orderer/cluster.proto</a>
<ul>
<li><a href="#consensusrequest">ConsensusRequest</a></li>
<li><a href="#steprequest">StepRequest</a></li>
<li><a href="#stepresponse">StepResponse</a></li>
<li><a href="#submitrequest">SubmitRequest</a></li>
<li><a href="#submitresponse">SubmitResponse</a></li>
<li><a href="#cluster">Cluster</a></li>
</ul>
</li>
<li><a href="#ordereretcdraftconfigurationproto">orderer/etcdraft/configuration.proto</a>
<ul>
<li><a href="#configmetadata">ConfigMetadata</a></li>
<li><a href="#consenter">Consenter</a></li>
<li><a href="#options">Options</a></li>
</ul>
</li>
<li><a href="#ordereretcdraftmetadataproto">orderer/etcdraft/metadata.proto</a>
<ul>
<li><a href="#blockmetadata">BlockMetadata</a></li>
<li><a href="#clustermetadata">ClusterMetadata</a></li>
</ul>
</li>
<li><a href="#gossipmessageproto">gossip/message.proto</a>
<ul>
<li><a href="#acknowledgement">Acknowledgement</a></li>
<li><a href="#alivemessage">AliveMessage</a></li>
<li><a href="#chaincode">Chaincode</a></li>
<li><a href="#connestablish">ConnEstablish</a></li>
<li><a href="#datadigest">DataDigest</a></li>
<li><a href="#datamessage">DataMessage</a></li>
<li><a href="#datarequest">DataRequest</a></li>
<li><a href="#dataupdate">DataUpdate</a></li>
<li><a href="#empty">Empty</a></li>
<li><a href="#envelope">Envelope</a></li>
<li><a href="#gossiphello">GossipHello</a></li>
<li><a href="#gossipmessage">GossipMessage</a></li>
<li><a href="#leadershipmessage">LeadershipMessage</a></li>
<li><a href="#member">Member</a></li>
<li><a href="#membershiprequest">MembershipRequest</a></li>
<li><a href="#membershipresponse">MembershipResponse</a></li>
<li><a href="#payload">Payload</a></li>
<li><a href="#peeridentity">PeerIdentity</a></li>
<li><a href="#peertime">PeerTime</a></li>
<li><a href="#privatedatamessage">PrivateDataMessage</a></li>
<li><a href="#privatepayload">PrivatePayload</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#pvtdatadigest">PvtDataDigest</a></li>
<li><a href="#pvtdataelement">PvtDataElement</a></li>
<li><a href="#pvtdatapayload">PvtDataPayload</a></li>
<li><a href="#remotepvtdatarequest">RemotePvtDataRequest</a></li>
<li><a href="#remotepvtdataresponse">RemotePvtDataResponse</a></li>
<li><a href="#remotestaterequest">RemoteStateRequest</a></li>
<li><a href="#remotestateresponse">RemoteStateResponse</a></li>
<li><a href="#secret">Secret</a></li>
<li><a href="#secretenvelope">SecretEnvelope</a></li>
<li><a href="#stateinfo">StateInfo</a></li>
<li><a href="#stateinfopullrequest">StateInfoPullRequest</a></li>
<li><a href="#stateinfosnapshot">StateInfoSnapshot</a></li>
<li><a href="#gossipmessagetag">GossipMessage.Tag</a></li>
<li><a href="#pullmsgtype">PullMsgType</a></li>
<li><a href="#gossip">Gossip</a></li>
</ul>
</li>
<li><a href="#transientstoretransientstoreproto">transientstore/transientstore.proto</a>
<ul>
<li><a href="#txpvtreadwritesetwithconfiginfo">TxPvtReadWriteSetWithConfigInfo</a></li>
<li><a href="#txpvtreadwritesetwithconfiginfocollectionconfigsentry">TxPvtReadWriteSetWithConfigInfo.CollectionConfigsEntry</a></li>
</ul>
</li>
<li><a href="#commonconfigurationproto">common/configuration.proto</a>
<ul>
<li><a href="#blockdatahashingstructure">BlockDataHashingStructure</a></li>
<li><a href="#capabilities">Capabilities</a></li>
<li><a href="#capabilitiescapabilitiesentry">Capabilities.CapabilitiesEntry</a></li>
<li><a href="#capability">Capability</a></li>
<li><a href="#consortium">Consortium</a></li>
<li><a href="#hashingalgorithm">HashingAlgorithm</a></li>
<li><a href="#ordereraddresses">OrdererAddresses</a></li>
</ul>
</li>
<li><a href="#commonledgerproto">common/ledger.proto</a>
<ul>
<li><a href="#blockchaininfo">BlockchainInfo</a></li>
</ul>
</li>
<li><a href="#commonpoliciesproto">common/policies.proto</a>
<ul>
<li><a href="#implicitmetapolicy">ImplicitMetaPolicy</a></li>
<li><a href="#policy">Policy</a></li>
<li><a href="#signaturepolicy">SignaturePolicy</a></li>
<li><a href="#signaturepolicynoutof">SignaturePolicy.NOutOf</a></li>
<li><a href="#signaturepolicyenvelope">SignaturePolicyEnvelope</a></li>
<li><a href="#implicitmetapolicyrule">ImplicitMetaPolicy.Rule</a></li>
<li><a href="#policypolicytype">Policy.PolicyType</a></li>
</ul>
</li>
<li><a href="#commonconfigtxproto">common/configtx.proto</a>
<ul>
<li><a href="#config">Config</a></li>
<li><a href="#configenvelope">ConfigEnvelope</a></li>
<li><a href="#configgroup">ConfigGroup</a></li>
<li><a href="#configgroupgroupsentry">ConfigGroup.GroupsEntry</a></li>
<li><a href="#configgrouppoliciesentry">ConfigGroup.PoliciesEntry</a></li>
<li><a href="#configgroupvaluesentry">ConfigGroup.ValuesEntry</a></li>
<li><a href="#configgroupschema">ConfigGroupSchema</a></li>
<li><a href="#configgroupschemagroupsentry">ConfigGroupSchema.GroupsEntry</a></li>
<li><a href="#configgroupschemapoliciesentry">ConfigGroupSchema.PoliciesEntry</a></li>
<li><a href="#configgroupschemavaluesentry">ConfigGroupSchema.ValuesEntry</a></li>
<li><a href="#configpolicy">ConfigPolicy</a></li>
<li><a href="#configpolicyschema">ConfigPolicySchema</a></li>
<li><a href="#configsignature">ConfigSignature</a></li>
<li><a href="#configupdate">ConfigUpdate</a></li>
<li><a href="#configupdateisolateddataentry">ConfigUpdate.IsolatedDataEntry</a></li>
<li><a href="#configupdateenvelope">ConfigUpdateEnvelope</a></li>
<li><a href="#configvalue">ConfigValue</a></li>
<li><a href="#configvalueschema">ConfigValueSchema</a></li>
</ul>
</li>
<li><a href="#commoncommonproto">common/common.proto</a>
<ul>
<li><a href="#block">Block</a></li>
<li><a href="#blockdata">BlockData</a></li>
<li><a href="#blockheader">BlockHeader</a></li>
<li><a href="#blockmetadata">BlockMetadata</a></li>
<li><a href="#channelheader">ChannelHeader</a></li>
<li><a href="#envelope">Envelope</a></li>
<li><a href="#header">Header</a></li>
<li><a href="#lastconfig">LastConfig</a></li>
<li><a href="#metadata">Metadata</a></li>
<li><a href="#metadatasignature">MetadataSignature</a></li>
<li><a href="#ordererblockmetadata">OrdererBlockMetadata</a></li>
<li><a href="#payload">Payload</a></li>
<li><a href="#signatureheader">SignatureHeader</a></li>
<li><a href="#blockmetadataindex">BlockMetadataIndex</a></li>
<li><a href="#headertype">HeaderType</a></li>
<li><a href="#status">Status</a></li>
</ul>
</li>
<li><a href="#commoncollectionproto">common/collection.proto</a>
<ul>
<li><a href="#collectionconfig">CollectionConfig</a></li>
<li><a href="#collectionconfigpackage">CollectionConfigPackage</a></li>
<li><a href="#collectioncriteria">CollectionCriteria</a></li>
<li><a href="#collectionpolicyconfig">CollectionPolicyConfig</a></li>
<li><a href="#staticcollectionconfig">StaticCollectionConfig</a></li>
</ul>
</li>
<li><a href="#scalar-value-types">Scalar Value Types</a></li>
</ul>
</li>
<li><a href="#protos-file-tree">Protos File Tree</a></li>
<li><a href="#protobuf-sources">Protobuf sources</a>
<ul>
<li><a href="#srcpeertransactionproto">src:./peer/transaction.proto</a></li>
<li><a href="#srcpeerconfigurationproto">src:./peer/configuration.proto</a></li>
<li><a href="#srcpeersigned_cc_dep_specproto">src:./peer/signed_cc_dep_spec.proto</a></li>
<li><a href="#srcpeerchaincodeproto">src:./peer/chaincode.proto</a></li>
<li><a href="#srcpeerproposal_responseproto">src:./peer/proposal_response.proto</a></li>
<li><a href="#srcpeerqueryproto">src:./peer/query.proto</a></li>
<li><a href="#srcpeerresourcesproto">src:./peer/resources.proto</a></li>
<li><a href="#srcpeereventsproto">src:./peer/events.proto</a></li>
<li><a href="#srcpeerproposalproto">src:./peer/proposal.proto</a></li>
<li><a href="#srcpeerpolicyproto">src:./peer/policy.proto</a></li>
<li><a href="#srcpeerlifecyclechaincode_definitionproto">src:./peer/lifecycle/chaincode_definition.proto</a></li>
<li><a href="#srcpeerlifecyclelifecycleproto">src:./peer/lifecycle/lifecycle.proto</a></li>
<li><a href="#srcpeerlifecycledbproto">src:./peer/lifecycle/db.proto</a></li>
<li><a href="#srcpeerchaincode_eventproto">src:./peer/chaincode_event.proto</a></li>
<li><a href="#srcpeerchaincode_shimproto">src:./peer/chaincode_shim.proto</a></li>
<li><a href="#srcpeerpeerproto">src:./peer/peer.proto</a></li>
<li><a href="#srcmspmsp_configproto">src:./msp/msp_config.proto</a></li>
<li><a href="#srcmspmsp_principalproto">src:./msp/msp_principal.proto</a></li>
<li><a href="#srcmspidentitiesproto">src:./msp/identities.proto</a></li>
<li><a href="#srcledgerrwsetrwsetproto">src:./ledger/rwset/rwset.proto</a></li>
<li><a href="#srcledgerrwsetkvrwsetkv_rwsetproto">src:./ledger/rwset/kvrwset/kv_rwset.proto</a></li>
<li><a href="#srcledgerqueryresultkv_query_resultproto">src:./ledger/queryresult/kv_query_result.proto</a></li>
<li><a href="#srcdiscoveryprotocolproto">src:./discovery/protocol.proto</a></li>
<li><a href="#srcordererconfigurationproto">src:./orderer/configuration.proto</a></li>
<li><a href="#srcordererkafkaproto">src:./orderer/kafka.proto</a></li>
<li><a href="#srcordererabproto">src:./orderer/ab.proto</a></li>
<li><a href="#srcordererclusterproto">src:./orderer/cluster.proto</a></li>
<li><a href="#srcordereretcdraftconfigurationproto">src:./orderer/etcdraft/configuration.proto</a></li>
<li><a href="#srcordereretcdraftmetadataproto">src:./orderer/etcdraft/metadata.proto</a></li>
<li><a href="#srcgossipmessageproto">src:./gossip/message.proto</a></li>
<li><a href="#srctransientstoretransientstoreproto">src:./transientstore/transientstore.proto</a></li>
<li><a href="#srccommonconfigurationproto">src:./common/configuration.proto</a></li>
<li><a href="#srccommonledgerproto">src:./common/ledger.proto</a></li>
<li><a href="#srccommonpoliciesproto">src:./common/policies.proto</a></li>
<li><a href="#srccommonconfigtxproto">src:./common/configtx.proto</a></li>
<li><a href="#srccommoncommonproto">src:./common/common.proto</a></li>
<li><a href="#srccommoncollectionproto">src:./common/collection.proto</a></li>
</ul>
</li>
</ul>
<h1><a class="header" href="#如何生成-google-protocol-buffers-文件" id="如何生成-google-protocol-buffers-文件">如何生成 Google Protocol Buffers 文件</a></h1>
<p><a href="https://github.com/hyperledger/fabric-protos">hyperledger/fabric-protos</a></p>
<pre><code class="language-shell">git clone https://github.com/hyperledger/fabric-protos.git /tmp/src/hlf-protos
bash tc.sh --gen-proto-doc /tmp/src/hlf-protos /tmp/output.md
</code></pre>
<h1><a class="header" href="#generated-date2019-09-12t1431570800" id="generated-date2019-09-12t1431570800">Generated Date:2019-09-12T14:31:57+08:00</a></h1>
<h1><a class="header" href="#protocol-documentation" id="protocol-documentation">Protocol Documentation</a></h1>
<p><a name="top"></a></p>
<h2><a class="header" href="#table-of-contents" id="table-of-contents">Table of Contents</a></h2>
<ul>
<li>
<p><a href="#peer/transaction.proto">peer/transaction.proto</a></p>
<ul>
<li>
<p><a href="#protos.ChaincodeActionPayload">ChaincodeActionPayload</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeEndorsedAction">ChaincodeEndorsedAction</a></p>
</li>
<li>
<p><a href="#protos.ProcessedTransaction">ProcessedTransaction</a></p>
</li>
<li>
<p><a href="#protos.SignedTransaction">SignedTransaction</a></p>
</li>
<li>
<p><a href="#protos.Transaction">Transaction</a></p>
</li>
<li>
<p><a href="#protos.TransactionAction">TransactionAction</a></p>
</li>
<li>
<p><a href="#protos.MetaDataKeys">MetaDataKeys</a></p>
</li>
<li>
<p><a href="#protos.TxValidationCode">TxValidationCode</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#peer/configuration.proto">peer/configuration.proto</a></p>
<ul>
<li><a href="#protos.ACLs">ACLs</a></li>
<li><a href="#protos.ACLs.AclsEntry">ACLs.AclsEntry</a></li>
<li><a href="#protos.APIResource">APIResource</a></li>
<li><a href="#protos.AnchorPeer">AnchorPeer</a></li>
<li><a href="#protos.AnchorPeers">AnchorPeers</a></li>
</ul>
</li>
<li>
<p><a href="#peer/signed_cc_dep_spec.proto">peer/signed_cc_dep_spec.proto</a></p>
<ul>
<li><a href="#protos.SignedChaincodeDeploymentSpec">SignedChaincodeDeploymentSpec</a></li>
</ul>
</li>
<li>
<p><a href="#peer/chaincode.proto">peer/chaincode.proto</a></p>
<ul>
<li>
<p><a href="#protos.CDSData">CDSData</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeData">ChaincodeData</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeDeploymentSpec">ChaincodeDeploymentSpec</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeID">ChaincodeID</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeInput">ChaincodeInput</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeInput.DecorationsEntry">ChaincodeInput.DecorationsEntry</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeInvocationSpec">ChaincodeInvocationSpec</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeSpec">ChaincodeSpec</a></p>
</li>
<li>
<p><a href="#protos.LifecycleEvent">LifecycleEvent</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeSpec.Type">ChaincodeSpec.Type</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#peer/proposal_response.proto">peer/proposal_response.proto</a></p>
<ul>
<li><a href="#protos.Endorsement">Endorsement</a></li>
<li><a href="#protos.ProposalResponse">ProposalResponse</a></li>
<li><a href="#protos.ProposalResponsePayload">ProposalResponsePayload</a></li>
<li><a href="#protos.Response">Response</a></li>
</ul>
</li>
<li>
<p><a href="#peer/query.proto">peer/query.proto</a></p>
<ul>
<li><a href="#protos.ChaincodeInfo">ChaincodeInfo</a></li>
<li><a href="#protos.ChaincodeQueryResponse">ChaincodeQueryResponse</a></li>
<li><a href="#protos.ChannelInfo">ChannelInfo</a></li>
<li><a href="#protos.ChannelQueryResponse">ChannelQueryResponse</a></li>
</ul>
</li>
<li>
<p><a href="#peer/resources.proto">peer/resources.proto</a></p>
<ul>
<li><a href="#protos.ChaincodeEndorsement">ChaincodeEndorsement</a></li>
<li><a href="#protos.ChaincodeIdentifier">ChaincodeIdentifier</a></li>
<li><a href="#protos.ChaincodeValidation">ChaincodeValidation</a></li>
<li><a href="#protos.ConfigTree">ConfigTree</a></li>
<li><a href="#protos.VSCCArgs">VSCCArgs</a></li>
</ul>
</li>
<li>
<p><a href="#peer/events.proto">peer/events.proto</a></p>
<ul>
<li>
<p><a href="#protos.BlockAndPrivateData">BlockAndPrivateData</a></p>
</li>
<li>
<p><a href="#protos.BlockAndPrivateData.PrivateDataMapEntry">BlockAndPrivateData.PrivateDataMapEntry</a></p>
</li>
<li>
<p><a href="#protos.DeliverResponse">DeliverResponse</a></p>
</li>
<li>
<p><a href="#protos.FilteredBlock">FilteredBlock</a></p>
</li>
<li>
<p><a href="#protos.FilteredChaincodeAction">FilteredChaincodeAction</a></p>
</li>
<li>
<p><a href="#protos.FilteredTransaction">FilteredTransaction</a></p>
</li>
<li>
<p><a href="#protos.FilteredTransactionActions">FilteredTransactionActions</a></p>
</li>
<li>
<p><a href="#protos.Deliver">Deliver</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#peer/proposal.proto">peer/proposal.proto</a></p>
<ul>
<li><a href="#protos.ChaincodeAction">ChaincodeAction</a></li>
<li><a href="#protos.ChaincodeHeaderExtension">ChaincodeHeaderExtension</a></li>
<li><a href="#protos.ChaincodeProposalPayload">ChaincodeProposalPayload</a></li>
<li><a href="#protos.ChaincodeProposalPayload.TransientMapEntry">ChaincodeProposalPayload.TransientMapEntry</a></li>
<li><a href="#protos.Proposal">Proposal</a></li>
<li><a href="#protos.SignedProposal">SignedProposal</a></li>
</ul>
</li>
<li>
<p><a href="#peer/policy.proto">peer/policy.proto</a></p>
<ul>
<li><a href="#protos.ApplicationPolicy">ApplicationPolicy</a></li>
</ul>
</li>
<li>
<p><a href="#peer/lifecycle/chaincode_definition.proto">peer/lifecycle/chaincode_definition.proto</a></p>
<ul>
<li><a href="#lifecycle.ChaincodeEndorsementInfo">ChaincodeEndorsementInfo</a></li>
<li><a href="#lifecycle.ChaincodeValidationInfo">ChaincodeValidationInfo</a></li>
</ul>
</li>
<li>
<p><a href="#peer/lifecycle/lifecycle.proto">peer/lifecycle/lifecycle.proto</a></p>
<ul>
<li><a href="#lifecycle.ApproveChaincodeDefinitionForMyOrgArgs">ApproveChaincodeDefinitionForMyOrgArgs</a></li>
<li><a href="#lifecycle.ApproveChaincodeDefinitionForMyOrgResult">ApproveChaincodeDefinitionForMyOrgResult</a></li>
<li><a href="#lifecycle.ChaincodeSource">ChaincodeSource</a></li>
<li><a href="#lifecycle.ChaincodeSource.Local">ChaincodeSource.Local</a></li>
<li><a href="#lifecycle.ChaincodeSource.Unavailable">ChaincodeSource.Unavailable</a></li>
<li><a href="#lifecycle.CheckCommitReadinessArgs">CheckCommitReadinessArgs</a></li>
<li><a href="#lifecycle.CheckCommitReadinessResult">CheckCommitReadinessResult</a></li>
<li><a href="#lifecycle.CheckCommitReadinessResult.ApprovalsEntry">CheckCommitReadinessResult.ApprovalsEntry</a></li>
<li><a href="#lifecycle.CommitChaincodeDefinitionArgs">CommitChaincodeDefinitionArgs</a></li>
<li><a href="#lifecycle.CommitChaincodeDefinitionResult">CommitChaincodeDefinitionResult</a></li>
<li><a href="#lifecycle.GetInstalledChaincodePackageArgs">GetInstalledChaincodePackageArgs</a></li>
<li><a href="#lifecycle.GetInstalledChaincodePackageResult">GetInstalledChaincodePackageResult</a></li>
<li><a href="#lifecycle.InstallChaincodeArgs">InstallChaincodeArgs</a></li>
<li><a href="#lifecycle.InstallChaincodeResult">InstallChaincodeResult</a></li>
<li><a href="#lifecycle.QueryChaincodeDefinitionArgs">QueryChaincodeDefinitionArgs</a></li>
<li><a href="#lifecycle.QueryChaincodeDefinitionResult">QueryChaincodeDefinitionResult</a></li>
<li><a href="#lifecycle.QueryChaincodeDefinitionResult.ApprovalsEntry">QueryChaincodeDefinitionResult.ApprovalsEntry</a></li>
<li><a href="#lifecycle.QueryChaincodeDefinitionsArgs">QueryChaincodeDefinitionsArgs</a></li>
<li><a href="#lifecycle.QueryChaincodeDefinitionsResult">QueryChaincodeDefinitionsResult</a></li>
<li><a href="#lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition">QueryChaincodeDefinitionsResult.ChaincodeDefinition</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodeArgs">QueryInstalledChaincodeArgs</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodeResult">QueryInstalledChaincodeResult</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodeResult.Chaincode">QueryInstalledChaincodeResult.Chaincode</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodeResult.References">QueryInstalledChaincodeResult.References</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodeResult.ReferencesEntry">QueryInstalledChaincodeResult.ReferencesEntry</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodesArgs">QueryInstalledChaincodesArgs</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodesResult">QueryInstalledChaincodesResult</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodesResult.Chaincode">QueryInstalledChaincodesResult.Chaincode</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodesResult.InstalledChaincode">QueryInstalledChaincodesResult.InstalledChaincode</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.ReferencesEntry">QueryInstalledChaincodesResult.InstalledChaincode.ReferencesEntry</a></li>
<li><a href="#lifecycle.QueryInstalledChaincodesResult.References">QueryInstalledChaincodesResult.References</a></li>
</ul>
</li>
<li>
<p><a href="#peer/lifecycle/db.proto">peer/lifecycle/db.proto</a></p>
<ul>
<li><a href="#lifecycle.StateData">StateData</a></li>
<li><a href="#lifecycle.StateMetadata">StateMetadata</a></li>
</ul>
</li>
<li>
<p><a href="#peer/chaincode_event.proto">peer/chaincode_event.proto</a></p>
<ul>
<li><a href="#protos.ChaincodeEvent">ChaincodeEvent</a></li>
</ul>
</li>
<li>
<p><a href="#peer/chaincode_shim.proto">peer/chaincode_shim.proto</a></p>
<ul>
<li>
<p><a href="#protos.ChaincodeMessage">ChaincodeMessage</a></p>
</li>
<li>
<p><a href="#protos.DelState">DelState</a></p>
</li>
<li>
<p><a href="#protos.GetHistoryForKey">GetHistoryForKey</a></p>
</li>
<li>
<p><a href="#protos.GetQueryResult">GetQueryResult</a></p>
</li>
<li>
<p><a href="#protos.GetState">GetState</a></p>
</li>
<li>
<p><a href="#protos.GetStateByRange">GetStateByRange</a></p>
</li>
<li>
<p><a href="#protos.GetStateMetadata">GetStateMetadata</a></p>
</li>
<li>
<p><a href="#protos.PutState">PutState</a></p>
</li>
<li>
<p><a href="#protos.PutStateMetadata">PutStateMetadata</a></p>
</li>
<li>
<p><a href="#protos.QueryMetadata">QueryMetadata</a></p>
</li>
<li>
<p><a href="#protos.QueryResponse">QueryResponse</a></p>
</li>
<li>
<p><a href="#protos.QueryResponseMetadata">QueryResponseMetadata</a></p>
</li>
<li>
<p><a href="#protos.QueryResultBytes">QueryResultBytes</a></p>
</li>
<li>
<p><a href="#protos.QueryStateClose">QueryStateClose</a></p>
</li>
<li>
<p><a href="#protos.QueryStateNext">QueryStateNext</a></p>
</li>
<li>
<p><a href="#protos.StateMetadata">StateMetadata</a></p>
</li>
<li>
<p><a href="#protos.StateMetadataResult">StateMetadataResult</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeMessage.Type">ChaincodeMessage.Type</a></p>
</li>
<li>
<p><a href="#protos.ChaincodeSupport">ChaincodeSupport</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#peer/peer.proto">peer/peer.proto</a></p>
<ul>
<li><a href="#protos.Endorser">Endorser</a></li>
</ul>
</li>
<li>
<p><a href="#msp/msp_config.proto">msp/msp_config.proto</a></p>
<ul>
<li><a href="#msp.FabricCryptoConfig">FabricCryptoConfig</a></li>
<li><a href="#msp.FabricMSPConfig">FabricMSPConfig</a></li>
<li><a href="#msp.FabricNodeOUs">FabricNodeOUs</a></li>
<li><a href="#msp.FabricOUIdentifier">FabricOUIdentifier</a></li>
<li><a href="#msp.IdemixMSPConfig">IdemixMSPConfig</a></li>
<li><a href="#msp.IdemixMSPSignerConfig">IdemixMSPSignerConfig</a></li>
<li><a href="#msp.KeyInfo">KeyInfo</a></li>
<li><a href="#msp.MSPConfig">MSPConfig</a></li>
<li><a href="#msp.SigningIdentityInfo">SigningIdentityInfo</a></li>
</ul>
</li>
<li>
<p><a href="#msp/msp_principal.proto">msp/msp_principal.proto</a></p>
<ul>
<li>
<p><a href="#common.CombinedPrincipal">CombinedPrincipal</a></p>
</li>
<li>
<p><a href="#common.MSPIdentityAnonymity">MSPIdentityAnonymity</a></p>
</li>
<li>
<p><a href="#common.MSPPrincipal">MSPPrincipal</a></p>
</li>
<li>
<p><a href="#common.MSPRole">MSPRole</a></p>
</li>
<li>
<p><a href="#common.OrganizationUnit">OrganizationUnit</a></p>
</li>
<li>
<p><a href="#common.MSPIdentityAnonymity.MSPIdentityAnonymityType">MSPIdentityAnonymity.MSPIdentityAnonymityType</a></p>
</li>
<li>
<p><a href="#common.MSPPrincipal.Classification">MSPPrincipal.Classification</a></p>
</li>
<li>
<p><a href="#common.MSPRole.MSPRoleType">MSPRole.MSPRoleType</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#msp/identities.proto">msp/identities.proto</a></p>
<ul>
<li><a href="#msp.SerializedIdemixIdentity">SerializedIdemixIdentity</a></li>
<li><a href="#msp.SerializedIdentity">SerializedIdentity</a></li>
</ul>
</li>
<li>
<p><a href="#ledger/rwset/rwset.proto">ledger/rwset/rwset.proto</a></p>
<ul>
<li>
<p><a href="#rwset.CollectionHashedReadWriteSet">CollectionHashedReadWriteSet</a></p>
</li>
<li>
<p><a href="#rwset.CollectionPvtReadWriteSet">CollectionPvtReadWriteSet</a></p>
</li>
<li>
<p><a href="#rwset.NsPvtReadWriteSet">NsPvtReadWriteSet</a></p>
</li>
<li>
<p><a href="#rwset.NsReadWriteSet">NsReadWriteSet</a></p>
</li>
<li>
<p><a href="#rwset.TxPvtReadWriteSet">TxPvtReadWriteSet</a></p>
</li>
<li>
<p><a href="#rwset.TxReadWriteSet">TxReadWriteSet</a></p>
</li>
<li>
<p><a href="#rwset.TxReadWriteSet.DataModel">TxReadWriteSet.DataModel</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#ledger/rwset/kvrwset/kv_rwset.proto">ledger/rwset/kvrwset/kv_rwset.proto</a></p>
<ul>
<li><a href="#kvrwset.HashedRWSet">HashedRWSet</a></li>
<li><a href="#kvrwset.KVMetadataEntry">KVMetadataEntry</a></li>
<li><a href="#kvrwset.KVMetadataWrite">KVMetadataWrite</a></li>
<li><a href="#kvrwset.KVMetadataWriteHash">KVMetadataWriteHash</a></li>
<li><a href="#kvrwset.KVRWSet">KVRWSet</a></li>
<li><a href="#kvrwset.KVRead">KVRead</a></li>
<li><a href="#kvrwset.KVReadHash">KVReadHash</a></li>
<li><a href="#kvrwset.KVWrite">KVWrite</a></li>
<li><a href="#kvrwset.KVWriteHash">KVWriteHash</a></li>
<li><a href="#kvrwset.QueryReads">QueryReads</a></li>
<li><a href="#kvrwset.QueryReadsMerkleSummary">QueryReadsMerkleSummary</a></li>
<li><a href="#kvrwset.RangeQueryInfo">RangeQueryInfo</a></li>
<li><a href="#kvrwset.Version">Version</a></li>
</ul>
</li>
<li>
<p><a href="#ledger/queryresult/kv_query_result.proto">ledger/queryresult/kv_query_result.proto</a></p>
<ul>
<li><a href="#queryresult.KV">KV</a></li>
<li><a href="#queryresult.KeyModification">KeyModification</a></li>
</ul>
</li>
<li>
<p><a href="#discovery/protocol.proto">discovery/protocol.proto</a></p>
<ul>
<li>
<p><a href="#discovery.AuthInfo">AuthInfo</a></p>
</li>
<li>
<p><a href="#discovery.ChaincodeCall">ChaincodeCall</a></p>
</li>
<li>
<p><a href="#discovery.ChaincodeInterest">ChaincodeInterest</a></p>
</li>
<li>
<p><a href="#discovery.ChaincodeQuery">ChaincodeQuery</a></p>
</li>
<li>
<p><a href="#discovery.ChaincodeQueryResult">ChaincodeQueryResult</a></p>
</li>
<li>
<p><a href="#discovery.ConfigQuery">ConfigQuery</a></p>
</li>
<li>
<p><a href="#discovery.ConfigResult">ConfigResult</a></p>
</li>
<li>
<p><a href="#discovery.ConfigResult.MspsEntry">ConfigResult.MspsEntry</a></p>
</li>
<li>
<p><a href="#discovery.ConfigResult.OrderersEntry">ConfigResult.OrderersEntry</a></p>
</li>
<li>
<p><a href="#discovery.EndorsementDescriptor">EndorsementDescriptor</a></p>
</li>
<li>
<p><a href="#discovery.EndorsementDescriptor.EndorsersByGroupsEntry">EndorsementDescriptor.EndorsersByGroupsEntry</a></p>
</li>
<li>
<p><a href="#discovery.Endpoint">Endpoint</a></p>
</li>
<li>
<p><a href="#discovery.Endpoints">Endpoints</a></p>
</li>
<li>
<p><a href="#discovery.Error">Error</a></p>
</li>
<li>
<p><a href="#discovery.Layout">Layout</a></p>
</li>
<li>
<p><a href="#discovery.Layout.QuantitiesByGroupEntry">Layout.QuantitiesByGroupEntry</a></p>
</li>
<li>
<p><a href="#discovery.LocalPeerQuery">LocalPeerQuery</a></p>
</li>
<li>
<p><a href="#discovery.Peer">Peer</a></p>
</li>
<li>
<p><a href="#discovery.PeerMembershipQuery">PeerMembershipQuery</a></p>
</li>
<li>
<p><a href="#discovery.PeerMembershipResult">PeerMembershipResult</a></p>
</li>
<li>
<p><a href="#discovery.PeerMembershipResult.PeersByOrgEntry">PeerMembershipResult.PeersByOrgEntry</a></p>
</li>
<li>
<p><a href="#discovery.Peers">Peers</a></p>
</li>
<li>
<p><a href="#discovery.Query">Query</a></p>
</li>
<li>
<p><a href="#discovery.QueryResult">QueryResult</a></p>
</li>
<li>
<p><a href="#discovery.Request">Request</a></p>
</li>
<li>
<p><a href="#discovery.Response">Response</a></p>
</li>
<li>
<p><a href="#discovery.SignedRequest">SignedRequest</a></p>
</li>
<li>
<p><a href="#discovery.Discovery">Discovery</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#orderer/configuration.proto">orderer/configuration.proto</a></p>
<ul>
<li>
<p><a href="#orderer.BatchSize">BatchSize</a></p>
</li>
<li>
<p><a href="#orderer.BatchTimeout">BatchTimeout</a></p>
</li>
<li>
<p><a href="#orderer.ChannelRestrictions">ChannelRestrictions</a></p>
</li>
<li>
<p><a href="#orderer.ConsensusType">ConsensusType</a></p>
</li>
<li>
<p><a href="#orderer.KafkaBrokers">KafkaBrokers</a></p>
</li>
<li>
<p><a href="#orderer.ConsensusType.State">ConsensusType.State</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#orderer/kafka.proto">orderer/kafka.proto</a></p>
<ul>
<li>
<p><a href="#orderer.KafkaMessage">KafkaMessage</a></p>
</li>
<li>
<p><a href="#orderer.KafkaMessageConnect">KafkaMessageConnect</a></p>
</li>
<li>
<p><a href="#orderer.KafkaMessageRegular">KafkaMessageRegular</a></p>
</li>
<li>
<p><a href="#orderer.KafkaMessageTimeToCut">KafkaMessageTimeToCut</a></p>
</li>
<li>
<p><a href="#orderer.KafkaMetadata">KafkaMetadata</a></p>
</li>
<li>
<p><a href="#orderer.KafkaMessageRegular.Class">KafkaMessageRegular.Class</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#orderer/ab.proto">orderer/ab.proto</a></p>
<ul>
<li>
<p><a href="#orderer.BroadcastResponse">BroadcastResponse</a></p>
</li>
<li>
<p><a href="#orderer.DeliverResponse">DeliverResponse</a></p>
</li>
<li>
<p><a href="#orderer.SeekInfo">SeekInfo</a></p>
</li>
<li>
<p><a href="#orderer.SeekNewest">SeekNewest</a></p>
</li>
<li>
<p><a href="#orderer.SeekOldest">SeekOldest</a></p>
</li>
<li>
<p><a href="#orderer.SeekPosition">SeekPosition</a></p>
</li>
<li>
<p><a href="#orderer.SeekSpecified">SeekSpecified</a></p>
</li>
<li>
<p><a href="#orderer.SeekInfo.SeekBehavior">SeekInfo.SeekBehavior</a></p>
</li>
<li>
<p><a href="#orderer.SeekInfo.SeekErrorResponse">SeekInfo.SeekErrorResponse</a></p>
</li>
<li>
<p><a href="#orderer.AtomicBroadcast">AtomicBroadcast</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#orderer/cluster.proto">orderer/cluster.proto</a></p>
<ul>
<li>
<p><a href="#orderer.ConsensusRequest">ConsensusRequest</a></p>
</li>
<li>
<p><a href="#orderer.StepRequest">StepRequest</a></p>
</li>
<li>
<p><a href="#orderer.StepResponse">StepResponse</a></p>
</li>
<li>
<p><a href="#orderer.SubmitRequest">SubmitRequest</a></p>
</li>
<li>
<p><a href="#orderer.SubmitResponse">SubmitResponse</a></p>
</li>
<li>
<p><a href="#orderer.Cluster">Cluster</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#orderer/etcdraft/configuration.proto">orderer/etcdraft/configuration.proto</a></p>
<ul>
<li><a href="#etcdraft.ConfigMetadata">ConfigMetadata</a></li>
<li><a href="#etcdraft.Consenter">Consenter</a></li>
<li><a href="#etcdraft.Options">Options</a></li>
</ul>
</li>
<li>
<p><a href="#orderer/etcdraft/metadata.proto">orderer/etcdraft/metadata.proto</a></p>
<ul>
<li><a href="#etcdraft.BlockMetadata">BlockMetadata</a></li>
<li><a href="#etcdraft.ClusterMetadata">ClusterMetadata</a></li>
</ul>
</li>
<li>
<p><a href="#gossip/message.proto">gossip/message.proto</a></p>
<ul>
<li>
<p><a href="#gossip.Acknowledgement">Acknowledgement</a></p>
</li>
<li>
<p><a href="#gossip.AliveMessage">AliveMessage</a></p>
</li>
<li>
<p><a href="#gossip.Chaincode">Chaincode</a></p>
</li>
<li>
<p><a href="#gossip.ConnEstablish">ConnEstablish</a></p>
</li>
<li>
<p><a href="#gossip.DataDigest">DataDigest</a></p>
</li>
<li>
<p><a href="#gossip.DataMessage">DataMessage</a></p>
</li>
<li>
<p><a href="#gossip.DataRequest">DataRequest</a></p>
</li>
<li>
<p><a href="#gossip.DataUpdate">DataUpdate</a></p>
</li>
<li>
<p><a href="#gossip.Empty">Empty</a></p>
</li>
<li>
<p><a href="#gossip.Envelope">Envelope</a></p>
</li>
<li>
<p><a href="#gossip.GossipHello">GossipHello</a></p>
</li>
<li>
<p><a href="#gossip.GossipMessage">GossipMessage</a></p>
</li>
<li>
<p><a href="#gossip.LeadershipMessage">LeadershipMessage</a></p>
</li>
<li>
<p><a href="#gossip.Member">Member</a></p>
</li>
<li>
<p><a href="#gossip.MembershipRequest">MembershipRequest</a></p>
</li>
<li>
<p><a href="#gossip.MembershipResponse">MembershipResponse</a></p>
</li>
<li>
<p><a href="#gossip.Payload">Payload</a></p>
</li>
<li>
<p><a href="#gossip.PeerIdentity">PeerIdentity</a></p>
</li>
<li>
<p><a href="#gossip.PeerTime">PeerTime</a></p>
</li>
<li>
<p><a href="#gossip.PrivateDataMessage">PrivateDataMessage</a></p>
</li>
<li>
<p><a href="#gossip.PrivatePayload">PrivatePayload</a></p>
</li>
<li>
<p><a href="#gossip.Properties">Properties</a></p>
</li>
<li>
<p><a href="#gossip.PvtDataDigest">PvtDataDigest</a></p>
</li>
<li>
<p><a href="#gossip.PvtDataElement">PvtDataElement</a></p>
</li>
<li>
<p><a href="#gossip.PvtDataPayload">PvtDataPayload</a></p>
</li>
<li>
<p><a href="#gossip.RemotePvtDataRequest">RemotePvtDataRequest</a></p>
</li>
<li>
<p><a href="#gossip.RemotePvtDataResponse">RemotePvtDataResponse</a></p>
</li>
<li>
<p><a href="#gossip.RemoteStateRequest">RemoteStateRequest</a></p>
</li>
<li>
<p><a href="#gossip.RemoteStateResponse">RemoteStateResponse</a></p>
</li>
<li>
<p><a href="#gossip.Secret">Secret</a></p>
</li>
<li>
<p><a href="#gossip.SecretEnvelope">SecretEnvelope</a></p>
</li>
<li>
<p><a href="#gossip.StateInfo">StateInfo</a></p>
</li>
<li>
<p><a href="#gossip.StateInfoPullRequest">StateInfoPullRequest</a></p>
</li>
<li>
<p><a href="#gossip.StateInfoSnapshot">StateInfoSnapshot</a></p>
</li>
<li>
<p><a href="#gossip.GossipMessage.Tag">GossipMessage.Tag</a></p>
</li>
<li>
<p><a href="#gossip.PullMsgType">PullMsgType</a></p>
</li>
<li>
<p><a href="#gossip.Gossip">Gossip</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#transientstore/transientstore.proto">transientstore/transientstore.proto</a></p>
<ul>
<li><a href="#transientstore.TxPvtReadWriteSetWithConfigInfo">TxPvtReadWriteSetWithConfigInfo</a></li>
<li><a href="#transientstore.TxPvtReadWriteSetWithConfigInfo.CollectionConfigsEntry">TxPvtReadWriteSetWithConfigInfo.CollectionConfigsEntry</a></li>
</ul>
</li>
<li>
<p><a href="#common/configuration.proto">common/configuration.proto</a></p>
<ul>
<li><a href="#common.BlockDataHashingStructure">BlockDataHashingStructure</a></li>
<li><a href="#common.Capabilities">Capabilities</a></li>
<li><a href="#common.Capabilities.CapabilitiesEntry">Capabilities.CapabilitiesEntry</a></li>
<li><a href="#common.Capability">Capability</a></li>
<li><a href="#common.Consortium">Consortium</a></li>
<li><a href="#common.HashingAlgorithm">HashingAlgorithm</a></li>
<li><a href="#common.OrdererAddresses">OrdererAddresses</a></li>
</ul>
</li>
<li>
<p><a href="#common/ledger.proto">common/ledger.proto</a></p>
<ul>
<li><a href="#common.BlockchainInfo">BlockchainInfo</a></li>
</ul>
</li>
<li>
<p><a href="#common/policies.proto">common/policies.proto</a></p>
<ul>
<li>
<p><a href="#common.ImplicitMetaPolicy">ImplicitMetaPolicy</a></p>
</li>
<li>
<p><a href="#common.Policy">Policy</a></p>
</li>
<li>
<p><a href="#common.SignaturePolicy">SignaturePolicy</a></p>
</li>
<li>
<p><a href="#common.SignaturePolicy.NOutOf">SignaturePolicy.NOutOf</a></p>
</li>
<li>
<p><a href="#common.SignaturePolicyEnvelope">SignaturePolicyEnvelope</a></p>
</li>
<li>
<p><a href="#common.ImplicitMetaPolicy.Rule">ImplicitMetaPolicy.Rule</a></p>
</li>
<li>
<p><a href="#common.Policy.PolicyType">Policy.PolicyType</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#common/configtx.proto">common/configtx.proto</a></p>
<ul>
<li><a href="#common.Config">Config</a></li>
<li><a href="#common.ConfigEnvelope">ConfigEnvelope</a></li>
<li><a href="#common.ConfigGroup">ConfigGroup</a></li>
<li><a href="#common.ConfigGroup.GroupsEntry">ConfigGroup.GroupsEntry</a></li>
<li><a href="#common.ConfigGroup.PoliciesEntry">ConfigGroup.PoliciesEntry</a></li>
<li><a href="#common.ConfigGroup.ValuesEntry">ConfigGroup.ValuesEntry</a></li>
<li><a href="#common.ConfigGroupSchema">ConfigGroupSchema</a></li>
<li><a href="#common.ConfigGroupSchema.GroupsEntry">ConfigGroupSchema.GroupsEntry</a></li>
<li><a href="#common.ConfigGroupSchema.PoliciesEntry">ConfigGroupSchema.PoliciesEntry</a></li>
<li><a href="#common.ConfigGroupSchema.ValuesEntry">ConfigGroupSchema.ValuesEntry</a></li>
<li><a href="#common.ConfigPolicy">ConfigPolicy</a></li>
<li><a href="#common.ConfigPolicySchema">ConfigPolicySchema</a></li>
<li><a href="#common.ConfigSignature">ConfigSignature</a></li>
<li><a href="#common.ConfigUpdate">ConfigUpdate</a></li>
<li><a href="#common.ConfigUpdate.IsolatedDataEntry">ConfigUpdate.IsolatedDataEntry</a></li>
<li><a href="#common.ConfigUpdateEnvelope">ConfigUpdateEnvelope</a></li>
<li><a href="#common.ConfigValue">ConfigValue</a></li>
<li><a href="#common.ConfigValueSchema">ConfigValueSchema</a></li>
</ul>
</li>
<li>
<p><a href="#common/common.proto">common/common.proto</a></p>
<ul>
<li>
<p><a href="#common.Block">Block</a></p>
</li>
<li>
<p><a href="#common.BlockData">BlockData</a></p>
</li>
<li>
<p><a href="#common.BlockHeader">BlockHeader</a></p>
</li>
<li>
<p><a href="#common.BlockMetadata">BlockMetadata</a></p>
</li>
<li>
<p><a href="#common.ChannelHeader">ChannelHeader</a></p>
</li>
<li>
<p><a href="#common.Envelope">Envelope</a></p>
</li>
<li>
<p><a href="#common.Header">Header</a></p>
</li>
<li>
<p><a href="#common.LastConfig">LastConfig</a></p>
</li>
<li>
<p><a href="#common.Metadata">Metadata</a></p>
</li>
<li>
<p><a href="#common.MetadataSignature">MetadataSignature</a></p>
</li>
<li>
<p><a href="#common.OrdererBlockMetadata">OrdererBlockMetadata</a></p>
</li>
<li>
<p><a href="#common.Payload">Payload</a></p>
</li>
<li>
<p><a href="#common.SignatureHeader">SignatureHeader</a></p>
</li>
<li>
<p><a href="#common.BlockMetadataIndex">BlockMetadataIndex</a></p>
</li>
<li>
<p><a href="#common.HeaderType">HeaderType</a></p>
</li>
<li>
<p><a href="#common.Status">Status</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#common/collection.proto">common/collection.proto</a></p>
<ul>
<li><a href="#common.CollectionConfig">CollectionConfig</a></li>
<li><a href="#common.CollectionConfigPackage">CollectionConfigPackage</a></li>
<li><a href="#common.CollectionCriteria">CollectionCriteria</a></li>
<li><a href="#common.CollectionPolicyConfig">CollectionPolicyConfig</a></li>
<li><a href="#common.StaticCollectionConfig">StaticCollectionConfig</a></li>
</ul>
</li>
<li>
<p><a href="#scalar-value-types">Scalar Value Types</a></p>
</li>
</ul>
<p><a name="peer/transaction.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peertransactionproto" id="peertransactionproto">peer/transaction.proto</a></h2>
<p><a name="protos.ChaincodeActionPayload"></a></p>
<h3><a class="header" href="#chaincodeactionpayload" id="chaincodeactionpayload">ChaincodeActionPayload</a></h3>
<p>ChaincodeActionPayload is the message to be used for the TransactionAction's
payload when the Header's type is set to CHAINCODE.  It carries the
chaincodeProposalPayload and an endorsed action to apply to the ledger.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_proposal_payload</td><td><a href="#bytes">bytes</a></td><td></td><td>This field contains the bytes of the ChaincodeProposalPayload message from the original invocation (essentially the arguments) after the application of the visibility function. The main visibility modes are &quot;full&quot; (the entire ChaincodeProposalPayload message is included here), &quot;hash&quot; (only the hash of the ChaincodeProposalPayload message is included) or &quot;nothing&quot;. This field will be used to check the consistency of ProposalResponsePayload.proposalHash. For the CHAINCODE type, ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader</td></tr>
<tr><td>action</td><td><a href="#protos.ChaincodeEndorsedAction">ChaincodeEndorsedAction</a></td><td></td><td>The list of actions to apply to the ledger</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeEndorsedAction"></a></p>
<h3><a class="header" href="#chaincodeendorsedaction" id="chaincodeendorsedaction">ChaincodeEndorsedAction</a></h3>
<p>ChaincodeEndorsedAction carries information about the endorsement of a
specific proposal</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>proposal_response_payload</td><td><a href="#bytes">bytes</a></td><td></td><td>This is the bytes of the ProposalResponsePayload message signed by the endorsers. Recall that for the CHAINCODE type, the ProposalResponsePayload's extenstion field carries a ChaincodeAction</td></tr>
<tr><td>endorsements</td><td><a href="#protos.Endorsement">Endorsement</a></td><td>repeated</td><td>The endorsement of the proposal, basically the endorser's signature over proposalResponsePayload</td></tr>
</tbody></table>
<p><a name="protos.ProcessedTransaction"></a></p>
<h3><a class="header" href="#processedtransaction" id="processedtransaction">ProcessedTransaction</a></h3>
<p>ProcessedTransaction wraps an Envelope that includes a transaction along with an indication
of whether the transaction was validated or invalidated by committing peer.
The use case is that GetTransactionByID API needs to retrieve the transaction Envelope
from block storage, and return it to a client, and indicate whether the transaction
was validated or invalidated by committing peer. So that the originally submitted
transaction Envelope is not modified, the ProcessedTransaction wrapper is returned.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>transactionEnvelope</td><td><a href="#common.Envelope">common.Envelope</a></td><td></td><td>An Envelope which includes a processed transaction</td></tr>
<tr><td>validationCode</td><td><a href="#int32">int32</a></td><td></td><td>An indication of whether the transaction was validated or invalidated by committing peer</td></tr>
</tbody></table>
<p><a name="protos.SignedTransaction"></a></p>
<h3><a class="header" href="#signedtransaction" id="signedtransaction">SignedTransaction</a></h3>
<p>This message is necessary to facilitate the verification of the signature
(in the signature field) over the bytes of the transaction (in the
transactionBytes field).</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>transaction_bytes</td><td><a href="#bytes">bytes</a></td><td></td><td>The bytes of the Transaction. NDD</td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td>Signature of the transactionBytes The public key of the signature is in the header field of TransactionAction There might be multiple TransactionAction, so multiple headers, but there should be same transactor identity (cert) in all headers</td></tr>
</tbody></table>
<p><a name="protos.Transaction"></a></p>
<h3><a class="header" href="#transaction" id="transaction">Transaction</a></h3>
<p>The transaction to be sent to the ordering service. A transaction contains
one or more TransactionAction. Each TransactionAction binds a proposal to
potentially multiple actions. The transaction is atomic meaning that either
all actions in the transaction will be committed or none will.  Note that
while a Transaction might include more than one Header, the Header.creator
field must be the same in each.
A single client is free to issue a number of independent Proposal, each with
their header (Header) and request payload (ChaincodeProposalPayload).  Each
proposal is independently endorsed generating an action
(ProposalResponsePayload) with one signature per Endorser. Any number of
independent proposals (and their action) might be included in a transaction
to ensure that they are treated atomically.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>actions</td><td><a href="#protos.TransactionAction">TransactionAction</a></td><td>repeated</td><td>The payload is an array of TransactionAction. An array is necessary to accommodate multiple actions per transaction</td></tr>
</tbody></table>
<p><a name="protos.TransactionAction"></a></p>
<h3><a class="header" href="#transactionaction" id="transactionaction">TransactionAction</a></h3>
<p>TransactionAction binds a proposal to its action.  The type field in the
header dictates the type of action to be applied to the ledger.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>header</td><td><a href="#bytes">bytes</a></td><td></td><td>The header of the proposal action, which is the proposal header</td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td>The payload of the action as defined by the type in the header For chaincode, it's the bytes of ChaincodeActionPayload</td></tr>
</tbody></table>
<p><a name="protos.MetaDataKeys"></a></p>
<h3><a class="header" href="#metadatakeys" id="metadatakeys">MetaDataKeys</a></h3>
<p>Reserved entries in the key-level metadata map</p>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>VALIDATION_PARAMETER</td><td>0</td><td></td></tr>
<tr><td>VALIDATION_PARAMETER_V2</td><td>1</td><td></td></tr>
</tbody></table>
<p><a name="protos.TxValidationCode"></a></p>
<h3><a class="header" href="#txvalidationcode" id="txvalidationcode">TxValidationCode</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>VALID</td><td>0</td><td></td></tr>
<tr><td>NIL_ENVELOPE</td><td>1</td><td></td></tr>
<tr><td>BAD_PAYLOAD</td><td>2</td><td></td></tr>
<tr><td>BAD_COMMON_HEADER</td><td>3</td><td></td></tr>
<tr><td>BAD_CREATOR_SIGNATURE</td><td>4</td><td></td></tr>
<tr><td>INVALID_ENDORSER_TRANSACTION</td><td>5</td><td></td></tr>
<tr><td>INVALID_CONFIG_TRANSACTION</td><td>6</td><td></td></tr>
<tr><td>UNSUPPORTED_TX_PAYLOAD</td><td>7</td><td></td></tr>
<tr><td>BAD_PROPOSAL_TXID</td><td>8</td><td></td></tr>
<tr><td>DUPLICATE_TXID</td><td>9</td><td></td></tr>
<tr><td>ENDORSEMENT_POLICY_FAILURE</td><td>10</td><td></td></tr>
<tr><td>MVCC_READ_CONFLICT</td><td>11</td><td></td></tr>
<tr><td>PHANTOM_READ_CONFLICT</td><td>12</td><td></td></tr>
<tr><td>UNKNOWN_TX_TYPE</td><td>13</td><td></td></tr>
<tr><td>TARGET_CHAIN_NOT_FOUND</td><td>14</td><td></td></tr>
<tr><td>MARSHAL_TX_ERROR</td><td>15</td><td></td></tr>
<tr><td>NIL_TXACTION</td><td>16</td><td></td></tr>
<tr><td>EXPIRED_CHAINCODE</td><td>17</td><td></td></tr>
<tr><td>CHAINCODE_VERSION_CONFLICT</td><td>18</td><td></td></tr>
<tr><td>BAD_HEADER_EXTENSION</td><td>19</td><td></td></tr>
<tr><td>BAD_CHANNEL_HEADER</td><td>20</td><td></td></tr>
<tr><td>BAD_RESPONSE_PAYLOAD</td><td>21</td><td></td></tr>
<tr><td>BAD_RWSET</td><td>22</td><td></td></tr>
<tr><td>ILLEGAL_WRITESET</td><td>23</td><td></td></tr>
<tr><td>INVALID_WRITESET</td><td>24</td><td></td></tr>
<tr><td>INVALID_CHAINCODE</td><td>25</td><td></td></tr>
<tr><td>NOT_VALIDATED</td><td>254</td><td></td></tr>
<tr><td>INVALID_OTHER_REASON</td><td>255</td><td></td></tr>
</tbody></table>
<p><a name="peer/configuration.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerconfigurationproto" id="peerconfigurationproto">peer/configuration.proto</a></h2>
<p><a name="protos.ACLs"></a></p>
<h3><a class="header" href="#acls" id="acls">ACLs</a></h3>
<p>ACLs provides mappings for resources in a channel. APIResource encapsulates
reference to a policy used to determine ACL for the resource</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>acls</td><td><a href="#protos.ACLs.AclsEntry">ACLs.AclsEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="protos.ACLs.AclsEntry"></a></p>
<h3><a class="header" href="#aclsaclsentry" id="aclsaclsentry">ACLs.AclsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#protos.APIResource">APIResource</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.APIResource"></a></p>
<h3><a class="header" href="#apiresource" id="apiresource">APIResource</a></h3>
<p>APIResource represents an API resource in the peer whose ACL
is determined by the policy_ref field</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>policy_ref</td><td><a href="#string">string</a></td><td></td><td>The policy name to use for this API</td></tr>
</tbody></table>
<p><a name="protos.AnchorPeer"></a></p>
<h3><a class="header" href="#anchorpeer" id="anchorpeer">AnchorPeer</a></h3>
<p>AnchorPeer message structure which provides information about anchor peer, it includes host name,
port number and peer certificate.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>host</td><td><a href="#string">string</a></td><td></td><td>DNS host name of the anchor peer</td></tr>
<tr><td>port</td><td><a href="#int32">int32</a></td><td></td><td>The port number</td></tr>
</tbody></table>
<p><a name="protos.AnchorPeers"></a></p>
<h3><a class="header" href="#anchorpeers" id="anchorpeers">AnchorPeers</a></h3>
<p>AnchorPeers simply represents list of anchor peers which is used in ConfigurationItem</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>anchor_peers</td><td><a href="#protos.AnchorPeer">AnchorPeer</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="peer/signed_cc_dep_spec.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peersigned_cc_dep_specproto" id="peersigned_cc_dep_specproto">peer/signed_cc_dep_spec.proto</a></h2>
<p><a name="protos.SignedChaincodeDeploymentSpec"></a></p>
<h3><a class="header" href="#signedchaincodedeploymentspec" id="signedchaincodedeploymentspec">SignedChaincodeDeploymentSpec</a></h3>
<p>SignedChaincodeDeploymentSpec carries the CDS along with endorsements</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_deployment_spec</td><td><a href="#bytes">bytes</a></td><td></td><td>This is the bytes of the ChaincodeDeploymentSpec</td></tr>
<tr><td>instantiation_policy</td><td><a href="#bytes">bytes</a></td><td></td><td>This is the instantiation policy which is identical in structure to endorsement policy. This policy is checked by the VSCC at commit time on the instantiation (all peers will get the same policy as it will be part of the LSCC instantation record and will be part of the hash as well)</td></tr>
<tr><td>owner_endorsements</td><td><a href="#protos.Endorsement">Endorsement</a></td><td>repeated</td><td>The endorsements of the above deployment spec, the owner's signature over chaincode_deployment_spec and Endorsement.endorser.</td></tr>
</tbody></table>
<p><a name="peer/chaincode.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerchaincodeproto" id="peerchaincodeproto">peer/chaincode.proto</a></h2>
<p><a name="protos.CDSData"></a></p>
<h3><a class="header" href="#cdsdata" id="cdsdata">CDSData</a></h3>
<p>CDSData is data stored in the LSCC on instantiation of a CC
for CDSPackage.  This needs to be serialized for ChaincodeData
hence the protobuf format</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>hash</td><td><a href="#bytes">bytes</a></td><td></td><td>hash of ChaincodeDeploymentSpec.code_package</td></tr>
<tr><td>metadatahash</td><td><a href="#bytes">bytes</a></td><td></td><td>hash of ChaincodeID.name + ChaincodeID.version</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeData"></a></p>
<h3><a class="header" href="#chaincodedata" id="chaincodedata">ChaincodeData</a></h3>
<p>ChaincodeData defines the datastructure for chaincodes to be serialized by proto
Type provides an additional check by directing to use a specific package after instantiation
Data is Type specific (see CDSPackage and SignedCDSPackage)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name of the chaincode</td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td>Version of the chaincode</td></tr>
<tr><td>escc</td><td><a href="#string">string</a></td><td></td><td>Escc for the chaincode instance</td></tr>
<tr><td>vscc</td><td><a href="#string">string</a></td><td></td><td>Vscc for the chaincode instance</td></tr>
<tr><td>policy</td><td><a href="#common.SignaturePolicyEnvelope">common.SignaturePolicyEnvelope</a></td><td></td><td>Policy endorsement policy for the chaincode instance</td></tr>
<tr><td>data</td><td><a href="#bytes">bytes</a></td><td></td><td>Data data specific to the package</td></tr>
<tr><td>id</td><td><a href="#bytes">bytes</a></td><td></td><td>Id of the chaincode that's the unique fingerprint for the CC This is not currently used anywhere but serves as a good eyecatcher</td></tr>
<tr><td>instantiation_policy</td><td><a href="#common.SignaturePolicyEnvelope">common.SignaturePolicyEnvelope</a></td><td></td><td>InstantiationPolicy for the chaincode</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeDeploymentSpec"></a></p>
<h3><a class="header" href="#chaincodedeploymentspec" id="chaincodedeploymentspec">ChaincodeDeploymentSpec</a></h3>
<p>Specify the deployment of a chaincode.
TODO: Define <code>codePackage</code>.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_spec</td><td><a href="#protos.ChaincodeSpec">ChaincodeSpec</a></td><td></td><td></td></tr>
<tr><td>code_package</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.ChaincodeID"></a></p>
<h3><a class="header" href="#chaincodeid" id="chaincodeid">ChaincodeID</a></h3>
<p>ChaincodeID contains the path as specified by the deploy transaction
that created it as well as the hashCode that is generated by the
system for the path. From the user level (ie, CLI, REST API and so on)
deploy transaction is expected to provide the path and other requests
are expected to provide the hashCode. The other value will be ignored.
Internally, the structure could contain both values. For instance, the
hashCode will be set when first generated using the path</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>path</td><td><a href="#string">string</a></td><td></td><td>deploy transaction will use the path</td></tr>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>all other requests will use the name (really a hashcode) generated by the deploy transaction</td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td>user friendly version name for the chaincode</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeInput"></a></p>
<h3><a class="header" href="#chaincodeinput" id="chaincodeinput">ChaincodeInput</a></h3>
<p>Carries the chaincode function and its arguments.
UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
the []byte-based current ChaincodeInput structure.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>args</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td></td></tr>
<tr><td>decorations</td><td><a href="#protos.ChaincodeInput.DecorationsEntry">ChaincodeInput.DecorationsEntry</a></td><td>repeated</td><td></td></tr>
<tr><td>is_init</td><td><a href="#bool">bool</a></td><td></td><td>is_init is used for the application to signal that an invocation is to be routed to the legacy 'Init' function for compatibility with chaincodes which handled Init in the old way. New applications should manage their initialized state themselves.</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeInput.DecorationsEntry"></a></p>
<h3><a class="header" href="#chaincodeinputdecorationsentry" id="chaincodeinputdecorationsentry">ChaincodeInput.DecorationsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.ChaincodeInvocationSpec"></a></p>
<h3><a class="header" href="#chaincodeinvocationspec" id="chaincodeinvocationspec">ChaincodeInvocationSpec</a></h3>
<p>Carries the chaincode function and its arguments.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_spec</td><td><a href="#protos.ChaincodeSpec">ChaincodeSpec</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.ChaincodeSpec"></a></p>
<h3><a class="header" href="#chaincodespec" id="chaincodespec">ChaincodeSpec</a></h3>
<p>Carries the chaincode specification. This is the actual metadata required for
defining a chaincode.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><a href="#protos.ChaincodeSpec.Type">ChaincodeSpec.Type</a></td><td></td><td></td></tr>
<tr><td>chaincode_id</td><td><a href="#protos.ChaincodeID">ChaincodeID</a></td><td></td><td></td></tr>
<tr><td>input</td><td><a href="#protos.ChaincodeInput">ChaincodeInput</a></td><td></td><td></td></tr>
<tr><td>timeout</td><td><a href="#int32">int32</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.LifecycleEvent"></a></p>
<h3><a class="header" href="#lifecycleevent" id="lifecycleevent">LifecycleEvent</a></h3>
<p>LifecycleEvent is used as the payload of the chaincode event emitted by LSCC</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.ChaincodeSpec.Type"></a></p>
<h3><a class="header" href="#chaincodespectype" id="chaincodespectype">ChaincodeSpec.Type</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>UNDEFINED</td><td>0</td><td></td></tr>
<tr><td>GOLANG</td><td>1</td><td></td></tr>
<tr><td>NODE</td><td>2</td><td></td></tr>
<tr><td>CAR</td><td>3</td><td></td></tr>
<tr><td>JAVA</td><td>4</td><td></td></tr>
</tbody></table>
<p><a name="peer/proposal_response.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerproposal_responseproto" id="peerproposal_responseproto">peer/proposal_response.proto</a></h2>
<p><a name="protos.Endorsement"></a></p>
<h3><a class="header" href="#endorsement" id="endorsement">Endorsement</a></h3>
<p>An endorsement is a signature of an endorser over a proposal response.  By
producing an endorsement message, an endorser implicitly &quot;approves&quot; that
proposal response and the actions contained therein. When enough
endorsements have been collected, a transaction can be generated out of a
set of proposal responses.  Note that this message only contains an identity
and a signature but no signed payload. This is intentional because
endorsements are supposed to be collected in a transaction, and they are all
expected to endorse a single proposal response/action (many endorsements
over a single proposal response)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>endorser</td><td><a href="#bytes">bytes</a></td><td></td><td>Identity of the endorser (e.g. its certificate)</td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td>Signature of the payload included in ProposalResponse concatenated with the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)</td></tr>
</tbody></table>
<p><a name="protos.ProposalResponse"></a></p>
<h3><a class="header" href="#proposalresponse" id="proposalresponse">ProposalResponse</a></h3>
<p>A ProposalResponse is returned from an endorser to the proposal submitter.
The idea is that this message contains the endorser's response to the
request of a client to perform an action over a chaincode (or more
generically on the ledger); the response might be success/error (conveyed in
the Response field) together with a description of the action and a
signature over it by that endorser.  If a sufficient number of distinct
endorsers agree on the same action and produce signature to that effect, a
transaction can be generated and sent for ordering.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>version</td><td><a href="#int32">int32</a></td><td></td><td>Version indicates message protocol version</td></tr>
<tr><td>timestamp</td><td><a href="#google.protobuf.Timestamp">google.protobuf.Timestamp</a></td><td></td><td>Timestamp is the time that the message was created as defined by the sender</td></tr>
<tr><td>response</td><td><a href="#protos.Response">Response</a></td><td></td><td>A response message indicating whether the endorsement of the action was successful</td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td>The payload of response. It is the bytes of ProposalResponsePayload</td></tr>
<tr><td>endorsement</td><td><a href="#protos.Endorsement">Endorsement</a></td><td></td><td>The endorsement of the proposal, basically the endorser's signature over the payload</td></tr>
</tbody></table>
<p><a name="protos.ProposalResponsePayload"></a></p>
<h3><a class="header" href="#proposalresponsepayload" id="proposalresponsepayload">ProposalResponsePayload</a></h3>
<p>ProposalResponsePayload is the payload of a proposal response.  This message
is the &quot;bridge&quot; between the client's request and the endorser's action in
response to that request. Concretely, for chaincodes, it contains a hashed
representation of the proposal (proposalHash) and a representation of the
chaincode state changes and events inside the extension field.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>proposal_hash</td><td><a href="#bytes">bytes</a></td><td></td><td>Hash of the proposal that triggered this response. The hash is used to link a response with its proposal, both for bookeeping purposes on an asynchronous system and for security reasons (accountability, non-repudiation). The hash usually covers the entire Proposal message (byte-by-byte).</td></tr>
<tr><td>extension</td><td><a href="#bytes">bytes</a></td><td></td><td>Extension should be unmarshaled to a type-specific message. The type of the extension in any proposal response depends on the type of the proposal that the client selected when the proposal was initially sent out. In particular, this information is stored in the type field of a Header. For chaincode, it's a ChaincodeAction message</td></tr>
</tbody></table>
<p><a name="protos.Response"></a></p>
<h3><a class="header" href="#response" id="response">Response</a></h3>
<p>A response with a representation similar to an HTTP response that can
be used within another message.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>status</td><td><a href="#int32">int32</a></td><td></td><td>A status code that should follow the HTTP status codes.</td></tr>
<tr><td>message</td><td><a href="#string">string</a></td><td></td><td>A message associated with the response code.</td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td>A payload that can be used to include metadata with this response.</td></tr>
</tbody></table>
<p><a name="peer/query.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerqueryproto" id="peerqueryproto">peer/query.proto</a></h2>
<p><a name="protos.ChaincodeInfo"></a></p>
<h3><a class="header" href="#chaincodeinfo" id="chaincodeinfo">ChaincodeInfo</a></h3>
<p>ChaincodeInfo contains general information about an installed/instantiated
chaincode</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>path</td><td><a href="#string">string</a></td><td></td><td>the path as specified by the install/instantiate transaction</td></tr>
<tr><td>input</td><td><a href="#string">string</a></td><td></td><td>the chaincode function upon instantiation and its arguments. This will be blank if the query is returning information about installed chaincodes.</td></tr>
<tr><td>escc</td><td><a href="#string">string</a></td><td></td><td>the name of the ESCC for this chaincode. This will be blank if the query is returning information about installed chaincodes.</td></tr>
<tr><td>vscc</td><td><a href="#string">string</a></td><td></td><td>the name of the VSCC for this chaincode. This will be blank if the query is returning information about installed chaincodes.</td></tr>
<tr><td>id</td><td><a href="#bytes">bytes</a></td><td></td><td>the chaincode unique id. computed as: H( H(name</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeQueryResponse"></a></p>
<h3><a class="header" href="#chaincodequeryresponse" id="chaincodequeryresponse">ChaincodeQueryResponse</a></h3>
<p>ChaincodeQueryResponse returns information about each chaincode that pertains
to a query in lscc.go, such as GetChaincodes (returns all chaincodes
instantiated on a channel), and GetInstalledChaincodes (returns all chaincodes
installed on a peer)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincodes</td><td><a href="#protos.ChaincodeInfo">ChaincodeInfo</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="protos.ChannelInfo"></a></p>
<h3><a class="header" href="#channelinfo" id="channelinfo">ChannelInfo</a></h3>
<p>ChannelInfo contains general information about channels</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.ChannelQueryResponse"></a></p>
<h3><a class="header" href="#channelqueryresponse" id="channelqueryresponse">ChannelQueryResponse</a></h3>
<p>ChannelQueryResponse returns information about each channel that pertains
to a query in lscc.go, such as GetChannels (returns all channels for a
given peer)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channels</td><td><a href="#protos.ChannelInfo">ChannelInfo</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="peer/resources.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerresourcesproto" id="peerresourcesproto">peer/resources.proto</a></h2>
<p><a name="protos.ChaincodeEndorsement"></a></p>
<h3><a class="header" href="#chaincodeendorsement" id="chaincodeendorsement">ChaincodeEndorsement</a></h3>
<p>ChaincodeEndorsement instructs the peer how transactions should be endorsed.  The only
endorsement mechanism which ships with the fabric today is the standard 'escc' mechanism.
This code simply simulates the proposal to generate a RW set, then signs the result
using the peer's local signing identity.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Specifies what code to run for endorsements, defaults 'escc'</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeIdentifier"></a></p>
<h3><a class="header" href="#chaincodeidentifier" id="chaincodeidentifier">ChaincodeIdentifier</a></h3>
<p>ChaincodeIdentifier identifies a piece of chaincode.  For a peer to accept invocations of
this chaincode, the hash of the installed code must match, as must the version string
included with the install command.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>hash</td><td><a href="#bytes">bytes</a></td><td></td><td>The hash of the chaincode bytes</td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td>A user friendly human readable name corresponding to the ID</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeValidation"></a></p>
<h3><a class="header" href="#chaincodevalidation" id="chaincodevalidation">ChaincodeValidation</a></h3>
<p>ChaincodeValidation instructs the peer how transactions for this chaincode should be
validated.  The only validation mechanism which ships with fabric today is the standard
'vscc' validation mechanism.  This built in validation method utilizes an endorsement policy
which checks that a sufficient number of signatures have been included.  The 'arguement'
field encodes any parameters required by the validation implementation.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Specifies which code to run to validate transactions, defaults to 'vscc'</td></tr>
<tr><td>argument</td><td><a href="#bytes">bytes</a></td><td></td><td>When 'vscc' a marshaled VSCCArgs</td></tr>
</tbody></table>
<p><a name="protos.ConfigTree"></a></p>
<h3><a class="header" href="#configtree" id="configtree">ConfigTree</a></h3>
<p>ConfigTree encapsulates channel and resources configuration of a channel.
Both configurations are represented as common.Config</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel_config</td><td><a href="#common.Config">common.Config</a></td><td></td><td></td></tr>
<tr><td>resources_config</td><td><a href="#common.Config">common.Config</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.VSCCArgs"></a></p>
<h3><a class="header" href="#vsccargs" id="vsccargs">VSCCArgs</a></h3>
<p>VSCCArgs is passed (marshaled) as a parameter to the VSCC imlementation via the
argument field of the ChaincodeValidation message.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>endorsement_policy_ref</td><td><a href="#string">string</a></td><td></td><td>A named reference to an endorsement policy,</td></tr>
</tbody></table>
<p><a name="peer/events.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peereventsproto" id="peereventsproto">peer/events.proto</a></h2>
<p><a name="protos.BlockAndPrivateData"></a></p>
<h3><a class="header" href="#blockandprivatedata" id="blockandprivatedata">BlockAndPrivateData</a></h3>
<p>BlockAndPrivateData contains Block and a map from tx_seq_in_block to rwset.TxPvtReadWriteSet</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>block</td><td><a href="#common.Block">common.Block</a></td><td></td><td></td></tr>
<tr><td>private_data_map</td><td><a href="#protos.BlockAndPrivateData.PrivateDataMapEntry">BlockAndPrivateData.PrivateDataMapEntry</a></td><td>repeated</td><td>map from tx_seq_in_block to rwset.TxPvtReadWriteSet</td></tr>
</tbody></table>
<p><a name="protos.BlockAndPrivateData.PrivateDataMapEntry"></a></p>
<h3><a class="header" href="#blockandprivatedataprivatedatamapentry" id="blockandprivatedataprivatedatamapentry">BlockAndPrivateData.PrivateDataMapEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#rwset.TxPvtReadWriteSet">rwset.TxPvtReadWriteSet</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.DeliverResponse"></a></p>
<h3><a class="header" href="#deliverresponse" id="deliverresponse">DeliverResponse</a></h3>
<p>DeliverResponse</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>status</td><td><a href="#common.Status">common.Status</a></td><td></td><td></td></tr>
<tr><td>block</td><td><a href="#common.Block">common.Block</a></td><td></td><td></td></tr>
<tr><td>filtered_block</td><td><a href="#protos.FilteredBlock">FilteredBlock</a></td><td></td><td></td></tr>
<tr><td>block_and_private_data</td><td><a href="#protos.BlockAndPrivateData">BlockAndPrivateData</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.FilteredBlock"></a></p>
<h3><a class="header" href="#filteredblock" id="filteredblock">FilteredBlock</a></h3>
<p>FilteredBlock is a minimal set of information about a block</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>number</td><td><a href="#uint64">uint64</a></td><td></td><td>The position in the blockchain</td></tr>
<tr><td>filtered_transactions</td><td><a href="#protos.FilteredTransaction">FilteredTransaction</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="protos.FilteredChaincodeAction"></a></p>
<h3><a class="header" href="#filteredchaincodeaction" id="filteredchaincodeaction">FilteredChaincodeAction</a></h3>
<p>FilteredChaincodeAction is a minimal set of information about an action
within a transaction</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_event</td><td><a href="#protos.ChaincodeEvent">ChaincodeEvent</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.FilteredTransaction"></a></p>
<h3><a class="header" href="#filteredtransaction" id="filteredtransaction">FilteredTransaction</a></h3>
<p>FilteredTransaction is a minimal set of information about a transaction
within a block</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>txid</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>type</td><td><a href="#common.HeaderType">common.HeaderType</a></td><td></td><td></td></tr>
<tr><td>tx_validation_code</td><td><a href="#protos.TxValidationCode">TxValidationCode</a></td><td></td><td></td></tr>
<tr><td>transaction_actions</td><td><a href="#protos.FilteredTransactionActions">FilteredTransactionActions</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.FilteredTransactionActions"></a></p>
<h3><a class="header" href="#filteredtransactionactions" id="filteredtransactionactions">FilteredTransactionActions</a></h3>
<p>FilteredTransactionActions is a wrapper for array of TransactionAction
message from regular block</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_actions</td><td><a href="#protos.FilteredChaincodeAction">FilteredChaincodeAction</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="protos.Deliver"></a></p>
<h3><a class="header" href="#deliver" id="deliver">Deliver</a></h3>
<table><thead><tr><th>Method Name</th><th>Request Type</th><th>Response Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Deliver</td><td><a href="#common.Envelope">.common.Envelope</a> stream</td><td><a href="#protos.DeliverResponse">DeliverResponse</a> stream</td><td>Deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with Payload data as a marshaled orderer.SeekInfo message, then a stream of block replies is received</td></tr>
<tr><td>DeliverFiltered</td><td><a href="#common.Envelope">.common.Envelope</a> stream</td><td><a href="#protos.DeliverResponse">DeliverResponse</a> stream</td><td>DeliverFiltered first requires an Envelope of type ab.DELIVER_SEEK_INFO with Payload data as a marshaled orderer.SeekInfo message, then a stream of <strong>filtered</strong> block replies is received</td></tr>
<tr><td>DeliverWithPrivateData</td><td><a href="#common.Envelope">.common.Envelope</a> stream</td><td><a href="#protos.DeliverResponse">DeliverResponse</a> stream</td><td>DeliverWithPrivateData first requires an Envelope of type ab.DELIVER_SEEK_INFO with Payload data as a marshaled orderer.SeekInfo message, then a stream of block and private data replies is received</td></tr>
</tbody></table>
<p><a name="peer/proposal.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerproposalproto" id="peerproposalproto">peer/proposal.proto</a></h2>
<p><a name="protos.ChaincodeAction"></a></p>
<h3><a class="header" href="#chaincodeaction" id="chaincodeaction">ChaincodeAction</a></h3>
<p>ChaincodeAction contains the actions the events generated by the execution
of the chaincode.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>results</td><td><a href="#bytes">bytes</a></td><td></td><td>This field contains the read set and the write set produced by the chaincode executing this invocation.</td></tr>
<tr><td>events</td><td><a href="#bytes">bytes</a></td><td></td><td>This field contains the events generated by the chaincode executing this invocation.</td></tr>
<tr><td>response</td><td><a href="#protos.Response">Response</a></td><td></td><td>This field contains the result of executing this invocation.</td></tr>
<tr><td>chaincode_id</td><td><a href="#protos.ChaincodeID">ChaincodeID</a></td><td></td><td>This field contains the ChaincodeID of executing this invocation. Endorser will set it with the ChaincodeID called by endorser while simulating proposal. Committer will validate the version matching with latest chaincode version. Adding ChaincodeID to keep version opens up the possibility of multiple ChaincodeAction per transaction.</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeHeaderExtension"></a></p>
<h3><a class="header" href="#chaincodeheaderextension" id="chaincodeheaderextension">ChaincodeHeaderExtension</a></h3>
<p>ChaincodeHeaderExtension is the Header's extentions message to be used when
the Header's type is CHAINCODE.  This extensions is used to specify which
chaincode to invoke and what should appear on the ledger.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_id</td><td><a href="#protos.ChaincodeID">ChaincodeID</a></td><td></td><td>The ID of the chaincode to target.</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeProposalPayload"></a></p>
<h3><a class="header" href="#chaincodeproposalpayload" id="chaincodeproposalpayload">ChaincodeProposalPayload</a></h3>
<p>ChaincodeProposalPayload is the Proposal's payload message to be used when
the Header's type is CHAINCODE.  It contains the arguments for this
invocation.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>input</td><td><a href="#bytes">bytes</a></td><td></td><td>Input contains the arguments for this invocation. If this invocation deploys a new chaincode, ESCC/VSCC are part of this field. This is usually a marshaled ChaincodeInvocationSpec</td></tr>
<tr><td>TransientMap</td><td><a href="#protos.ChaincodeProposalPayload.TransientMapEntry">ChaincodeProposalPayload.TransientMapEntry</a></td><td>repeated</td><td>TransientMap contains data (e.g. cryptographic material) that might be used to implement some form of application-level confidentiality. The contents of this field are supposed to always be omitted from the transaction and excluded from the ledger.</td></tr>
</tbody></table>
<p><a name="protos.ChaincodeProposalPayload.TransientMapEntry"></a></p>
<h3><a class="header" href="#chaincodeproposalpayloadtransientmapentry" id="chaincodeproposalpayloadtransientmapentry">ChaincodeProposalPayload.TransientMapEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.Proposal"></a></p>
<h3><a class="header" href="#proposal" id="proposal">Proposal</a></h3>
<p>A Proposal is sent to an endorser for endorsement.  The proposal contains:</p>
<ol>
<li>A header which should be unmarshaled to a Header message.  Note that
Header is both the header of a Proposal and of a Transaction, in that i)
both headers should be unmarshaled to this message; and ii) it is used to
compute cryptographic hashes and signatures.  The header has fields common
to all proposals/transactions.  In addition it has a type field for
additional customization. An example of this is the ChaincodeHeaderExtension
message used to extend the Header for type CHAINCODE.</li>
<li>A payload whose type depends on the header's type field.</li>
<li>An extension whose type depends on the header's type field.</li>
</ol>
<p>Let us see an example. For type CHAINCODE (see the Header message),
we have the following:</p>
<ol>
<li>The header is a Header message whose extensions field is a
ChaincodeHeaderExtension message.</li>
<li>The payload is a ChaincodeProposalPayload message.</li>
<li>The extension is a ChaincodeAction that might be used to ask the
endorsers to endorse a specific ChaincodeAction, thus emulating the
submitting peer model.</li>
</ol>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>header</td><td><a href="#bytes">bytes</a></td><td></td><td>The header of the proposal. It is the bytes of the Header</td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td>The payload of the proposal as defined by the type in the proposal header.</td></tr>
<tr><td>extension</td><td><a href="#bytes">bytes</a></td><td></td><td>Optional extensions to the proposal. Its content depends on the Header's type field. For the type CHAINCODE, it might be the bytes of a ChaincodeAction message.</td></tr>
</tbody></table>
<p><a name="protos.SignedProposal"></a></p>
<h3><a class="header" href="#signedproposal" id="signedproposal">SignedProposal</a></h3>
<p>This structure is necessary to sign the proposal which contains the header
and the payload. Without this structure, we would have to concatenate the
header and the payload to verify the signature, which could be expensive
with large payload</p>
<p>When an endorser receives a SignedProposal message, it should verify the
signature over the proposal bytes. This verification requires the following
steps:</p>
<ol>
<li>Verification of the validity of the certificate that was used to produce
the signature.  The certificate will be available once proposalBytes has
been unmarshalled to a Proposal message, and Proposal.header has been
unmarshalled to a Header message. While this unmarshalling-before-verifying
might not be ideal, it is unavoidable because i) the signature needs to also
protect the signing certificate; ii) it is desirable that Header is created
once by the client and never changed (for the sake of accountability and
non-repudiation). Note also that it is actually impossible to conclusively
verify the validity of the certificate included in a Proposal, because the
proposal needs to first be endorsed and ordered with respect to certificate
expiration transactions. Still, it is useful to pre-filter expired
certificates at this stage.</li>
<li>Verification that the certificate is trusted (signed by a trusted CA) and
that it is allowed to transact with us (with respect to some ACLs);</li>
<li>Verification that the signature on proposalBytes is valid;</li>
<li>Detect replay attacks;</li>
</ol>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>proposal_bytes</td><td><a href="#bytes">bytes</a></td><td></td><td>The bytes of Proposal</td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td>Signaure over proposalBytes; this signature is to be verified against the creator identity contained in the header of the Proposal message marshaled as proposalBytes</td></tr>
</tbody></table>
<p><a name="peer/policy.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerpolicyproto" id="peerpolicyproto">peer/policy.proto</a></h2>
<p><a name="protos.ApplicationPolicy"></a></p>
<h3><a class="header" href="#applicationpolicy" id="applicationpolicy">ApplicationPolicy</a></h3>
<p>ApplicationPolicy captures the diffenrent policy types that
are set and evaluted at the application level.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>signature_policy</td><td><a href="#common.SignaturePolicyEnvelope">common.SignaturePolicyEnvelope</a></td><td></td><td>SignaturePolicy type is used if the policy is specified as a combination (using threshold gates) of signatures from MSP principals</td></tr>
<tr><td>channel_config_policy_reference</td><td><a href="#string">string</a></td><td></td><td>ChannelConfigPolicyReference is used when the policy is specified as a string that references a policy defined in the configuration of the channel</td></tr>
</tbody></table>
<p><a name="peer/lifecycle/chaincode_definition.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerlifecyclechaincode_definitionproto" id="peerlifecyclechaincode_definitionproto">peer/lifecycle/chaincode_definition.proto</a></h2>
<p><a name="lifecycle.ChaincodeEndorsementInfo"></a></p>
<h3><a class="header" href="#chaincodeendorsementinfo" id="chaincodeendorsementinfo">ChaincodeEndorsementInfo</a></h3>
<p>ChaincodeEndorsementInfo is (most) everything the peer needs to know in order
to execute a chaincode</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>init_required</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>endorsement_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.ChaincodeValidationInfo"></a></p>
<h3><a class="header" href="#chaincodevalidationinfo" id="chaincodevalidationinfo">ChaincodeValidationInfo</a></h3>
<p>ValidationInfo is (most) everything the peer needs to know in order
to validate a transaction</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>validation_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_parameter</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="peer/lifecycle/lifecycle.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerlifecyclelifecycleproto" id="peerlifecyclelifecycleproto">peer/lifecycle/lifecycle.proto</a></h2>
<p><a name="lifecycle.ApproveChaincodeDefinitionForMyOrgArgs"></a></p>
<h3><a class="header" href="#approvechaincodedefinitionformyorgargs" id="approvechaincodedefinitionformyorgargs">ApproveChaincodeDefinitionForMyOrgArgs</a></h3>
<p>ApproveChaincodeDefinitionForMyOrgArgs is the message used as arguments to
<code>_lifecycle.ApproveChaincodeDefinitionForMyOrg</code>.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>sequence</td><td><a href="#int64">int64</a></td><td></td><td></td></tr>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>endorsement_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_parameter</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>collections</td><td><a href="#common.CollectionConfigPackage">common.CollectionConfigPackage</a></td><td></td><td></td></tr>
<tr><td>init_required</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>source</td><td><a href="#lifecycle.ChaincodeSource">ChaincodeSource</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.ApproveChaincodeDefinitionForMyOrgResult"></a></p>
<h3><a class="header" href="#approvechaincodedefinitionformyorgresult" id="approvechaincodedefinitionformyorgresult">ApproveChaincodeDefinitionForMyOrgResult</a></h3>
<p>ApproveChaincodeDefinitionForMyOrgResult is the message returned by
<code>_lifecycle.ApproveChaincodeDefinitionForMyOrg</code>. Currently it returns
nothing, but may be extended in the future.</p>
<p><a name="lifecycle.ChaincodeSource"></a></p>
<h3><a class="header" href="#chaincodesource" id="chaincodesource">ChaincodeSource</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>unavailable</td><td><a href="#lifecycle.ChaincodeSource.Unavailable">ChaincodeSource.Unavailable</a></td><td></td><td></td></tr>
<tr><td>local_package</td><td><a href="#lifecycle.ChaincodeSource.Local">ChaincodeSource.Local</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.ChaincodeSource.Local"></a></p>
<h3><a class="header" href="#chaincodesourcelocal" id="chaincodesourcelocal">ChaincodeSource.Local</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>package_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.ChaincodeSource.Unavailable"></a></p>
<h3><a class="header" href="#chaincodesourceunavailable" id="chaincodesourceunavailable">ChaincodeSource.Unavailable</a></h3>
<p><a name="lifecycle.CheckCommitReadinessArgs"></a></p>
<h3><a class="header" href="#checkcommitreadinessargs" id="checkcommitreadinessargs">CheckCommitReadinessArgs</a></h3>
<p>CheckCommitReadinessArgs is the message used as arguments to
<code>_lifecycle.CheckCommitReadiness</code>.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>sequence</td><td><a href="#int64">int64</a></td><td></td><td></td></tr>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>endorsement_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_parameter</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>collections</td><td><a href="#common.CollectionConfigPackage">common.CollectionConfigPackage</a></td><td></td><td></td></tr>
<tr><td>init_required</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.CheckCommitReadinessResult"></a></p>
<h3><a class="header" href="#checkcommitreadinessresult" id="checkcommitreadinessresult">CheckCommitReadinessResult</a></h3>
<p>CheckCommitReadinessResult is the message returned by
<code>_lifecycle.CheckCommitReadiness</code>. It returns a map of
orgs to their approval (true/false) for the definition 
supplied as args.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>approvals</td><td><a href="#lifecycle.CheckCommitReadinessResult.ApprovalsEntry">CheckCommitReadinessResult.ApprovalsEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.CheckCommitReadinessResult.ApprovalsEntry"></a></p>
<h3><a class="header" href="#checkcommitreadinessresultapprovalsentry" id="checkcommitreadinessresultapprovalsentry">CheckCommitReadinessResult.ApprovalsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.CommitChaincodeDefinitionArgs"></a></p>
<h3><a class="header" href="#commitchaincodedefinitionargs" id="commitchaincodedefinitionargs">CommitChaincodeDefinitionArgs</a></h3>
<p>CommitChaincodeDefinitionArgs is the message used as arguments to
<code>_lifecycle.CommitChaincodeDefinition</code>.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>sequence</td><td><a href="#int64">int64</a></td><td></td><td></td></tr>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>endorsement_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_parameter</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>collections</td><td><a href="#common.CollectionConfigPackage">common.CollectionConfigPackage</a></td><td></td><td></td></tr>
<tr><td>init_required</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.CommitChaincodeDefinitionResult"></a></p>
<h3><a class="header" href="#commitchaincodedefinitionresult" id="commitchaincodedefinitionresult">CommitChaincodeDefinitionResult</a></h3>
<p>CommitChaincodeDefinitionResult is the message returned by
<code>_lifecycle.CommitChaincodeDefinition</code>. Currently it returns
nothing, but may be extended in the future.</p>
<p><a name="lifecycle.GetInstalledChaincodePackageArgs"></a></p>
<h3><a class="header" href="#getinstalledchaincodepackageargs" id="getinstalledchaincodepackageargs">GetInstalledChaincodePackageArgs</a></h3>
<p>GetInstalledChaincodePackageArgs is the message used as the argument to
'_lifecycle.GetInstalledChaincodePackage'.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>package_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.GetInstalledChaincodePackageResult"></a></p>
<h3><a class="header" href="#getinstalledchaincodepackageresult" id="getinstalledchaincodepackageresult">GetInstalledChaincodePackageResult</a></h3>
<p>GetInstalledChaincodePackageResult is the message returned by
'_lifecycle.GetInstalledChaincodePackage'.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_install_package</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.InstallChaincodeArgs"></a></p>
<h3><a class="header" href="#installchaincodeargs" id="installchaincodeargs">InstallChaincodeArgs</a></h3>
<p>InstallChaincodeArgs is the message used as the argument to
'_lifecycle.InstallChaincode'.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_install_package</td><td><a href="#bytes">bytes</a></td><td></td><td>This should be a marshaled lifecycle.ChaincodePackage</td></tr>
</tbody></table>
<p><a name="lifecycle.InstallChaincodeResult"></a></p>
<h3><a class="header" href="#installchaincoderesult" id="installchaincoderesult">InstallChaincodeResult</a></h3>
<p>InstallChaincodeArgs is the message returned by
'_lifecycle.InstallChaincode'.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>package_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>label</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryChaincodeDefinitionArgs"></a></p>
<h3><a class="header" href="#querychaincodedefinitionargs" id="querychaincodedefinitionargs">QueryChaincodeDefinitionArgs</a></h3>
<p>QueryChaincodeDefinitionArgs is the message used as arguments to
<code>_lifecycle.QueryChaincodeDefinition</code>.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryChaincodeDefinitionResult"></a></p>
<h3><a class="header" href="#querychaincodedefinitionresult" id="querychaincodedefinitionresult">QueryChaincodeDefinitionResult</a></h3>
<p>QueryChaincodeDefinitionResult is the message returned by
<code>_lifecycle.QueryChaincodeDefinition</code>.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>sequence</td><td><a href="#int64">int64</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>endorsement_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_parameter</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>collections</td><td><a href="#common.CollectionConfigPackage">common.CollectionConfigPackage</a></td><td></td><td></td></tr>
<tr><td>init_required</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>approvals</td><td><a href="#lifecycle.QueryChaincodeDefinitionResult.ApprovalsEntry">QueryChaincodeDefinitionResult.ApprovalsEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryChaincodeDefinitionResult.ApprovalsEntry"></a></p>
<h3><a class="header" href="#querychaincodedefinitionresultapprovalsentry" id="querychaincodedefinitionresultapprovalsentry">QueryChaincodeDefinitionResult.ApprovalsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryChaincodeDefinitionsArgs"></a></p>
<h3><a class="header" href="#querychaincodedefinitionsargs" id="querychaincodedefinitionsargs">QueryChaincodeDefinitionsArgs</a></h3>
<p>QueryChaincodeDefinitionsArgs is the message used as arguments to
<code>_lifecycle.QueryChaincodeDefinitions</code>.</p>
<p><a name="lifecycle.QueryChaincodeDefinitionsResult"></a></p>
<h3><a class="header" href="#querychaincodedefinitionsresult" id="querychaincodedefinitionsresult">QueryChaincodeDefinitionsResult</a></h3>
<p>QueryChaincodeDefinitionsResult is the message returned by
<code>_lifecycle.QueryChaincodeDefinitions</code>.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_definitions</td><td><a href="#lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition">QueryChaincodeDefinitionsResult.ChaincodeDefinition</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryChaincodeDefinitionsResult.ChaincodeDefinition"></a></p>
<h3><a class="header" href="#querychaincodedefinitionsresultchaincodedefinition" id="querychaincodedefinitionsresultchaincodedefinition">QueryChaincodeDefinitionsResult.ChaincodeDefinition</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>sequence</td><td><a href="#int64">int64</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>endorsement_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_plugin</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>validation_parameter</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>collections</td><td><a href="#common.CollectionConfigPackage">common.CollectionConfigPackage</a></td><td></td><td></td></tr>
<tr><td>init_required</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodeArgs"></a></p>
<h3><a class="header" href="#queryinstalledchaincodeargs" id="queryinstalledchaincodeargs">QueryInstalledChaincodeArgs</a></h3>
<p>QueryInstalledChaincodeArgs is the message used as arguments
'_lifecycle.QueryInstalledChaincode'</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>package_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodeResult"></a></p>
<h3><a class="header" href="#queryinstalledchaincoderesult" id="queryinstalledchaincoderesult">QueryInstalledChaincodeResult</a></h3>
<p>QueryInstalledChaincodeResult is the message returned by
'_lifecycle.QueryInstalledChaincode'</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>package_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>label</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>references</td><td><a href="#lifecycle.QueryInstalledChaincodeResult.ReferencesEntry">QueryInstalledChaincodeResult.ReferencesEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodeResult.Chaincode"></a></p>
<h3><a class="header" href="#queryinstalledchaincoderesultchaincode" id="queryinstalledchaincoderesultchaincode">QueryInstalledChaincodeResult.Chaincode</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodeResult.References"></a></p>
<h3><a class="header" href="#queryinstalledchaincoderesultreferences" id="queryinstalledchaincoderesultreferences">QueryInstalledChaincodeResult.References</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincodes</td><td><a href="#lifecycle.QueryInstalledChaincodeResult.Chaincode">QueryInstalledChaincodeResult.Chaincode</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodeResult.ReferencesEntry"></a></p>
<h3><a class="header" href="#queryinstalledchaincoderesultreferencesentry" id="queryinstalledchaincoderesultreferencesentry">QueryInstalledChaincodeResult.ReferencesEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#lifecycle.QueryInstalledChaincodeResult.References">QueryInstalledChaincodeResult.References</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodesArgs"></a></p>
<h3><a class="header" href="#queryinstalledchaincodesargs" id="queryinstalledchaincodesargs">QueryInstalledChaincodesArgs</a></h3>
<p>QueryInstalledChaincodesArgs currently is an empty argument to
'_lifecycle.QueryInstalledChaincodes'.   In the future, it may be
extended to have parameters.</p>
<p><a name="lifecycle.QueryInstalledChaincodesResult"></a></p>
<h3><a class="header" href="#queryinstalledchaincodesresult" id="queryinstalledchaincodesresult">QueryInstalledChaincodesResult</a></h3>
<p>QueryInstalledChaincodesResult is the message returned by
'_lifecycle.QueryInstalledChaincodes'.  It returns a list of installed
chaincodes, including a map of channel name to chaincode name and version
pairs of chaincode definitions that reference this chaincode package.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>installed_chaincodes</td><td><a href="#lifecycle.QueryInstalledChaincodesResult.InstalledChaincode">QueryInstalledChaincodesResult.InstalledChaincode</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodesResult.Chaincode"></a></p>
<h3><a class="header" href="#queryinstalledchaincodesresultchaincode" id="queryinstalledchaincodesresultchaincode">QueryInstalledChaincodesResult.Chaincode</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodesResult.InstalledChaincode"></a></p>
<h3><a class="header" href="#queryinstalledchaincodesresultinstalledchaincode" id="queryinstalledchaincodesresultinstalledchaincode">QueryInstalledChaincodesResult.InstalledChaincode</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>package_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>label</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>references</td><td><a href="#lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.ReferencesEntry">QueryInstalledChaincodesResult.InstalledChaincode.ReferencesEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodesResult.InstalledChaincode.ReferencesEntry"></a></p>
<h3><a class="header" href="#queryinstalledchaincodesresultinstalledchaincodereferencesentry" id="queryinstalledchaincodesresultinstalledchaincodereferencesentry">QueryInstalledChaincodesResult.InstalledChaincode.ReferencesEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#lifecycle.QueryInstalledChaincodesResult.References">QueryInstalledChaincodesResult.References</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.QueryInstalledChaincodesResult.References"></a></p>
<h3><a class="header" href="#queryinstalledchaincodesresultreferences" id="queryinstalledchaincodesresultreferences">QueryInstalledChaincodesResult.References</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincodes</td><td><a href="#lifecycle.QueryInstalledChaincodesResult.Chaincode">QueryInstalledChaincodesResult.Chaincode</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="peer/lifecycle/db.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerlifecycledbproto" id="peerlifecycledbproto">peer/lifecycle/db.proto</a></h2>
<p><a name="lifecycle.StateData"></a></p>
<h3><a class="header" href="#statedata" id="statedata">StateData</a></h3>
<p>StateData encodes a particular field of a datatype</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>Int64</td><td><a href="#int64">int64</a></td><td></td><td></td></tr>
<tr><td>Bytes</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>String</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="lifecycle.StateMetadata"></a></p>
<h3><a class="header" href="#statemetadata" id="statemetadata">StateMetadata</a></h3>
<p>StateMetadata describes the keys in a namespace.  It is necessary because
in collections, range scans are not possible during transactions which
write.  Therefore we must track the keys in our namespace ourselves.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>datatype</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>fields</td><td><a href="#string">string</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="peer/chaincode_event.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerchaincode_eventproto" id="peerchaincode_eventproto">peer/chaincode_event.proto</a></h2>
<p><a name="protos.ChaincodeEvent"></a></p>
<h3><a class="header" href="#chaincodeevent" id="chaincodeevent">ChaincodeEvent</a></h3>
<p>ChaincodeEvent is used for events and registrations that are specific to chaincode
string type - &quot;chaincode&quot;</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>tx_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>event_name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="peer/chaincode_shim.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerchaincode_shimproto" id="peerchaincode_shimproto">peer/chaincode_shim.proto</a></h2>
<p><a name="protos.ChaincodeMessage"></a></p>
<h3><a class="header" href="#chaincodemessage" id="chaincodemessage">ChaincodeMessage</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><a href="#protos.ChaincodeMessage.Type">ChaincodeMessage.Type</a></td><td></td><td></td></tr>
<tr><td>timestamp</td><td><a href="#google.protobuf.Timestamp">google.protobuf.Timestamp</a></td><td></td><td></td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>txid</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>proposal</td><td><a href="#protos.SignedProposal">SignedProposal</a></td><td></td><td></td></tr>
<tr><td>chaincode_event</td><td><a href="#protos.ChaincodeEvent">ChaincodeEvent</a></td><td></td><td>event emitted by chaincode. Used only with Init or Invoke. This event is then stored (currently) with Block.NonHashData.TransactionResult</td></tr>
<tr><td>channel_id</td><td><a href="#string">string</a></td><td></td><td>channel id</td></tr>
</tbody></table>
<p><a name="protos.DelState"></a></p>
<h3><a class="header" href="#delstate" id="delstate">DelState</a></h3>
<p>DelState is the payload of a ChaincodeMessage. It contains a key which
needs to be recorded in the transaction's write set as a delete operation.
If the collection is specified, the key needs to be recorded in the
transaction's private write set as a delete operation.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.GetHistoryForKey"></a></p>
<h3><a class="header" href="#gethistoryforkey" id="gethistoryforkey">GetHistoryForKey</a></h3>
<p>GetHistoryForKey is the payload of a ChaincodeMessage. It contains a key
for which the historical values need to be retrieved.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.GetQueryResult"></a></p>
<h3><a class="header" href="#getqueryresult" id="getqueryresult">GetQueryResult</a></h3>
<p>GetQueryResult is the payload of a ChaincodeMessage. It contains a query
string in the form that is supported by the underlying state database.
If the collection is specified, the query needs to be executed on the
private data.  The metadata hold the byte representation of QueryMetadata.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>query</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.GetState"></a></p>
<h3><a class="header" href="#getstate" id="getstate">GetState</a></h3>
<p>GetState is the payload of a ChaincodeMessage. It contains a key which
is to be fetched from the ledger. If the collection is specified, the key
would be fetched from the collection (i.e., private state)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.GetStateByRange"></a></p>
<h3><a class="header" href="#getstatebyrange" id="getstatebyrange">GetStateByRange</a></h3>
<p>GetStateByRange is the payload of a ChaincodeMessage. It contains a start key and
a end key required to execute range query. If the collection is specified,
the range query needs to be executed on the private data. The metadata hold
the byte representation of QueryMetadata.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>startKey</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>endKey</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.GetStateMetadata"></a></p>
<h3><a class="header" href="#getstatemetadata" id="getstatemetadata">GetStateMetadata</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.PutState"></a></p>
<h3><a class="header" href="#putstate" id="putstate">PutState</a></h3>
<p>PutState is the payload of a ChaincodeMessage. It contains a key and value
which needs to be written to the transaction's write set. If the collection is
specified, the key and value would be written to the transaction's private
write set.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.PutStateMetadata"></a></p>
<h3><a class="header" href="#putstatemetadata" id="putstatemetadata">PutStateMetadata</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#protos.StateMetadata">StateMetadata</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.QueryMetadata"></a></p>
<h3><a class="header" href="#querymetadata" id="querymetadata">QueryMetadata</a></h3>
<p>QueryMetadata is the metadata of a GetStateByRange and GetQueryResult.
It contains a pageSize which denotes the number of records to be fetched
and a bookmark.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>pageSize</td><td><a href="#int32">int32</a></td><td></td><td></td></tr>
<tr><td>bookmark</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.QueryResponse"></a></p>
<h3><a class="header" href="#queryresponse" id="queryresponse">QueryResponse</a></h3>
<p>QueryResponse is returned by the peer as a result of a GetStateByRange,
GetQueryResult, and GetHistoryForKey. It holds a bunch of records in
results field, a flag to denote whether more results need to be fetched from
the peer in has_more field, transaction id in id field, and a QueryResponseMetadata
in metadata field.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>results</td><td><a href="#protos.QueryResultBytes">QueryResultBytes</a></td><td>repeated</td><td></td></tr>
<tr><td>has_more</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.QueryResponseMetadata"></a></p>
<h3><a class="header" href="#queryresponsemetadata" id="queryresponsemetadata">QueryResponseMetadata</a></h3>
<p>QueryResponseMetadata is the metadata of a QueryResponse. It contains a count
which denotes the number of records fetched from the ledger and a bookmark.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>fetched_records_count</td><td><a href="#int32">int32</a></td><td></td><td></td></tr>
<tr><td>bookmark</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.QueryResultBytes"></a></p>
<h3><a class="header" href="#queryresultbytes" id="queryresultbytes">QueryResultBytes</a></h3>
<p>QueryResultBytes hold the byte representation of a record returned by the peer.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>resultBytes</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.QueryStateClose"></a></p>
<h3><a class="header" href="#querystateclose" id="querystateclose">QueryStateClose</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.QueryStateNext"></a></p>
<h3><a class="header" href="#querystatenext" id="querystatenext">QueryStateNext</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.StateMetadata"></a></p>
<h3><a class="header" href="#statemetadata-1" id="statemetadata-1">StateMetadata</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>metakey</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="protos.StateMetadataResult"></a></p>
<h3><a class="header" href="#statemetadataresult" id="statemetadataresult">StateMetadataResult</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>entries</td><td><a href="#protos.StateMetadata">StateMetadata</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="protos.ChaincodeMessage.Type"></a></p>
<h3><a class="header" href="#chaincodemessagetype" id="chaincodemessagetype">ChaincodeMessage.Type</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>UNDEFINED</td><td>0</td><td></td></tr>
<tr><td>REGISTER</td><td>1</td><td></td></tr>
<tr><td>REGISTERED</td><td>2</td><td></td></tr>
<tr><td>INIT</td><td>3</td><td></td></tr>
<tr><td>READY</td><td>4</td><td></td></tr>
<tr><td>TRANSACTION</td><td>5</td><td></td></tr>
<tr><td>COMPLETED</td><td>6</td><td></td></tr>
<tr><td>ERROR</td><td>7</td><td></td></tr>
<tr><td>GET_STATE</td><td>8</td><td></td></tr>
<tr><td>PUT_STATE</td><td>9</td><td></td></tr>
<tr><td>DEL_STATE</td><td>10</td><td></td></tr>
<tr><td>INVOKE_CHAINCODE</td><td>11</td><td></td></tr>
<tr><td>RESPONSE</td><td>13</td><td></td></tr>
<tr><td>GET_STATE_BY_RANGE</td><td>14</td><td></td></tr>
<tr><td>GET_QUERY_RESULT</td><td>15</td><td></td></tr>
<tr><td>QUERY_STATE_NEXT</td><td>16</td><td></td></tr>
<tr><td>QUERY_STATE_CLOSE</td><td>17</td><td></td></tr>
<tr><td>KEEPALIVE</td><td>18</td><td></td></tr>
<tr><td>GET_HISTORY_FOR_KEY</td><td>19</td><td></td></tr>
<tr><td>GET_STATE_METADATA</td><td>20</td><td></td></tr>
<tr><td>PUT_STATE_METADATA</td><td>21</td><td></td></tr>
<tr><td>GET_PRIVATE_DATA_HASH</td><td>22</td><td></td></tr>
</tbody></table>
<p><a name="protos.ChaincodeSupport"></a></p>
<h3><a class="header" href="#chaincodesupport" id="chaincodesupport">ChaincodeSupport</a></h3>
<p>Interface that provides support to chaincode execution. ChaincodeContext
provides the context necessary for the server to respond appropriately.</p>
<table><thead><tr><th>Method Name</th><th>Request Type</th><th>Response Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Register</td><td><a href="#protos.ChaincodeMessage">ChaincodeMessage</a> stream</td><td><a href="#protos.ChaincodeMessage">ChaincodeMessage</a> stream</td><td></td></tr>
</tbody></table>
<p><a name="peer/peer.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#peerpeerproto" id="peerpeerproto">peer/peer.proto</a></h2>
<p><a name="protos.Endorser"></a></p>
<h3><a class="header" href="#endorser" id="endorser">Endorser</a></h3>
<table><thead><tr><th>Method Name</th><th>Request Type</th><th>Response Type</th><th>Description</th></tr></thead><tbody>
<tr><td>ProcessProposal</td><td><a href="#protos.SignedProposal">SignedProposal</a></td><td><a href="#protos.ProposalResponse">ProposalResponse</a></td><td></td></tr>
</tbody></table>
<p><a name="msp/msp_config.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#mspmsp_configproto" id="mspmsp_configproto">msp/msp_config.proto</a></h2>
<p><a name="msp.FabricCryptoConfig"></a></p>
<h3><a class="header" href="#fabriccryptoconfig" id="fabriccryptoconfig">FabricCryptoConfig</a></h3>
<p>FabricCryptoConfig contains configuration parameters
for the cryptographic algorithms used by the MSP
this configuration refers to</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>signature_hash_family</td><td><a href="#string">string</a></td><td></td><td>SignatureHashFamily is a string representing the hash family to be used during sign and verify operations. Allowed values are &quot;SHA2&quot; and &quot;SHA3&quot;.</td></tr>
<tr><td>identity_identifier_hash_function</td><td><a href="#string">string</a></td><td></td><td>IdentityIdentifierHashFunction is a string representing the hash function to be used during the computation of the identity identifier of an MSP identity. Allowed values are &quot;SHA256&quot;, &quot;SHA384&quot; and &quot;SHA3_256&quot;, &quot;SHA3_384&quot;.</td></tr>
</tbody></table>
<p><a name="msp.FabricMSPConfig"></a></p>
<h3><a class="header" href="#fabricmspconfig" id="fabricmspconfig">FabricMSPConfig</a></h3>
<p>FabricMSPConfig collects all the configuration information for
a Fabric MSP.
Here we assume a default certificate validation policy, where
any certificate signed by any of the listed rootCA certs would
be considered as valid under this MSP.
This MSP may or may not come with a signing identity. If it does,
it can also issue signing identities. If it does not, it can only
be used to validate and verify certificates.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name holds the identifier of the MSP; MSP identifier is chosen by the application that governs this MSP. For example, and assuming the default implementation of MSP, that is X.509-based and considers a single Issuer, this can refer to the Subject OU field or the Issuer OU field.</td></tr>
<tr><td>root_certs</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>List of root certificates trusted by this MSP they are used upon certificate validation (see comment for IntermediateCerts below)</td></tr>
<tr><td>intermediate_certs</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>List of intermediate certificates trusted by this MSP; they are used upon certificate validation as follows: validation attempts to build a path from the certificate to be validated (which is at one end of the path) and one of the certs in the RootCerts field (which is at the other end of the path). If the path is longer than 2, certificates in the middle are searched within the IntermediateCerts pool</td></tr>
<tr><td>admins</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>Identity denoting the administrator of this MSP</td></tr>
<tr><td>revocation_list</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>Identity revocation list</td></tr>
<tr><td>signing_identity</td><td><a href="#msp.SigningIdentityInfo">SigningIdentityInfo</a></td><td></td><td>SigningIdentity holds information on the signing identity this peer is to use, and which is to be imported by the MSP defined before</td></tr>
<tr><td>organizational_unit_identifiers</td><td><a href="#msp.FabricOUIdentifier">FabricOUIdentifier</a></td><td>repeated</td><td>OrganizationalUnitIdentifiers holds one or more fabric organizational unit identifiers that belong to this MSP configuration</td></tr>
<tr><td>crypto_config</td><td><a href="#msp.FabricCryptoConfig">FabricCryptoConfig</a></td><td></td><td>FabricCryptoConfig contains the configuration parameters for the cryptographic algorithms used by this MSP</td></tr>
<tr><td>tls_root_certs</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>List of TLS root certificates trusted by this MSP. They are returned by GetTLSRootCerts.</td></tr>
<tr><td>tls_intermediate_certs</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>List of TLS intermediate certificates trusted by this MSP; They are returned by GetTLSIntermediateCerts.</td></tr>
<tr><td>fabric_node_ous</td><td><a href="#msp.FabricNodeOUs">FabricNodeOUs</a></td><td></td><td>fabric_node_ous contains the configuration to distinguish clients from peers from orderers based on the OUs.</td></tr>
</tbody></table>
<p><a name="msp.FabricNodeOUs"></a></p>
<h3><a class="header" href="#fabricnodeous" id="fabricnodeous">FabricNodeOUs</a></h3>
<p>FabricNodeOUs contains configuration to tell apart clients from peers from orderers
based on OUs. If NodeOUs recognition is enabled then an msp identity
that does not contain any of the specified OU will be considered invalid.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>enable</td><td><a href="#bool">bool</a></td><td></td><td>If true then an msp identity that does not contain any of the specified OU will be considered invalid.</td></tr>
<tr><td>client_ou_identifier</td><td><a href="#msp.FabricOUIdentifier">FabricOUIdentifier</a></td><td></td><td>OU Identifier of the clients</td></tr>
<tr><td>peer_ou_identifier</td><td><a href="#msp.FabricOUIdentifier">FabricOUIdentifier</a></td><td></td><td>OU Identifier of the peers</td></tr>
<tr><td>admin_ou_identifier</td><td><a href="#msp.FabricOUIdentifier">FabricOUIdentifier</a></td><td></td><td>OU Identifier of the admins</td></tr>
<tr><td>orderer_ou_identifier</td><td><a href="#msp.FabricOUIdentifier">FabricOUIdentifier</a></td><td></td><td>OU Identifier of the orderers</td></tr>
</tbody></table>
<p><a name="msp.FabricOUIdentifier"></a></p>
<h3><a class="header" href="#fabricouidentifier" id="fabricouidentifier">FabricOUIdentifier</a></h3>
<p>FabricOUIdentifier represents an organizational unit and
its related chain of trust identifier.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>certificate</td><td><a href="#bytes">bytes</a></td><td></td><td>Certificate represents the second certificate in a certification chain. (Notice that the first certificate in a certification chain is supposed to be the certificate of an identity). It must correspond to the certificate of root or intermediate CA recognized by the MSP this message belongs to. Starting from this certificate, a certification chain is computed and bound to the OrganizationUnitIdentifier specified</td></tr>
<tr><td>organizational_unit_identifier</td><td><a href="#string">string</a></td><td></td><td>OrganizationUnitIdentifier defines the organizational unit under the MSP identified with MSPIdentifier</td></tr>
</tbody></table>
<p><a name="msp.IdemixMSPConfig"></a></p>
<h3><a class="header" href="#idemixmspconfig" id="idemixmspconfig">IdemixMSPConfig</a></h3>
<p>IdemixMSPConfig collects all the configuration information for
an Idemix MSP.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Name holds the identifier of the MSP</td></tr>
<tr><td>ipk</td><td><a href="#bytes">bytes</a></td><td></td><td>ipk represents the (serialized) issuer public key</td></tr>
<tr><td>signer</td><td><a href="#msp.IdemixMSPSignerConfig">IdemixMSPSignerConfig</a></td><td></td><td>signer may contain crypto material to configure a default signer</td></tr>
<tr><td>revocation_pk</td><td><a href="#bytes">bytes</a></td><td></td><td>revocation_pk is the public key used for revocation of credentials</td></tr>
<tr><td>epoch</td><td><a href="#int64">int64</a></td><td></td><td>epoch represents the current epoch (time interval) used for revocation</td></tr>
</tbody></table>
<p><a name="msp.IdemixMSPSignerConfig"></a></p>
<h3><a class="header" href="#idemixmspsignerconfig" id="idemixmspsignerconfig">IdemixMSPSignerConfig</a></h3>
<p>IdemixMSPSIgnerConfig contains the crypto material to set up an idemix signing identity</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>cred</td><td><a href="#bytes">bytes</a></td><td></td><td>cred represents the serialized idemix credential of the default signer</td></tr>
<tr><td>sk</td><td><a href="#bytes">bytes</a></td><td></td><td>sk is the secret key of the default signer, corresponding to credential Cred</td></tr>
<tr><td>organizational_unit_identifier</td><td><a href="#string">string</a></td><td></td><td>organizational_unit_identifier defines the organizational unit the default signer is in</td></tr>
<tr><td>role</td><td><a href="#int32">int32</a></td><td></td><td>role defines whether the default signer is admin, peer, member or client</td></tr>
<tr><td>enrollment_id</td><td><a href="#string">string</a></td><td></td><td>enrollment_id contains the enrollment id of this signer</td></tr>
<tr><td>credential_revocation_information</td><td><a href="#bytes">bytes</a></td><td></td><td>credential_revocation_information contains a serialized CredentialRevocationInformation</td></tr>
</tbody></table>
<p><a name="msp.KeyInfo"></a></p>
<h3><a class="header" href="#keyinfo" id="keyinfo">KeyInfo</a></h3>
<p>KeyInfo represents a (secret) key that is either already stored
in the bccsp/keystore or key material to be imported to the
bccsp key-store. In later versions it may contain also a
keystore identifier</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key_identifier</td><td><a href="#string">string</a></td><td></td><td>Identifier of the key inside the default keystore; this for the case of Software BCCSP as well as the HSM BCCSP would be the SKI of the key</td></tr>
<tr><td>key_material</td><td><a href="#bytes">bytes</a></td><td></td><td>KeyMaterial (optional) for the key to be imported; this is properly encoded key bytes, prefixed by the type of the key</td></tr>
</tbody></table>
<p><a name="msp.MSPConfig"></a></p>
<h3><a class="header" href="#mspconfig" id="mspconfig">MSPConfig</a></h3>
<p>MSPConfig collects all the configuration information for
an MSP. The Config field should be unmarshalled in a way
that depends on the Type</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><a href="#int32">int32</a></td><td></td><td>Type holds the type of the MSP; the default one would be of type FABRIC implementing an X.509 based provider</td></tr>
<tr><td>config</td><td><a href="#bytes">bytes</a></td><td></td><td>Config is MSP dependent configuration info</td></tr>
</tbody></table>
<p><a name="msp.SigningIdentityInfo"></a></p>
<h3><a class="header" href="#signingidentityinfo" id="signingidentityinfo">SigningIdentityInfo</a></h3>
<p>SigningIdentityInfo represents the configuration information
related to the signing identity the peer is to use for generating
endorsements</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>public_signer</td><td><a href="#bytes">bytes</a></td><td></td><td>PublicSigner carries the public information of the signing identity. For an X.509 provider this would be represented by an X.509 certificate</td></tr>
<tr><td>private_signer</td><td><a href="#msp.KeyInfo">KeyInfo</a></td><td></td><td>PrivateSigner denotes a reference to the private key of the peer's signing identity</td></tr>
</tbody></table>
<p><a name="msp/msp_principal.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#mspmsp_principalproto" id="mspmsp_principalproto">msp/msp_principal.proto</a></h2>
<p><a name="common.CombinedPrincipal"></a></p>
<h3><a class="header" href="#combinedprincipal" id="combinedprincipal">CombinedPrincipal</a></h3>
<p>CombinedPrincipal governs the organization of the Principal
field of a policy principal when principal_classification has
indicated that a combined form of principals is required</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>principals</td><td><a href="#common.MSPPrincipal">MSPPrincipal</a></td><td>repeated</td><td>Principals refer to combined principals</td></tr>
</tbody></table>
<p><a name="common.MSPIdentityAnonymity"></a></p>
<h3><a class="header" href="#mspidentityanonymity" id="mspidentityanonymity">MSPIdentityAnonymity</a></h3>
<p>MSPIdentityAnonymity can be used to enforce an identity to be anonymous or nominal.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>anonymity_type</td><td><a href="#common.MSPIdentityAnonymity.MSPIdentityAnonymityType">MSPIdentityAnonymity.MSPIdentityAnonymityType</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.MSPPrincipal"></a></p>
<h3><a class="header" href="#mspprincipal" id="mspprincipal">MSPPrincipal</a></h3>
<p>MSPPrincipal aims to represent an MSP-centric set of identities.
In particular, this structure allows for definition of</p>
<ul>
<li>a group of identities that are member of the same MSP</li>
<li>a group of identities that are member of the same organization unit
in the same MSP</li>
<li>a group of identities that are administering a specific MSP</li>
<li>a specific identity
Expressing these groups is done given two fields of the fields below</li>
<li>Classification, that defines the type of classification of identities
in an MSP this principal would be defined on; Classification can take
three values:
(i)  ByMSPRole: that represents a classification of identities within
MSP based on one of the two pre-defined MSP rules, &quot;member&quot; and &quot;admin&quot;
(ii) ByOrganizationUnit: that represents a classification of identities
within MSP based on the organization unit an identity belongs to
(iii)ByIdentity that denotes that MSPPrincipal is mapped to a single
identity/certificate; this would mean that the Principal bytes
message</li>
</ul>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>principal_classification</td><td><a href="#common.MSPPrincipal.Classification">MSPPrincipal.Classification</a></td><td></td><td>Classification describes the way that one should process Principal. An Classification value of &quot;ByOrganizationUnit&quot; reflects that &quot;Principal&quot; contains the name of an organization this MSP handles. A Classification value &quot;ByIdentity&quot; means that &quot;Principal&quot; contains a specific identity. Default value denotes that Principal contains one of the groups by default supported by all MSPs (&quot;admin&quot; or &quot;member&quot;).</td></tr>
<tr><td>principal</td><td><a href="#bytes">bytes</a></td><td></td><td>Principal completes the policy principal definition. For the default principal types, Principal can be either &quot;Admin&quot; or &quot;Member&quot;. For the ByOrganizationUnit/ByIdentity values of Classification, PolicyPrincipal acquires its value from an organization unit or identity, respectively. For the Combined Classification type, the Principal is a marshalled CombinedPrincipal.</td></tr>
</tbody></table>
<p><a name="common.MSPRole"></a></p>
<h3><a class="header" href="#msprole" id="msprole">MSPRole</a></h3>
<p>MSPRole governs the organization of the Principal
field of an MSPPrincipal when it aims to define one of the
two dedicated roles within an MSP: Admin and Members.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msp_identifier</td><td><a href="#string">string</a></td><td></td><td>MSPIdentifier represents the identifier of the MSP this principal refers to</td></tr>
<tr><td>role</td><td><a href="#common.MSPRole.MSPRoleType">MSPRole.MSPRoleType</a></td><td></td><td>MSPRoleType defines which of the available, pre-defined MSP-roles an identiy should posess inside the MSP with identifier MSPidentifier</td></tr>
</tbody></table>
<p><a name="common.OrganizationUnit"></a></p>
<h3><a class="header" href="#organizationunit" id="organizationunit">OrganizationUnit</a></h3>
<p>OrganizationUnit governs the organization of the Principal
field of a policy principal when a specific organization unity members
are to be defined within a policy principal.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msp_identifier</td><td><a href="#string">string</a></td><td></td><td>MSPIdentifier represents the identifier of the MSP this organization unit refers to</td></tr>
<tr><td>organizational_unit_identifier</td><td><a href="#string">string</a></td><td></td><td>OrganizationUnitIdentifier defines the organizational unit under the MSP identified with MSPIdentifier</td></tr>
<tr><td>certifiers_identifier</td><td><a href="#bytes">bytes</a></td><td></td><td>CertifiersIdentifier is the hash of certificates chain of trust related to this organizational unit</td></tr>
</tbody></table>
<p><a name="common.MSPIdentityAnonymity.MSPIdentityAnonymityType"></a></p>
<h3><a class="header" href="#mspidentityanonymitymspidentityanonymitytype" id="mspidentityanonymitymspidentityanonymitytype">MSPIdentityAnonymity.MSPIdentityAnonymityType</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>NOMINAL</td><td>0</td><td>Represents a nominal MSP Identity</td></tr>
<tr><td>ANONYMOUS</td><td>1</td><td>Represents an anonymous MSP Identity</td></tr>
</tbody></table>
<p><a name="common.MSPPrincipal.Classification"></a></p>
<h3><a class="header" href="#mspprincipalclassification" id="mspprincipalclassification">MSPPrincipal.Classification</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>ROLE</td><td>0</td><td>Represents the one of the dedicated MSP roles, the</td></tr>
<tr><td>ORGANIZATION_UNIT</td><td>1</td><td>one of a member of MSP network, and the one of an administrator of an MSP network</td></tr>
</tbody></table>
<p>Denotes a finer grained (affiliation-based) |
| IDENTITY | 2 | groupping of entities, per MSP affiliation E.g., this can well be represented by an MSP's Organization unit</p>
<p>Denotes a principal that consists of a single |
| ANONYMITY | 3 | identity</p>
<p>Denotes a principal that can be used to enforce |
| COMBINED | 4 | an identity to be anonymous or nominal.</p>
<p>Denotes a combined principal |</p>
<p><a name="common.MSPRole.MSPRoleType"></a></p>
<h3><a class="header" href="#msprolemsproletype" id="msprolemsproletype">MSPRole.MSPRoleType</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>MEMBER</td><td>0</td><td>Represents an MSP Member</td></tr>
<tr><td>ADMIN</td><td>1</td><td>Represents an MSP Admin</td></tr>
<tr><td>CLIENT</td><td>2</td><td>Represents an MSP Client</td></tr>
<tr><td>PEER</td><td>3</td><td>Represents an MSP Peer</td></tr>
<tr><td>ORDERER</td><td>4</td><td>Represents an MSP Orderer</td></tr>
</tbody></table>
<p><a name="msp/identities.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#mspidentitiesproto" id="mspidentitiesproto">msp/identities.proto</a></h2>
<p><a name="msp.SerializedIdemixIdentity"></a></p>
<h3><a class="header" href="#serializedidemixidentity" id="serializedidemixidentity">SerializedIdemixIdentity</a></h3>
<p>This struct represents an Idemix Identity
to be used to serialize it and deserialize it.
The IdemixMSP will first serialize an idemix identity to bytes using
this proto, and then uses these bytes as id_bytes in SerializedIdentity</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>nym_x</td><td><a href="#bytes">bytes</a></td><td></td><td>nym_x is the X-component of the pseudonym elliptic curve point. It is a []byte representation of an amcl.BIG The pseudonym can be seen as a public key of the identity, it is used to verify signatures.</td></tr>
<tr><td>nym_y</td><td><a href="#bytes">bytes</a></td><td></td><td>nym_y is the Y-component of the pseudonym elliptic curve point. It is a []byte representation of an amcl.BIG The pseudonym can be seen as a public key of the identity, it is used to verify signatures.</td></tr>
<tr><td>ou</td><td><a href="#bytes">bytes</a></td><td></td><td>ou contains the organizational unit of the idemix identity</td></tr>
<tr><td>role</td><td><a href="#bytes">bytes</a></td><td></td><td>role contains the role of this identity (e.g., ADMIN or MEMBER)</td></tr>
<tr><td>proof</td><td><a href="#bytes">bytes</a></td><td></td><td>proof contains the cryptographic evidence that this identity is valid</td></tr>
</tbody></table>
<p><a name="msp.SerializedIdentity"></a></p>
<h3><a class="header" href="#serializedidentity" id="serializedidentity">SerializedIdentity</a></h3>
<p>This struct represents an Identity
(with its MSP identifier) to be used
to serialize it and deserialize it</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>mspid</td><td><a href="#string">string</a></td><td></td><td>The identifier of the associated membership service provider</td></tr>
<tr><td>id_bytes</td><td><a href="#bytes">bytes</a></td><td></td><td>the Identity, serialized according to the rules of its MPS</td></tr>
</tbody></table>
<p><a name="ledger/rwset/rwset.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ledgerrwsetrwsetproto" id="ledgerrwsetrwsetproto">ledger/rwset/rwset.proto</a></h2>
<p><a name="rwset.CollectionHashedReadWriteSet"></a></p>
<h3><a class="header" href="#collectionhashedreadwriteset" id="collectionhashedreadwriteset">CollectionHashedReadWriteSet</a></h3>
<p>CollectionHashedReadWriteSet encapsulate the hashed representation for the private read-write set for a collection</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>collection_name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>hashed_rwset</td><td><a href="#bytes">bytes</a></td><td></td><td>Data model specific serialized proto message (e.g., kvrwset.HashedRWSet for KV and Document data models)</td></tr>
<tr><td>pvt_rwset_hash</td><td><a href="#bytes">bytes</a></td><td></td><td>Hash of entire private read-write set for a specific collection. This helps in authenticating the private read-write set efficiently</td></tr>
</tbody></table>
<p><a name="rwset.CollectionPvtReadWriteSet"></a></p>
<h3><a class="header" href="#collectionpvtreadwriteset" id="collectionpvtreadwriteset">CollectionPvtReadWriteSet</a></h3>
<p>CollectionPvtReadWriteSet encapsulates the private read-write set for a collection</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>collection_name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>rwset</td><td><a href="#bytes">bytes</a></td><td></td><td>Data model specific serialized proto message (e.g., kvrwset.KVRWSet for KV and Document data models)</td></tr>
</tbody></table>
<p><a name="rwset.NsPvtReadWriteSet"></a></p>
<h3><a class="header" href="#nspvtreadwriteset" id="nspvtreadwriteset">NsPvtReadWriteSet</a></h3>
<p>NsPvtReadWriteSet encapsulates the private read-write set for a chaincode</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>namespace</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection_pvt_rwset</td><td><a href="#rwset.CollectionPvtReadWriteSet">CollectionPvtReadWriteSet</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="rwset.NsReadWriteSet"></a></p>
<h3><a class="header" href="#nsreadwriteset" id="nsreadwriteset">NsReadWriteSet</a></h3>
<p>NsReadWriteSet encapsulates the read-write set for a chaincode</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>namespace</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>rwset</td><td><a href="#bytes">bytes</a></td><td></td><td>Data model specific serialized proto message (e.g., kvrwset.KVRWSet for KV and Document data models)</td></tr>
<tr><td>collection_hashed_rwset</td><td><a href="#rwset.CollectionHashedReadWriteSet">CollectionHashedReadWriteSet</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="rwset.TxPvtReadWriteSet"></a></p>
<h3><a class="header" href="#txpvtreadwriteset" id="txpvtreadwriteset">TxPvtReadWriteSet</a></h3>
<p>TxPvtReadWriteSet encapsulate the private read-write set for a transaction</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>data_model</td><td><a href="#rwset.TxReadWriteSet.DataModel">TxReadWriteSet.DataModel</a></td><td></td><td></td></tr>
<tr><td>ns_pvt_rwset</td><td><a href="#rwset.NsPvtReadWriteSet">NsPvtReadWriteSet</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="rwset.TxReadWriteSet"></a></p>
<h3><a class="header" href="#txreadwriteset" id="txreadwriteset">TxReadWriteSet</a></h3>
<p>TxReadWriteSet encapsulates a read-write set for a transaction
DataModel specifies the enum value of the data model
ns_rwset field specifies a list of chaincode specific read-write set (one for each chaincode)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>data_model</td><td><a href="#rwset.TxReadWriteSet.DataModel">TxReadWriteSet.DataModel</a></td><td></td><td></td></tr>
<tr><td>ns_rwset</td><td><a href="#rwset.NsReadWriteSet">NsReadWriteSet</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="rwset.TxReadWriteSet.DataModel"></a></p>
<h3><a class="header" href="#txreadwritesetdatamodel" id="txreadwritesetdatamodel">TxReadWriteSet.DataModel</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>KV</td><td>0</td><td></td></tr>
</tbody></table>
<p><a name="ledger/rwset/kvrwset/kv_rwset.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ledgerrwsetkvrwsetkv_rwsetproto" id="ledgerrwsetkvrwsetkv_rwsetproto">ledger/rwset/kvrwset/kv_rwset.proto</a></h2>
<p><a name="kvrwset.HashedRWSet"></a></p>
<h3><a class="header" href="#hashedrwset" id="hashedrwset">HashedRWSet</a></h3>
<p>HashedRWSet encapsulates hashed representation of a private read-write set for KV or Document data model</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>hashed_reads</td><td><a href="#kvrwset.KVReadHash">KVReadHash</a></td><td>repeated</td><td></td></tr>
<tr><td>hashed_writes</td><td><a href="#kvrwset.KVWriteHash">KVWriteHash</a></td><td>repeated</td><td></td></tr>
<tr><td>metadata_writes</td><td><a href="#kvrwset.KVMetadataWriteHash">KVMetadataWriteHash</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVMetadataEntry"></a></p>
<h3><a class="header" href="#kvmetadataentry" id="kvmetadataentry">KVMetadataEntry</a></h3>
<p>KVMetadataEntry captures a 'name'ed entry in the metadata of a key/key-hash.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVMetadataWrite"></a></p>
<h3><a class="header" href="#kvmetadatawrite" id="kvmetadatawrite">KVMetadataWrite</a></h3>
<p>KVMetadataWrite captures all the entries in the metadata associated with a key</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>entries</td><td><a href="#kvrwset.KVMetadataEntry">KVMetadataEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVMetadataWriteHash"></a></p>
<h3><a class="header" href="#kvmetadatawritehash" id="kvmetadatawritehash">KVMetadataWriteHash</a></h3>
<p>KVMetadataWriteHash captures all the upserts to the metadata associated with a key hash</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key_hash</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>entries</td><td><a href="#kvrwset.KVMetadataEntry">KVMetadataEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVRWSet"></a></p>
<h3><a class="header" href="#kvrwset" id="kvrwset">KVRWSet</a></h3>
<p>KVRWSet encapsulates the read-write set for a chaincode that operates upon a KV or Document data model
This structure is used for both the public data and the private data</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>reads</td><td><a href="#kvrwset.KVRead">KVRead</a></td><td>repeated</td><td></td></tr>
<tr><td>range_queries_info</td><td><a href="#kvrwset.RangeQueryInfo">RangeQueryInfo</a></td><td>repeated</td><td></td></tr>
<tr><td>writes</td><td><a href="#kvrwset.KVWrite">KVWrite</a></td><td>repeated</td><td></td></tr>
<tr><td>metadata_writes</td><td><a href="#kvrwset.KVMetadataWrite">KVMetadataWrite</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVRead"></a></p>
<h3><a class="header" href="#kvread" id="kvread">KVRead</a></h3>
<p>KVRead captures a read operation performed during transaction simulation
A 'nil' version indicates a non-existing key read by the transaction</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#kvrwset.Version">Version</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVReadHash"></a></p>
<h3><a class="header" href="#kvreadhash" id="kvreadhash">KVReadHash</a></h3>
<p>KVReadHash is similar to the KVRead in spirit. However, it captures the hash of the key instead of the key itself
version is kept as is for now. However, if the version also needs to be privacy-protected, it would need to be the
hash of the version and hence of 'bytes' type</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key_hash</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#kvrwset.Version">Version</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVWrite"></a></p>
<h3><a class="header" href="#kvwrite" id="kvwrite">KVWrite</a></h3>
<p>KVWrite captures a write (update/delete) operation performed during transaction simulation</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>is_delete</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.KVWriteHash"></a></p>
<h3><a class="header" href="#kvwritehash" id="kvwritehash">KVWriteHash</a></h3>
<p>KVWriteHash is similar to the KVWrite. It captures a write (update/delete) operation performed during transaction simulation</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key_hash</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>is_delete</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>value_hash</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.QueryReads"></a></p>
<h3><a class="header" href="#queryreads" id="queryreads">QueryReads</a></h3>
<p>QueryReads encapsulates the KVReads for the items read by a transaction as a result of a query execution</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>kv_reads</td><td><a href="#kvrwset.KVRead">KVRead</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.QueryReadsMerkleSummary"></a></p>
<h3><a class="header" href="#queryreadsmerklesummary" id="queryreadsmerklesummary">QueryReadsMerkleSummary</a></h3>
<p>QueryReadsMerkleSummary encapsulates the Merkle-tree hashes for the QueryReads
This allows to reduce the size of RWSet in the presence of query results
by storing certain hashes instead of actual results.
maxDegree field refers to the maximum number of children in the tree at any level
maxLevel field contains the lowest level which has lesser nodes than maxDegree (starting from leaf level)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>max_degree</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
<tr><td>max_level</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
<tr><td>max_level_hashes</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.RangeQueryInfo"></a></p>
<h3><a class="header" href="#rangequeryinfo" id="rangequeryinfo">RangeQueryInfo</a></h3>
<p>RangeQueryInfo encapsulates the details of a range query performed by a transaction during simulation.
This helps protect transactions from phantom reads by varifying during validation whether any new items
got committed within the given range between transaction simuation and validation
(in addition to regular checks for updates/deletes of the existing items).
readInfo field contains either the KVReads (for the items read by the range query) or a merkle-tree hash
if the KVReads exceeds a pre-configured numbers</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>start_key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>end_key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>itr_exhausted</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>raw_reads</td><td><a href="#kvrwset.QueryReads">QueryReads</a></td><td></td><td></td></tr>
<tr><td>reads_merkle_hashes</td><td><a href="#kvrwset.QueryReadsMerkleSummary">QueryReadsMerkleSummary</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="kvrwset.Version"></a></p>
<h3><a class="header" href="#version" id="version">Version</a></h3>
<p>Version encapsulates the version of a Key
A version of a committed key is maintained as the height of the transaction that committed the key.
The height is represenetd as a tuple &lt;blockNum, txNum&gt; where the txNum is the position of the transaction
(starting with 0) within block</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>block_num</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>tx_num</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="ledger/queryresult/kv_query_result.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ledgerqueryresultkv_query_resultproto" id="ledgerqueryresultkv_query_resultproto">ledger/queryresult/kv_query_result.proto</a></h2>
<p><a name="queryresult.KV"></a></p>
<h3><a class="header" href="#kv" id="kv">KV</a></h3>
<p>KV -- QueryResult for range/execute query. Holds a key and corresponding value.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>namespace</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="queryresult.KeyModification"></a></p>
<h3><a class="header" href="#keymodification" id="keymodification">KeyModification</a></h3>
<p>KeyModification -- QueryResult for history query. Holds a transaction ID, value,
timestamp, and delete marker which resulted from a history query.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>tx_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>timestamp</td><td><a href="#google.protobuf.Timestamp">google.protobuf.Timestamp</a></td><td></td><td></td></tr>
<tr><td>is_delete</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery/protocol.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#discoveryprotocolproto" id="discoveryprotocolproto">discovery/protocol.proto</a></h2>
<p><a name="discovery.AuthInfo"></a></p>
<h3><a class="header" href="#authinfo" id="authinfo">AuthInfo</a></h3>
<p>AuthInfo aggregates authentication information that the server uses
to authenticate the client</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>client_identity</td><td><a href="#bytes">bytes</a></td><td></td><td>This is the identity of the client that is used to verify the signature on the SignedRequest's payload. It is a msp.SerializedIdentity in bytes form</td></tr>
<tr><td>client_tls_cert_hash</td><td><a href="#bytes">bytes</a></td><td></td><td>This is the hash of the client's TLS cert. When the network is running with TLS, clients that don't include a certificate will be denied access to the service. Since the Request is encapsulated with a SignedRequest (which is signed), this binds the TLS session to the enrollement identity of the client and therefore both authenticates the client to the server, and also prevents the server from relaying the request message to another server.</td></tr>
</tbody></table>
<p><a name="discovery.ChaincodeCall"></a></p>
<h3><a class="header" href="#chaincodecall" id="chaincodecall">ChaincodeCall</a></h3>
<p>ChaincodeCall defines a call to a chaincode.
It may have collections that are related to the chaincode</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection_names</td><td><a href="#string">string</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="discovery.ChaincodeInterest"></a></p>
<h3><a class="header" href="#chaincodeinterest" id="chaincodeinterest">ChaincodeInterest</a></h3>
<p>ChaincodeInterest defines an interest about an endorsement
for a specific single chaincode invocation.
Multiple chaincodes indicate chaincode to chaincode invocations.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincodes</td><td><a href="#discovery.ChaincodeCall">ChaincodeCall</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="discovery.ChaincodeQuery"></a></p>
<h3><a class="header" href="#chaincodequery" id="chaincodequery">ChaincodeQuery</a></h3>
<p>ChaincodeQuery requests ChaincodeQueryResults for a given
list of chaincode invocations.
Each invocation is a separate one, and the endorsement policy
is evaluated independantly for each given interest.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>interests</td><td><a href="#discovery.ChaincodeInterest">ChaincodeInterest</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="discovery.ChaincodeQueryResult"></a></p>
<h3><a class="header" href="#chaincodequeryresult" id="chaincodequeryresult">ChaincodeQueryResult</a></h3>
<p>ChaincodeQueryResult contains EndorsementDescriptors for
chaincodes</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>content</td><td><a href="#discovery.EndorsementDescriptor">EndorsementDescriptor</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="discovery.ConfigQuery"></a></p>
<h3><a class="header" href="#configquery" id="configquery">ConfigQuery</a></h3>
<p>ConfigQuery requests a ConfigResult</p>
<p><a name="discovery.ConfigResult"></a></p>
<h3><a class="header" href="#configresult" id="configresult">ConfigResult</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>msps</td><td><a href="#discovery.ConfigResult.MspsEntry">ConfigResult.MspsEntry</a></td><td>repeated</td><td>msps is a map from MSP_ID to FabricMSPConfig</td></tr>
<tr><td>orderers</td><td><a href="#discovery.ConfigResult.OrderersEntry">ConfigResult.OrderersEntry</a></td><td>repeated</td><td>orderers is a map from MSP_ID to endpoint lists of orderers</td></tr>
</tbody></table>
<p><a name="discovery.ConfigResult.MspsEntry"></a></p>
<h3><a class="header" href="#configresultmspsentry" id="configresultmspsentry">ConfigResult.MspsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#msp.FabricMSPConfig">msp.FabricMSPConfig</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.ConfigResult.OrderersEntry"></a></p>
<h3><a class="header" href="#configresultorderersentry" id="configresultorderersentry">ConfigResult.OrderersEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#discovery.Endpoints">Endpoints</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.EndorsementDescriptor"></a></p>
<h3><a class="header" href="#endorsementdescriptor" id="endorsementdescriptor">EndorsementDescriptor</a></h3>
<p>EndorsementDescriptor contains information about which peers can be used
to request endorsement from, such that the endorsement policy would be fulfilled.
Here is how to compute a set of peers to ask an endorsement from, given an EndorsementDescriptor:
Let e: G --&gt; P be the endorsers_by_groups field that maps a group to a set of peers.
Note that applying e on a group g yields a set of peers.</p>
<ol>
<li>Select a layout l: G --&gt; N out of the layouts given.
l is the quantities_by_group field of a Layout, and it maps a group to an integer.</li>
<li>R = {}  (an empty set of peers)</li>
<li>For each group g in the layout l, compute n = l(g)
3.1) Denote P_g as a set of n random peers {p0, p1, ... p_n} selected from e(g)
3.2) R = R U P_g  (add P_g to R)</li>
<li>The set of peers R is the peers the client needs to request endorsements from</li>
</ol>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>chaincode</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>endorsers_by_groups</td><td><a href="#discovery.EndorsementDescriptor.EndorsersByGroupsEntry">EndorsementDescriptor.EndorsersByGroupsEntry</a></td><td>repeated</td><td>Specifies the endorsers, separated to groups.</td></tr>
<tr><td>layouts</td><td><a href="#discovery.Layout">Layout</a></td><td>repeated</td><td>Specifies options of fulfulling the endorsement policy. Each option lists the group names, and the amount of signatures needed from each group.</td></tr>
</tbody></table>
<p><a name="discovery.EndorsementDescriptor.EndorsersByGroupsEntry"></a></p>
<h3><a class="header" href="#endorsementdescriptorendorsersbygroupsentry" id="endorsementdescriptorendorsersbygroupsentry">EndorsementDescriptor.EndorsersByGroupsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#discovery.Peers">Peers</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.Endpoint"></a></p>
<h3><a class="header" href="#endpoint" id="endpoint">Endpoint</a></h3>
<p>Endpoint is a combination of a host and a port</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>host</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>port</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.Endpoints"></a></p>
<h3><a class="header" href="#endpoints" id="endpoints">Endpoints</a></h3>
<p>Endpoints is a list of Endpoint(s)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>endpoint</td><td><a href="#discovery.Endpoint">Endpoint</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="discovery.Error"></a></p>
<h3><a class="header" href="#error" id="error">Error</a></h3>
<p>Error denotes that something went wrong and contains the error message</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>content</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.Layout"></a></p>
<h3><a class="header" href="#layout" id="layout">Layout</a></h3>
<p>Layout contains a mapping from a group name to number of peers
that are needed for fulfilling an endorsement policy</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>quantities_by_group</td><td><a href="#discovery.Layout.QuantitiesByGroupEntry">Layout.QuantitiesByGroupEntry</a></td><td>repeated</td><td>Specifies how many non repeated signatures of each group are needed for endorsement</td></tr>
</tbody></table>
<p><a name="discovery.Layout.QuantitiesByGroupEntry"></a></p>
<h3><a class="header" href="#layoutquantitiesbygroupentry" id="layoutquantitiesbygroupentry">Layout.QuantitiesByGroupEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.LocalPeerQuery"></a></p>
<h3><a class="header" href="#localpeerquery" id="localpeerquery">LocalPeerQuery</a></h3>
<p>LocalPeerQuery queries for peers in a non channel context</p>
<p><a name="discovery.Peer"></a></p>
<h3><a class="header" href="#peer" id="peer">Peer</a></h3>
<p>Peer contains information about the peer such as its channel specific
state, and membership information.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>state_info</td><td><a href="#gossip.Envelope">gossip.Envelope</a></td><td></td><td>This is an Envelope of a GossipMessage with a gossip.StateInfo message</td></tr>
<tr><td>membership_info</td><td><a href="#gossip.Envelope">gossip.Envelope</a></td><td></td><td>This is an Envelope of a GossipMessage with a gossip.AliveMessage message</td></tr>
<tr><td>identity</td><td><a href="#bytes">bytes</a></td><td></td><td>This is the msp.SerializedIdentity of the peer, represented in bytes.</td></tr>
</tbody></table>
<p><a name="discovery.PeerMembershipQuery"></a></p>
<h3><a class="header" href="#peermembershipquery" id="peermembershipquery">PeerMembershipQuery</a></h3>
<p>PeerMembershipQuery requests PeerMembershipResult.
The filter field may be optionally populated in order
for the peer membership to be filtered according to
chaincodes that are installed on peers and collection
access control policies.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>filter</td><td><a href="#discovery.ChaincodeInterest">ChaincodeInterest</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.PeerMembershipResult"></a></p>
<h3><a class="header" href="#peermembershipresult" id="peermembershipresult">PeerMembershipResult</a></h3>
<p>PeerMembershipResult contains peers mapped by their organizations (MSP_ID)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>peers_by_org</td><td><a href="#discovery.PeerMembershipResult.PeersByOrgEntry">PeerMembershipResult.PeersByOrgEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="discovery.PeerMembershipResult.PeersByOrgEntry"></a></p>
<h3><a class="header" href="#peermembershipresultpeersbyorgentry" id="peermembershipresultpeersbyorgentry">PeerMembershipResult.PeersByOrgEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#discovery.Peers">Peers</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.Peers"></a></p>
<h3><a class="header" href="#peers" id="peers">Peers</a></h3>
<p>Peers contains a list of Peer(s)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>peers</td><td><a href="#discovery.Peer">Peer</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="discovery.Query"></a></p>
<h3><a class="header" href="#query" id="query">Query</a></h3>
<p>Query asks for information in the context of a specific channel</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>config_query</td><td><a href="#discovery.ConfigQuery">ConfigQuery</a></td><td></td><td>ConfigQuery is used to query for the configuration of the channel, such as FabricMSPConfig, and rorderer endpoints. The client has to query a peer it trusts as it doesn't have means to self-verify the authenticity of the returned result. The result is returned in the form of ConfigResult.</td></tr>
<tr><td>peer_query</td><td><a href="#discovery.PeerMembershipQuery">PeerMembershipQuery</a></td><td></td><td>PeerMembershipQuery queries for peers in a channel context, and returns PeerMembershipResult</td></tr>
<tr><td>cc_query</td><td><a href="#discovery.ChaincodeQuery">ChaincodeQuery</a></td><td></td><td>ChaincodeQuery queries for chaincodes by their name and version. An empty version means any version can by returned.</td></tr>
<tr><td>local_peers</td><td><a href="#discovery.LocalPeerQuery">LocalPeerQuery</a></td><td></td><td>LocalPeerQuery queries for peers in a non channel context, and returns PeerMembershipResult</td></tr>
</tbody></table>
<p><a name="discovery.QueryResult"></a></p>
<h3><a class="header" href="#queryresult" id="queryresult">QueryResult</a></h3>
<p>QueryResult contains a result for a given Query.
The corresponding Query can be inferred by the index of the QueryResult from
its enclosing Response message.
QueryResults are ordered in the same order as the Queries are ordered in their enclosing Request.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="#discovery.Error">Error</a></td><td></td><td>Error indicates failure or refusal to process the query</td></tr>
<tr><td>config_result</td><td><a href="#discovery.ConfigResult">ConfigResult</a></td><td></td><td>ConfigResult contains the configuration of the channel, such as FabricMSPConfig and orderer endpoints</td></tr>
<tr><td>cc_query_res</td><td><a href="#discovery.ChaincodeQueryResult">ChaincodeQueryResult</a></td><td></td><td>ChaincodeQueryResult contains information about chaincodes, and their corresponding endorsers</td></tr>
<tr><td>members</td><td><a href="#discovery.PeerMembershipResult">PeerMembershipResult</a></td><td></td><td>PeerMembershipResult contains information about peers, such as their identity, endpoints, and channel related state.</td></tr>
</tbody></table>
<p><a name="discovery.Request"></a></p>
<h3><a class="header" href="#request" id="request">Request</a></h3>
<p>Request contains authentication info about the client that sent the request
and the queries it wishes to query the service</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>authentication</td><td><a href="#discovery.AuthInfo">AuthInfo</a></td><td></td><td>authentication contains information that the service uses to check the client's eligibility for the queries.</td></tr>
<tr><td>queries</td><td><a href="#discovery.Query">Query</a></td><td>repeated</td><td>queries</td></tr>
</tbody></table>
<p><a name="discovery.Response"></a></p>
<h3><a class="header" href="#response-1" id="response-1">Response</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>results</td><td><a href="#discovery.QueryResult">QueryResult</a></td><td>repeated</td><td>The results are returned in the same order of the queries</td></tr>
</tbody></table>
<p><a name="discovery.SignedRequest"></a></p>
<h3><a class="header" href="#signedrequest" id="signedrequest">SignedRequest</a></h3>
<p>SignedRequest contains a serialized Request in the payload field
and a signature.
The identity that is used to verify the signature
can be extracted from the authentication field of type AuthInfo
in the Request itself after deserializing it.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="discovery.Discovery"></a></p>
<h3><a class="header" href="#discovery" id="discovery">Discovery</a></h3>
<p>Discovery defines a service that serves information about the fabric network
like which peers, orderers, chaincodes, etc.</p>
<table><thead><tr><th>Method Name</th><th>Request Type</th><th>Response Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Discover</td><td><a href="#discovery.SignedRequest">SignedRequest</a></td><td><a href="#discovery.Response">Response</a></td><td>Discover receives a signed request, and returns a response.</td></tr>
</tbody></table>
<p><a name="orderer/configuration.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ordererconfigurationproto" id="ordererconfigurationproto">orderer/configuration.proto</a></h2>
<p><a name="orderer.BatchSize"></a></p>
<h3><a class="header" href="#batchsize" id="batchsize">BatchSize</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>max_message_count</td><td><a href="#uint32">uint32</a></td><td></td><td>Simply specified as number of messages for now, in the future we may want to allow this to be specified by size in bytes</td></tr>
<tr><td>absolute_max_bytes</td><td><a href="#uint32">uint32</a></td><td></td><td>The byte count of the serialized messages in a batch cannot exceed this value.</td></tr>
<tr><td>preferred_max_bytes</td><td><a href="#uint32">uint32</a></td><td></td><td>The byte count of the serialized messages in a batch should not exceed this value.</td></tr>
</tbody></table>
<p><a name="orderer.BatchTimeout"></a></p>
<h3><a class="header" href="#batchtimeout" id="batchtimeout">BatchTimeout</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>timeout</td><td><a href="#string">string</a></td><td></td><td>Any duration string parseable by ParseDuration(): https://golang.org/pkg/time/#ParseDuration</td></tr>
</tbody></table>
<p><a name="orderer.ChannelRestrictions"></a></p>
<h3><a class="header" href="#channelrestrictions" id="channelrestrictions">ChannelRestrictions</a></h3>
<p>ChannelRestrictions is the mssage which conveys restrictions on channel creation for an orderer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>max_count</td><td><a href="#uint64">uint64</a></td><td></td><td>The max count of channels to allow to be created, a value of 0 indicates no limit</td></tr>
</tbody></table>
<p><a name="orderer.ConsensusType"></a></p>
<h3><a class="header" href="#consensustype" id="consensustype">ConsensusType</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><a href="#string">string</a></td><td></td><td>The consensus type: &quot;solo&quot;, &quot;kafka&quot; or &quot;etcdraft&quot;.</td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td>Opaque metadata, dependent on the consensus type.</td></tr>
<tr><td>state</td><td><a href="#orderer.ConsensusType.State">ConsensusType.State</a></td><td></td><td>The state signals the ordering service to go into maintenance mode, typically for consensus-type migration.</td></tr>
</tbody></table>
<p><a name="orderer.KafkaBrokers"></a></p>
<h3><a class="header" href="#kafkabrokers" id="kafkabrokers">KafkaBrokers</a></h3>
<p>Carries a list of bootstrap brokers, i.e. this is not the exclusive set of
brokers an ordering service</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>brokers</td><td><a href="#string">string</a></td><td>repeated</td><td>Each broker here should be identified using the (IP</td></tr>
</tbody></table>
<p><a name="orderer.ConsensusType.State"></a></p>
<h3><a class="header" href="#consensustypestate" id="consensustypestate">ConsensusType.State</a></h3>
<p>State defines the orderer mode of operation, typically for consensus-type migration.
NORMAL is during normal operation, when consensus-type migration is not, and can not, take place.
MAINTENANCE is when the consensus-type can be changed.</p>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>STATE_NORMAL</td><td>0</td><td></td></tr>
<tr><td>STATE_MAINTENANCE</td><td>1</td><td></td></tr>
</tbody></table>
<p><a name="orderer/kafka.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ordererkafkaproto" id="ordererkafkaproto">orderer/kafka.proto</a></h2>
<p><a name="orderer.KafkaMessage"></a></p>
<h3><a class="header" href="#kafkamessage" id="kafkamessage">KafkaMessage</a></h3>
<p>KafkaMessage is a wrapper type for the messages
that the Kafka-based orderer deals with.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>regular</td><td><a href="#orderer.KafkaMessageRegular">KafkaMessageRegular</a></td><td></td><td></td></tr>
<tr><td>time_to_cut</td><td><a href="#orderer.KafkaMessageTimeToCut">KafkaMessageTimeToCut</a></td><td></td><td></td></tr>
<tr><td>connect</td><td><a href="#orderer.KafkaMessageConnect">KafkaMessageConnect</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.KafkaMessageConnect"></a></p>
<h3><a class="header" href="#kafkamessageconnect" id="kafkamessageconnect">KafkaMessageConnect</a></h3>
<p>KafkaMessageConnect is posted by an orderer upon booting up.
It is used to prevent the panic that would be caused if we
were to consume an empty partition. It is ignored by all
orderers when processing the partition.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.KafkaMessageRegular"></a></p>
<h3><a class="header" href="#kafkamessageregular" id="kafkamessageregular">KafkaMessageRegular</a></h3>
<p>KafkaMessageRegular wraps a marshalled envelope.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>config_seq</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>class</td><td><a href="#orderer.KafkaMessageRegular.Class">KafkaMessageRegular.Class</a></td><td></td><td></td></tr>
<tr><td>original_offset</td><td><a href="#int64">int64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.KafkaMessageTimeToCut"></a></p>
<h3><a class="header" href="#kafkamessagetimetocut" id="kafkamessagetimetocut">KafkaMessageTimeToCut</a></h3>
<p>KafkaMessageTimeToCut is used to signal to the orderers
that it is time to cut block &lt;block_number&gt;.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>block_number</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.KafkaMetadata"></a></p>
<h3><a class="header" href="#kafkametadata" id="kafkametadata">KafkaMetadata</a></h3>
<p>KafkaMetadata is encoded into the ORDERER block to keep track of
Kafka-related metadata associated with this block.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>last_offset_persisted</td><td><a href="#int64">int64</a></td><td></td><td>LastOffsetPersisted is the encoded value for the Metadata message which is encoded in the ORDERER block metadata index for the case of the Kafka-based orderer.</td></tr>
<tr><td>last_original_offset_processed</td><td><a href="#int64">int64</a></td><td></td><td>LastOriginalOffsetProcessed is used to keep track of the newest offset processed if a message is re-validated and re-ordered. This value is used to deduplicate re-submitted messages from multiple orderer so that we don't bother re-processing it again.</td></tr>
<tr><td>last_resubmitted_config_offset</td><td><a href="#int64">int64</a></td><td></td><td>LastResubmittedConfigOffset is used to capture the newest offset of CONFIG kafka message, which is revalidated and resubmitted. By comparing this with LastOriginalOffsetProcessed, we could detemine whether there are still CONFIG messages that have been resubmitted but NOT processed yet. It's used as condition to block ingress messages, so we could reduce the overhead of repeatedly resubmitting messages as config seq keeps advancing.</td></tr>
</tbody></table>
<p><a name="orderer.KafkaMessageRegular.Class"></a></p>
<h3><a class="header" href="#kafkamessageregularclass" id="kafkamessageregularclass">KafkaMessageRegular.Class</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>UNKNOWN</td><td>0</td><td></td></tr>
<tr><td>NORMAL</td><td>1</td><td></td></tr>
<tr><td>CONFIG</td><td>2</td><td></td></tr>
</tbody></table>
<p><a name="orderer/ab.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ordererabproto" id="ordererabproto">orderer/ab.proto</a></h2>
<p><a name="orderer.BroadcastResponse"></a></p>
<h3><a class="header" href="#broadcastresponse" id="broadcastresponse">BroadcastResponse</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>status</td><td><a href="#common.Status">common.Status</a></td><td></td><td>Status code, which may be used to programatically respond to success/failure</td></tr>
<tr><td>info</td><td><a href="#string">string</a></td><td></td><td>Info string which may contain additional information about the status returned</td></tr>
</tbody></table>
<p><a name="orderer.DeliverResponse"></a></p>
<h3><a class="header" href="#deliverresponse-1" id="deliverresponse-1">DeliverResponse</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>status</td><td><a href="#common.Status">common.Status</a></td><td></td><td></td></tr>
<tr><td>block</td><td><a href="#common.Block">common.Block</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.SeekInfo"></a></p>
<h3><a class="header" href="#seekinfo" id="seekinfo">SeekInfo</a></h3>
<p>SeekInfo specifies the range of requested blocks to return
If the start position is not found, an error is immediately returned
Otherwise, blocks are returned until a missing block is encountered, then behavior is dictated
by the SeekBehavior specified.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>start</td><td><a href="#orderer.SeekPosition">SeekPosition</a></td><td></td><td>The position to start the deliver from</td></tr>
<tr><td>stop</td><td><a href="#orderer.SeekPosition">SeekPosition</a></td><td></td><td>The position to stop the deliver</td></tr>
<tr><td>behavior</td><td><a href="#orderer.SeekInfo.SeekBehavior">SeekInfo.SeekBehavior</a></td><td></td><td>The behavior when a missing block is encountered</td></tr>
<tr><td>error_response</td><td><a href="#orderer.SeekInfo.SeekErrorResponse">SeekInfo.SeekErrorResponse</a></td><td></td><td>How to respond to errors reported to the deliver service</td></tr>
</tbody></table>
<p><a name="orderer.SeekNewest"></a></p>
<h3><a class="header" href="#seeknewest" id="seeknewest">SeekNewest</a></h3>
<p><a name="orderer.SeekOldest"></a></p>
<h3><a class="header" href="#seekoldest" id="seekoldest">SeekOldest</a></h3>
<p><a name="orderer.SeekPosition"></a></p>
<h3><a class="header" href="#seekposition" id="seekposition">SeekPosition</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>newest</td><td><a href="#orderer.SeekNewest">SeekNewest</a></td><td></td><td></td></tr>
<tr><td>oldest</td><td><a href="#orderer.SeekOldest">SeekOldest</a></td><td></td><td></td></tr>
<tr><td>specified</td><td><a href="#orderer.SeekSpecified">SeekSpecified</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.SeekSpecified"></a></p>
<h3><a class="header" href="#seekspecified" id="seekspecified">SeekSpecified</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>number</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.SeekInfo.SeekBehavior"></a></p>
<h3><a class="header" href="#seekinfoseekbehavior" id="seekinfoseekbehavior">SeekInfo.SeekBehavior</a></h3>
<p>If BLOCK_UNTIL_READY is specified, the reply will block until the requested blocks are available,
if FAIL_IF_NOT_READY is specified, the reply will return an error indicating that the block is not
found.  To request that all blocks be returned indefinitely as they are created, behavior should be
set to BLOCK_UNTIL_READY and the stop should be set to specified with a number of MAX_UINT64</p>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>BLOCK_UNTIL_READY</td><td>0</td><td></td></tr>
<tr><td>FAIL_IF_NOT_READY</td><td>1</td><td></td></tr>
</tbody></table>
<p><a name="orderer.SeekInfo.SeekErrorResponse"></a></p>
<h3><a class="header" href="#seekinfoseekerrorresponse" id="seekinfoseekerrorresponse">SeekInfo.SeekErrorResponse</a></h3>
<p>SeekErrorTolerance indicates to the server how block provider errors should be tolerated.  By default,
if the deliver service detects a problem in the underlying block source (typically, in the orderer,
a consenter error), it will begin to reject deliver requests.  This is to prevent a client from waiting
for blocks from an orderer which is stuck in an errored state.  This is almost always the desired behavior
and clients should stick with the default STRICT checking behavior.  However, in some scenarios, particularly
when attempting to recover from a crash or other corruption, it's desirable to force an orderer to respond
with blocks on a best effort basis, even if the backing consensus implementation is in an errored state.
In this case, set the SeekErrorResponse to BEST_EFFORT to ignore the consenter errors.</p>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>STRICT</td><td>0</td><td></td></tr>
<tr><td>BEST_EFFORT</td><td>1</td><td></td></tr>
</tbody></table>
<p><a name="orderer.AtomicBroadcast"></a></p>
<h3><a class="header" href="#atomicbroadcast" id="atomicbroadcast">AtomicBroadcast</a></h3>
<table><thead><tr><th>Method Name</th><th>Request Type</th><th>Response Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Broadcast</td><td><a href="#common.Envelope">.common.Envelope</a> stream</td><td><a href="#orderer.BroadcastResponse">BroadcastResponse</a> stream</td><td>broadcast receives a reply of Acknowledgement for each common.Envelope in order, indicating success or type of failure</td></tr>
<tr><td>Deliver</td><td><a href="#common.Envelope">.common.Envelope</a> stream</td><td><a href="#orderer.DeliverResponse">DeliverResponse</a> stream</td><td>deliver first requires an Envelope of type DELIVER_SEEK_INFO with Payload data as a mashaled SeekInfo message, then a stream of block replies is received.</td></tr>
</tbody></table>
<p><a name="orderer/cluster.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ordererclusterproto" id="ordererclusterproto">orderer/cluster.proto</a></h2>
<p><a name="orderer.ConsensusRequest"></a></p>
<h3><a class="header" href="#consensusrequest" id="consensusrequest">ConsensusRequest</a></h3>
<p>ConsensusRequest is a consensus specific message sent to a cluster member.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.StepRequest"></a></p>
<h3><a class="header" href="#steprequest" id="steprequest">StepRequest</a></h3>
<p>StepRequest wraps a message that is sent to a cluster member.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>consensus_request</td><td><a href="#orderer.ConsensusRequest">ConsensusRequest</a></td><td></td><td>consensus_request is a consensus specific message.</td></tr>
<tr><td>submit_request</td><td><a href="#orderer.SubmitRequest">SubmitRequest</a></td><td></td><td>submit_request is a relay of a transaction.</td></tr>
</tbody></table>
<p><a name="orderer.StepResponse"></a></p>
<h3><a class="header" href="#stepresponse" id="stepresponse">StepResponse</a></h3>
<p>StepResponse is a message received from a cluster member.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>submit_res</td><td><a href="#orderer.SubmitResponse">SubmitResponse</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="orderer.SubmitRequest"></a></p>
<h3><a class="header" href="#submitrequest" id="submitrequest">SubmitRequest</a></h3>
<p>SubmitRequest wraps a transaction to be sent for ordering.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>last_validation_seq</td><td><a href="#uint64">uint64</a></td><td></td><td>last_validation_seq denotes the last configuration sequence at which the sender validated this message.</td></tr>
<tr><td>payload</td><td><a href="#common.Envelope">common.Envelope</a></td><td></td><td>content is the fabric transaction that is forwarded to the cluster member.</td></tr>
</tbody></table>
<p><a name="orderer.SubmitResponse"></a></p>
<h3><a class="header" href="#submitresponse" id="submitresponse">SubmitResponse</a></h3>
<p>SubmitResponse returns a success
or failure status to the sender.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>status</td><td><a href="#common.Status">common.Status</a></td><td></td><td>Status code, which may be used to programatically respond to success/failure.</td></tr>
<tr><td>info</td><td><a href="#string">string</a></td><td></td><td>Info string which may contain additional information about the returned status.</td></tr>
</tbody></table>
<p><a name="orderer.Cluster"></a></p>
<h3><a class="header" href="#cluster" id="cluster">Cluster</a></h3>
<p>Cluster defines communication between cluster members.</p>
<table><thead><tr><th>Method Name</th><th>Request Type</th><th>Response Type</th><th>Description</th></tr></thead><tbody>
<tr><td>Step</td><td><a href="#orderer.StepRequest">StepRequest</a> stream</td><td><a href="#orderer.StepResponse">StepResponse</a> stream</td><td>Step passes an implementation-specific message to another cluster member.</td></tr>
</tbody></table>
<p><a name="orderer/etcdraft/configuration.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ordereretcdraftconfigurationproto" id="ordereretcdraftconfigurationproto">orderer/etcdraft/configuration.proto</a></h2>
<p><a name="etcdraft.ConfigMetadata"></a></p>
<h3><a class="header" href="#configmetadata" id="configmetadata">ConfigMetadata</a></h3>
<p>ConfigMetadata is serialized and set as the value of ConsensusType.Metadata in
a channel configuration when the ConsensusType.Type is set &quot;etcdraft&quot;.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>consenters</td><td><a href="#etcdraft.Consenter">Consenter</a></td><td>repeated</td><td></td></tr>
<tr><td>options</td><td><a href="#etcdraft.Options">Options</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="etcdraft.Consenter"></a></p>
<h3><a class="header" href="#consenter" id="consenter">Consenter</a></h3>
<p>Consenter represents a consenting node (i.e. replica).</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>host</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>port</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
<tr><td>client_tls_cert</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>server_tls_cert</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="etcdraft.Options"></a></p>
<h3><a class="header" href="#options" id="options">Options</a></h3>
<p>Options to be specified for all the etcd/raft nodes. These can be modified on a
per-channel basis.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>tick_interval</td><td><a href="#string">string</a></td><td></td><td>time duration format, e.g. 500ms</td></tr>
<tr><td>election_tick</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
<tr><td>heartbeat_tick</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
<tr><td>max_inflight_blocks</td><td><a href="#uint32">uint32</a></td><td></td><td></td></tr>
<tr><td>snapshot_interval_size</td><td><a href="#uint32">uint32</a></td><td></td><td>Take snapshot when cumulative data exceeds certain size in bytes.</td></tr>
</tbody></table>
<p><a name="orderer/etcdraft/metadata.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#ordereretcdraftmetadataproto" id="ordereretcdraftmetadataproto">orderer/etcdraft/metadata.proto</a></h2>
<p><a name="etcdraft.BlockMetadata"></a></p>
<h3><a class="header" href="#blockmetadata" id="blockmetadata">BlockMetadata</a></h3>
<p>BlockMetadata stores data used by the Raft OSNs when
coordinating with each other, to be serialized into
block meta dta field and used after failres and restarts.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>consenter_ids</td><td><a href="#uint64">uint64</a></td><td>repeated</td><td>Maintains a mapping between the cluster's OSNs and their Raft IDs.</td></tr>
<tr><td>next_consenter_id</td><td><a href="#uint64">uint64</a></td><td></td><td>Carries the Raft ID value that will be assigned to the next OSN that will join this cluster.</td></tr>
<tr><td>raft_index</td><td><a href="#uint64">uint64</a></td><td></td><td>Index of etcd/raft entry for current block.</td></tr>
</tbody></table>
<p><a name="etcdraft.ClusterMetadata"></a></p>
<h3><a class="header" href="#clustermetadata" id="clustermetadata">ClusterMetadata</a></h3>
<p>ClusterMetadata encapsulates metadata that is exchanged among cluster nodes</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>active_nodes</td><td><a href="#uint64">uint64</a></td><td>repeated</td><td>Indicates active nodes in cluster that are reacheable by Raft leader</td></tr>
</tbody></table>
<p><a name="gossip/message.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#gossipmessageproto" id="gossipmessageproto">gossip/message.proto</a></h2>
<p><a name="gossip.Acknowledgement"></a></p>
<h3><a class="header" href="#acknowledgement" id="acknowledgement">Acknowledgement</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>error</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.AliveMessage"></a></p>
<h3><a class="header" href="#alivemessage" id="alivemessage">AliveMessage</a></h3>
<p>AliveMessage is sent to inform remote peers
of a peer's existence and activity</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>membership</td><td><a href="#gossip.Member">Member</a></td><td></td><td></td></tr>
<tr><td>timestamp</td><td><a href="#gossip.PeerTime">PeerTime</a></td><td></td><td></td></tr>
<tr><td>identity</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.Chaincode"></a></p>
<h3><a class="header" href="#chaincode" id="chaincode">Chaincode</a></h3>
<p>Chaincode represents a Chaincode that is installed
on a peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>version</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.ConnEstablish"></a></p>
<h3><a class="header" href="#connestablish" id="connestablish">ConnEstablish</a></h3>
<p>ConnEstablish is the message used for the gossip handshake
Whenever a peer connects to another peer, it handshakes
with it by sending this message that proves its identity</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>pki_id</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>identity</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>tls_cert_hash</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.DataDigest"></a></p>
<h3><a class="header" href="#datadigest" id="datadigest">DataDigest</a></h3>
<p>DataDigest is the message sent from the receiver peer
to the initator peer and contains the data items it has</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>nonce</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>digests</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>Maybe change this to bitmap later on</td></tr>
<tr><td>msg_type</td><td><a href="#gossip.PullMsgType">PullMsgType</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.DataMessage"></a></p>
<h3><a class="header" href="#datamessage" id="datamessage">DataMessage</a></h3>
<p>DataMessage is the message that contains a block</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#gossip.Payload">Payload</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.DataRequest"></a></p>
<h3><a class="header" href="#datarequest" id="datarequest">DataRequest</a></h3>
<p>DataRequest is a message used for a peer to request
certain data blocks from a remote peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>nonce</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>digests</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td></td></tr>
<tr><td>msg_type</td><td><a href="#gossip.PullMsgType">PullMsgType</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.DataUpdate"></a></p>
<h3><a class="header" href="#dataupdate" id="dataupdate">DataUpdate</a></h3>
<p>DataUpdate is the final message in the pull phase
sent from the receiver to the initiator</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>nonce</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>data</td><td><a href="#gossip.Envelope">Envelope</a></td><td>repeated</td><td></td></tr>
<tr><td>msg_type</td><td><a href="#gossip.PullMsgType">PullMsgType</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.Empty"></a></p>
<h3><a class="header" href="#empty" id="empty">Empty</a></h3>
<p>Empty is used for pinging and in tests</p>
<p><a name="gossip.Envelope"></a></p>
<h3><a class="header" href="#envelope" id="envelope">Envelope</a></h3>
<p>Envelope contains a marshalled
GossipMessage and a signature over it.
It may also contain a SecretEnvelope
which is a marshalled Secret</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>secret_envelope</td><td><a href="#gossip.SecretEnvelope">SecretEnvelope</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.GossipHello"></a></p>
<h3><a class="header" href="#gossiphello" id="gossiphello">GossipHello</a></h3>
<p>GossipHello is the message that is used for the peer to initiate
a pull round with another peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>nonce</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>msg_type</td><td><a href="#gossip.PullMsgType">PullMsgType</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.GossipMessage"></a></p>
<h3><a class="header" href="#gossipmessage" id="gossipmessage">GossipMessage</a></h3>
<p>GossipMessage defines the message sent in a gossip network</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>nonce</td><td><a href="#uint64">uint64</a></td><td></td><td>used mainly for testing, but will might be used in the future for ensuring message delivery by acking</td></tr>
<tr><td>channel</td><td><a href="#bytes">bytes</a></td><td></td><td>The channel of the message. Some GossipMessages may set this to nil, because they are cross-channels but some may not</td></tr>
<tr><td>tag</td><td><a href="#gossip.GossipMessage.Tag">GossipMessage.Tag</a></td><td></td><td>determines to which peers it is allowed to forward the message</td></tr>
<tr><td>alive_msg</td><td><a href="#gossip.AliveMessage">AliveMessage</a></td><td></td><td>Membership</td></tr>
<tr><td>mem_req</td><td><a href="#gossip.MembershipRequest">MembershipRequest</a></td><td></td><td></td></tr>
<tr><td>mem_res</td><td><a href="#gossip.MembershipResponse">MembershipResponse</a></td><td></td><td></td></tr>
<tr><td>data_msg</td><td><a href="#gossip.DataMessage">DataMessage</a></td><td></td><td>Contains a ledger block</td></tr>
<tr><td>hello</td><td><a href="#gossip.GossipHello">GossipHello</a></td><td></td><td>Used for push&amp;pull</td></tr>
<tr><td>data_dig</td><td><a href="#gossip.DataDigest">DataDigest</a></td><td></td><td></td></tr>
<tr><td>data_req</td><td><a href="#gossip.DataRequest">DataRequest</a></td><td></td><td></td></tr>
<tr><td>data_update</td><td><a href="#gossip.DataUpdate">DataUpdate</a></td><td></td><td></td></tr>
<tr><td>empty</td><td><a href="#gossip.Empty">Empty</a></td><td></td><td>Empty message, used for pinging</td></tr>
<tr><td>conn</td><td><a href="#gossip.ConnEstablish">ConnEstablish</a></td><td></td><td>ConnEstablish, used for establishing a connection</td></tr>
<tr><td>state_info</td><td><a href="#gossip.StateInfo">StateInfo</a></td><td></td><td>Used for relaying information about state</td></tr>
<tr><td>state_snapshot</td><td><a href="#gossip.StateInfoSnapshot">StateInfoSnapshot</a></td><td></td><td>Used for sending sets of StateInfo messages</td></tr>
<tr><td>state_info_pull_req</td><td><a href="#gossip.StateInfoPullRequest">StateInfoPullRequest</a></td><td></td><td>Used for asking for StateInfoSnapshots</td></tr>
<tr><td>state_request</td><td><a href="#gossip.RemoteStateRequest">RemoteStateRequest</a></td><td></td><td>Used to ask from a remote peer a set of blocks</td></tr>
<tr><td>state_response</td><td><a href="#gossip.RemoteStateResponse">RemoteStateResponse</a></td><td></td><td>Used to send a set of blocks to a remote peer</td></tr>
<tr><td>leadership_msg</td><td><a href="#gossip.LeadershipMessage">LeadershipMessage</a></td><td></td><td>Used to indicate intent of peer to become leader</td></tr>
<tr><td>peer_identity</td><td><a href="#gossip.PeerIdentity">PeerIdentity</a></td><td></td><td>Used to learn of a peer's certificate</td></tr>
<tr><td>ack</td><td><a href="#gossip.Acknowledgement">Acknowledgement</a></td><td></td><td></td></tr>
<tr><td>privateReq</td><td><a href="#gossip.RemotePvtDataRequest">RemotePvtDataRequest</a></td><td></td><td>Used to request private data</td></tr>
<tr><td>privateRes</td><td><a href="#gossip.RemotePvtDataResponse">RemotePvtDataResponse</a></td><td></td><td>Used to respond to private data requests</td></tr>
<tr><td>private_data</td><td><a href="#gossip.PrivateDataMessage">PrivateDataMessage</a></td><td></td><td>Encapsulates private data used to distribute private rwset after the endorsement</td></tr>
</tbody></table>
<p><a name="gossip.LeadershipMessage"></a></p>
<h3><a class="header" href="#leadershipmessage" id="leadershipmessage">LeadershipMessage</a></h3>
<p>Leadership Message is sent during leader election to inform
remote peers about intent of peer to proclaim itself as leader</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>pki_id</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>timestamp</td><td><a href="#gossip.PeerTime">PeerTime</a></td><td></td><td></td></tr>
<tr><td>is_declaration</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.Member"></a></p>
<h3><a class="header" href="#member" id="member">Member</a></h3>
<p>Member holds membership-related information
about a peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>endpoint</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>pki_id</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.MembershipRequest"></a></p>
<h3><a class="header" href="#membershiprequest" id="membershiprequest">MembershipRequest</a></h3>
<p>MembershipRequest is used to ask membership information
from a remote peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>self_information</td><td><a href="#gossip.Envelope">Envelope</a></td><td></td><td></td></tr>
<tr><td>known</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.MembershipResponse"></a></p>
<h3><a class="header" href="#membershipresponse" id="membershipresponse">MembershipResponse</a></h3>
<p>MembershipResponse is used for replying to MembershipRequests</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>alive</td><td><a href="#gossip.Envelope">Envelope</a></td><td>repeated</td><td></td></tr>
<tr><td>dead</td><td><a href="#gossip.Envelope">Envelope</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.Payload"></a></p>
<h3><a class="header" href="#payload" id="payload">Payload</a></h3>
<p>Payload contains a block</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>seq_num</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>data</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>private_data</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.PeerIdentity"></a></p>
<h3><a class="header" href="#peeridentity" id="peeridentity">PeerIdentity</a></h3>
<p>PeerIdentity defines the identity of the peer
Used to make other peers learn of the identity
of a certain peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>pki_id</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>cert</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.PeerTime"></a></p>
<h3><a class="header" href="#peertime" id="peertime">PeerTime</a></h3>
<p>PeerTime defines the logical time of a peer's life</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>inc_num</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>seq_num</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.PrivateDataMessage"></a></p>
<h3><a class="header" href="#privatedatamessage" id="privatedatamessage">PrivateDataMessage</a></h3>
<p>PrivateDataMessage message which includes private
data information to distributed once transaction
has been endorsed</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#gossip.PrivatePayload">PrivatePayload</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.PrivatePayload"></a></p>
<h3><a class="header" href="#privatepayload" id="privatepayload">PrivatePayload</a></h3>
<p>PrivatePayload payload to encapsulate private
data with collection name to enable routing
based on collection partitioning</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>collection_name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>namespace</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>tx_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>private_rwset</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>private_sim_height</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>collection_configs</td><td><a href="#common.CollectionConfigPackage">common.CollectionConfigPackage</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.Properties"></a></p>
<h3><a class="header" href="#properties" id="properties">Properties</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>ledger_height</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>left_channel</td><td><a href="#bool">bool</a></td><td></td><td></td></tr>
<tr><td>chaincodes</td><td><a href="#gossip.Chaincode">Chaincode</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.PvtDataDigest"></a></p>
<h3><a class="header" href="#pvtdatadigest" id="pvtdatadigest">PvtDataDigest</a></h3>
<p>PvtDataDigest defines a digest of private data</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>tx_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>namespace</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>block_seq</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>seq_in_block</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.PvtDataElement"></a></p>
<h3><a class="header" href="#pvtdataelement" id="pvtdataelement">PvtDataElement</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>digest</td><td><a href="#gossip.PvtDataDigest">PvtDataDigest</a></td><td></td><td></td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td>the payload is a marshaled kvrwset.KVRWSet</td></tr>
</tbody></table>
<p><a name="gossip.PvtDataPayload"></a></p>
<h3><a class="header" href="#pvtdatapayload" id="pvtdatapayload">PvtDataPayload</a></h3>
<p>PvtPayload augments private rwset data and tx index
inside the block</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>tx_seq_in_block</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td>Encodes marhslaed bytes of rwset.TxPvtReadWriteSet defined in rwset.proto</td></tr>
</tbody></table>
<p><a name="gossip.RemotePvtDataRequest"></a></p>
<h3><a class="header" href="#remotepvtdatarequest" id="remotepvtdatarequest">RemotePvtDataRequest</a></h3>
<p>RemotePrivateDataRequest message used to request
missing private rwset</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>digests</td><td><a href="#gossip.PvtDataDigest">PvtDataDigest</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.RemotePvtDataResponse"></a></p>
<h3><a class="header" href="#remotepvtdataresponse" id="remotepvtdataresponse">RemotePvtDataResponse</a></h3>
<p>RemotePrivateData message to response on private
data replication request</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>elements</td><td><a href="#gossip.PvtDataElement">PvtDataElement</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.RemoteStateRequest"></a></p>
<h3><a class="header" href="#remotestaterequest" id="remotestaterequest">RemoteStateRequest</a></h3>
<p>RemoteStateRequest is used to ask a set of blocks
from a remote peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>start_seq_num</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>end_seq_num</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.RemoteStateResponse"></a></p>
<h3><a class="header" href="#remotestateresponse" id="remotestateresponse">RemoteStateResponse</a></h3>
<p>RemoteStateResponse is used to send a set of blocks
to a remote peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payloads</td><td><a href="#gossip.Payload">Payload</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.Secret"></a></p>
<h3><a class="header" href="#secret" id="secret">Secret</a></h3>
<p>Secret is an entity that might be omitted
from an Envelope when the remote peer that is receiving
the Envelope shouldn't know the secret's content.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>internalEndpoint</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.SecretEnvelope"></a></p>
<h3><a class="header" href="#secretenvelope" id="secretenvelope">SecretEnvelope</a></h3>
<p>SecretEnvelope is a marshalled Secret
and a signature over it.
The signature should be validated by the peer
that signed the Envelope the SecretEnvelope
came with</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.StateInfo"></a></p>
<h3><a class="header" href="#stateinfo" id="stateinfo">StateInfo</a></h3>
<p>StateInfo is used for a peer to relay its state information
to other peers</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>timestamp</td><td><a href="#gossip.PeerTime">PeerTime</a></td><td></td><td></td></tr>
<tr><td>pki_id</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>channel_MAC</td><td><a href="#bytes">bytes</a></td><td></td><td>channel_MAC is an authentication code that proves that the peer that sent this message knows the name of the channel.</td></tr>
<tr><td>properties</td><td><a href="#gossip.Properties">Properties</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="gossip.StateInfoPullRequest"></a></p>
<h3><a class="header" href="#stateinfopullrequest" id="stateinfopullrequest">StateInfoPullRequest</a></h3>
<p>StateInfoPullRequest is used to fetch a StateInfoSnapshot
from a remote peer</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel_MAC</td><td><a href="#bytes">bytes</a></td><td></td><td>channel_MAC is an authentication code that proves that the peer that sent this message knows the name of the channel.</td></tr>
</tbody></table>
<p><a name="gossip.StateInfoSnapshot"></a></p>
<h3><a class="header" href="#stateinfosnapshot" id="stateinfosnapshot">StateInfoSnapshot</a></h3>
<p>StateInfoSnapshot is an aggregation of StateInfo messages</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>elements</td><td><a href="#gossip.Envelope">Envelope</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="gossip.GossipMessage.Tag"></a></p>
<h3><a class="header" href="#gossipmessagetag" id="gossipmessagetag">GossipMessage.Tag</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>UNDEFINED</td><td>0</td><td></td></tr>
<tr><td>EMPTY</td><td>1</td><td></td></tr>
<tr><td>ORG_ONLY</td><td>2</td><td></td></tr>
<tr><td>CHAN_ONLY</td><td>3</td><td></td></tr>
<tr><td>CHAN_AND_ORG</td><td>4</td><td></td></tr>
<tr><td>CHAN_OR_ORG</td><td>5</td><td></td></tr>
</tbody></table>
<p><a name="gossip.PullMsgType"></a></p>
<h3><a class="header" href="#pullmsgtype" id="pullmsgtype">PullMsgType</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>UNDEFINED</td><td>0</td><td></td></tr>
<tr><td>BLOCK_MSG</td><td>1</td><td></td></tr>
<tr><td>IDENTITY_MSG</td><td>2</td><td></td></tr>
</tbody></table>
<p><a name="gossip.Gossip"></a></p>
<h3><a class="header" href="#gossip" id="gossip">Gossip</a></h3>
<p>Gossip</p>
<table><thead><tr><th>Method Name</th><th>Request Type</th><th>Response Type</th><th>Description</th></tr></thead><tbody>
<tr><td>GossipStream</td><td><a href="#gossip.Envelope">Envelope</a> stream</td><td><a href="#gossip.Envelope">Envelope</a> stream</td><td>GossipStream is the gRPC stream used for sending and receiving messages</td></tr>
<tr><td>Ping</td><td><a href="#gossip.Empty">Empty</a></td><td><a href="#gossip.Empty">Empty</a></td><td>Ping is used to probe a remote peer's aliveness</td></tr>
</tbody></table>
<p><a name="transientstore/transientstore.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#transientstoretransientstoreproto" id="transientstoretransientstoreproto">transientstore/transientstore.proto</a></h2>
<p><a name="transientstore.TxPvtReadWriteSetWithConfigInfo"></a></p>
<h3><a class="header" href="#txpvtreadwritesetwithconfiginfo" id="txpvtreadwritesetwithconfiginfo">TxPvtReadWriteSetWithConfigInfo</a></h3>
<p>TxPvtReadWriteSetWithConfigInfo encapsulates the transaction's private
read-write set and additional information about the configurations such as
the latest collection config when the transaction is simulated</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>endorsed_at</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>pvt_rwset</td><td><a href="#rwset.TxPvtReadWriteSet">rwset.TxPvtReadWriteSet</a></td><td></td><td></td></tr>
<tr><td>collection_configs</td><td><a href="#transientstore.TxPvtReadWriteSetWithConfigInfo.CollectionConfigsEntry">TxPvtReadWriteSetWithConfigInfo.CollectionConfigsEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="transientstore.TxPvtReadWriteSetWithConfigInfo.CollectionConfigsEntry"></a></p>
<h3><a class="header" href="#txpvtreadwritesetwithconfiginfocollectionconfigsentry" id="txpvtreadwritesetwithconfiginfocollectionconfigsentry">TxPvtReadWriteSetWithConfigInfo.CollectionConfigsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.CollectionConfigPackage">common.CollectionConfigPackage</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common/configuration.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#commonconfigurationproto" id="commonconfigurationproto">common/configuration.proto</a></h2>
<p><a name="common.BlockDataHashingStructure"></a></p>
<h3><a class="header" href="#blockdatahashingstructure" id="blockdatahashingstructure">BlockDataHashingStructure</a></h3>
<p>BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
type Chain with a Key of &quot;BlockDataHashingStructure&quot; and a Value of HashingAlgorithm as marshaled protobuf bytes</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>width</td><td><a href="#uint32">uint32</a></td><td></td><td>width specifies the width of the Merkle tree to use when computing the BlockDataHash in order to replicate flat hashing, set this width to MAX_UINT32</td></tr>
</tbody></table>
<p><a name="common.Capabilities"></a></p>
<h3><a class="header" href="#capabilities" id="capabilities">Capabilities</a></h3>
<p>Capabilities message defines the capabilities a particular binary must implement
for that binary to be able to safely participate in the channel.  The capabilities
message is defined at the /Channel level, the /Channel/Application level, and the
/Channel/Orderer level.</p>
<p>The /Channel level capabilties define capabilities which both the orderer and peer
binaries must satisfy.  These capabilties might be things like a new MSP type,
or a new policy type.</p>
<p>The /Channel/Orderer level capabilties define capabilities which must be supported
by the orderer, but which have no bearing on the behavior of the peer.  For instance
if the orderer changes the logic for how it constructs new channels, only all orderers
must agree on the new logic.  The peers do not need to be aware of this change as
they only interact with the channel after it has been constructed.</p>
<p>Finally, the /Channel/Application level capabilities define capabilities which the peer
binary must satisfy, but which have no bearing on the orderer.  For instance, if the
peer adds a new UTXO transaction type, or changes the chaincode lifecycle requirements,
all peers must agree on the new logic.  However, orderers never inspect transactions
this deeply, and therefore have no need to be aware of the change.</p>
<p>The capabilities strings defined in these messages typically correspond to release
binary versions (e.g. &quot;V1.1&quot;), and are used primarilly as a mechanism for a fully
upgraded network to switch from one set of logic to a new one.</p>
<p>Although for V1.1, the orderers must be upgraded to V1.1 prior to the rest of the
network, going forward, because of the split between the /Channel, /Channel/Orderer
and /Channel/Application capabilities.  It should be possible for the orderer and
application networks to upgrade themselves independently (with the exception of any
new capabilities defined at the /Channel level).</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>capabilities</td><td><a href="#common.Capabilities.CapabilitiesEntry">Capabilities.CapabilitiesEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.Capabilities.CapabilitiesEntry"></a></p>
<h3><a class="header" href="#capabilitiescapabilitiesentry" id="capabilitiescapabilitiesentry">Capabilities.CapabilitiesEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.Capability">Capability</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.Capability"></a></p>
<h3><a class="header" href="#capability" id="capability">Capability</a></h3>
<p>Capability is an empty message for the time being.  It is defined as a protobuf
message rather than a constant, so that we may extend capabilities with other fields
if the need arises in the future.  For the time being, a capability being in the
capabilities map requires that that capability be supported.</p>
<p><a name="common.Consortium"></a></p>
<h3><a class="header" href="#consortium" id="consortium">Consortium</a></h3>
<p>Consortium represents the consortium context in which the channel was created</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.HashingAlgorithm"></a></p>
<h3><a class="header" href="#hashingalgorithm" id="hashingalgorithm">HashingAlgorithm</a></h3>
<p>HashingAlgorithm is encoded into the configuration transaction as  a configuration item of type Chain
with a Key of &quot;HashingAlgorithm&quot; and a Value of  HashingAlgorithm as marshaled protobuf bytes</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>Currently supported algorithms are: SHAKE256</td></tr>
</tbody></table>
<p><a name="common.OrdererAddresses"></a></p>
<h3><a class="header" href="#ordereraddresses" id="ordereraddresses">OrdererAddresses</a></h3>
<p>OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
with a Key of &quot;OrdererAddresses&quot; and a Value of OrdererAddresses as marshaled protobuf bytes</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>addresses</td><td><a href="#string">string</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common/ledger.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#commonledgerproto" id="commonledgerproto">common/ledger.proto</a></h2>
<p><a name="common.BlockchainInfo"></a></p>
<h3><a class="header" href="#blockchaininfo" id="blockchaininfo">BlockchainInfo</a></h3>
<p>Contains information about the blockchain ledger such as height, current
block hash, and previous block hash.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>height</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>currentBlockHash</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>previousBlockHash</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common/policies.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#commonpoliciesproto" id="commonpoliciesproto">common/policies.proto</a></h2>
<p><a name="common.ImplicitMetaPolicy"></a></p>
<h3><a class="header" href="#implicitmetapolicy" id="implicitmetapolicy">ImplicitMetaPolicy</a></h3>
<p>ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
It is implicit because the rule is generate implicitly based on the number of sub policies
It is meta because it depends only on the result of other policies
When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
of name sub_policy, evaluates the collection and applies the rule.
For example, with 4 sub-groups, and a policy name of &quot;foo&quot;, ImplicitMetaPolicy retrieves
each sub-group, retrieves policy &quot;foo&quot; for each subgroup, evaluates it, and, in the case of ANY
1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>sub_policy</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>rule</td><td><a href="#common.ImplicitMetaPolicy.Rule">ImplicitMetaPolicy.Rule</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.Policy"></a></p>
<h3><a class="header" href="#policy" id="policy">Policy</a></h3>
<p>Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
multiple policy engines, this is typed as a oneof for now</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><a href="#int32">int32</a></td><td></td><td>For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType</td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.SignaturePolicy"></a></p>
<h3><a class="header" href="#signaturepolicy" id="signaturepolicy">SignaturePolicy</a></h3>
<p>SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
to express AND as well as OR, as well as of course N out of the following M policies
SignedBy implies that the signature is from a valid certificate which is signed by the trusted
authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
and will be the CA for more traditional certificates</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>signed_by</td><td><a href="#int32">int32</a></td><td></td><td></td></tr>
<tr><td>n_out_of</td><td><a href="#common.SignaturePolicy.NOutOf">SignaturePolicy.NOutOf</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.SignaturePolicy.NOutOf"></a></p>
<h3><a class="header" href="#signaturepolicynoutof" id="signaturepolicynoutof">SignaturePolicy.NOutOf</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>n</td><td><a href="#int32">int32</a></td><td></td><td></td></tr>
<tr><td>rules</td><td><a href="#common.SignaturePolicy">SignaturePolicy</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.SignaturePolicyEnvelope"></a></p>
<h3><a class="header" href="#signaturepolicyenvelope" id="signaturepolicyenvelope">SignaturePolicyEnvelope</a></h3>
<p>SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>version</td><td><a href="#int32">int32</a></td><td></td><td></td></tr>
<tr><td>rule</td><td><a href="#common.SignaturePolicy">SignaturePolicy</a></td><td></td><td></td></tr>
<tr><td>identities</td><td><a href="#common.MSPPrincipal">MSPPrincipal</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.ImplicitMetaPolicy.Rule"></a></p>
<h3><a class="header" href="#implicitmetapolicyrule" id="implicitmetapolicyrule">ImplicitMetaPolicy.Rule</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>ANY</td><td>0</td><td>Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true</td></tr>
<tr><td>ALL</td><td>1</td><td>Requires all of the sub-policies be satisfied</td></tr>
<tr><td>MAJORITY</td><td>2</td><td>Requires a strict majority (greater than half) of the sub-policies be satisfied</td></tr>
</tbody></table>
<p><a name="common.Policy.PolicyType"></a></p>
<h3><a class="header" href="#policypolicytype" id="policypolicytype">Policy.PolicyType</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>UNKNOWN</td><td>0</td><td>Reserved to check for proper initialization</td></tr>
<tr><td>SIGNATURE</td><td>1</td><td></td></tr>
<tr><td>MSP</td><td>2</td><td></td></tr>
<tr><td>IMPLICIT_META</td><td>3</td><td></td></tr>
</tbody></table>
<p><a name="common/configtx.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#commonconfigtxproto" id="commonconfigtxproto">common/configtx.proto</a></h2>
<p><a name="common.Config"></a></p>
<h3><a class="header" href="#config" id="config">Config</a></h3>
<p>Config represents the config for a particular channel</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>sequence</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>channel_group</td><td><a href="#common.ConfigGroup">ConfigGroup</a></td><td></td><td>channel_group is a bad name for this, it should be changed to root when API breakage is allowed</td></tr>
</tbody></table>
<p><a name="common.ConfigEnvelope"></a></p>
<h3><a class="header" href="#configenvelope" id="configenvelope">ConfigEnvelope</a></h3>
<p>ConfigEnvelope is designed to contain <em>all</em> configuration for a chain with no dependency
on previous configuration transactions.</p>
<p>It is generated with the following scheme:</p>
<ol>
<li>Retrieve the existing configuration</li>
<li>Note the config properties (ConfigValue, ConfigPolicy, ConfigGroup) to be modified</li>
<li>Add any intermediate ConfigGroups to the ConfigUpdate.read_set (sparsely)</li>
<li>Add any additional desired dependencies to ConfigUpdate.read_set (sparsely)</li>
<li>Modify the config properties, incrementing each version by 1, set them in the ConfigUpdate.write_set
Note: any element not modified but specified should already be in the read_set, so may be specified sparsely</li>
<li>Create ConfigUpdate message and marshal it into ConfigUpdateEnvelope.update and encode the required signatures
a) Each signature is of type ConfigSignature
b) The ConfigSignature signature is over the concatenation of signature_header and the ConfigUpdate bytes (which includes a ChainHeader)</li>
<li>Submit new Config for ordering in Envelope signed by submitter
a) The Envelope Payload has data set to the marshaled ConfigEnvelope
b) The Envelope Payload has a header of type Header.Type.CONFIG_UPDATE</li>
</ol>
<p>The configuration manager will verify:</p>
<ol>
<li>All items in the read_set exist at the read versions</li>
<li>All items in the write_set at a different version than, or not in, the read_set have been appropriately signed according to their mod_policy</li>
<li>The new configuration satisfies the ConfigSchema</li>
</ol>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>config</td><td><a href="#common.Config">Config</a></td><td></td><td>A marshaled Config structure</td></tr>
<tr><td>last_update</td><td><a href="#common.Envelope">Envelope</a></td><td></td><td>The last CONFIG_UPDATE message which generated this current configuration</td></tr>
</tbody></table>
<p><a name="common.ConfigGroup"></a></p>
<h3><a class="header" href="#configgroup" id="configgroup">ConfigGroup</a></h3>
<p>ConfigGroup is the hierarchical data structure for holding config</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>version</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>groups</td><td><a href="#common.ConfigGroup.GroupsEntry">ConfigGroup.GroupsEntry</a></td><td>repeated</td><td></td></tr>
<tr><td>values</td><td><a href="#common.ConfigGroup.ValuesEntry">ConfigGroup.ValuesEntry</a></td><td>repeated</td><td></td></tr>
<tr><td>policies</td><td><a href="#common.ConfigGroup.PoliciesEntry">ConfigGroup.PoliciesEntry</a></td><td>repeated</td><td></td></tr>
<tr><td>mod_policy</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigGroup.GroupsEntry"></a></p>
<h3><a class="header" href="#configgroupgroupsentry" id="configgroupgroupsentry">ConfigGroup.GroupsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.ConfigGroup">ConfigGroup</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigGroup.PoliciesEntry"></a></p>
<h3><a class="header" href="#configgrouppoliciesentry" id="configgrouppoliciesentry">ConfigGroup.PoliciesEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.ConfigPolicy">ConfigPolicy</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigGroup.ValuesEntry"></a></p>
<h3><a class="header" href="#configgroupvaluesentry" id="configgroupvaluesentry">ConfigGroup.ValuesEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.ConfigValue">ConfigValue</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigGroupSchema"></a></p>
<h3><a class="header" href="#configgroupschema" id="configgroupschema">ConfigGroupSchema</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>groups</td><td><a href="#common.ConfigGroupSchema.GroupsEntry">ConfigGroupSchema.GroupsEntry</a></td><td>repeated</td><td></td></tr>
<tr><td>values</td><td><a href="#common.ConfigGroupSchema.ValuesEntry">ConfigGroupSchema.ValuesEntry</a></td><td>repeated</td><td></td></tr>
<tr><td>policies</td><td><a href="#common.ConfigGroupSchema.PoliciesEntry">ConfigGroupSchema.PoliciesEntry</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigGroupSchema.GroupsEntry"></a></p>
<h3><a class="header" href="#configgroupschemagroupsentry" id="configgroupschemagroupsentry">ConfigGroupSchema.GroupsEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.ConfigGroupSchema">ConfigGroupSchema</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigGroupSchema.PoliciesEntry"></a></p>
<h3><a class="header" href="#configgroupschemapoliciesentry" id="configgroupschemapoliciesentry">ConfigGroupSchema.PoliciesEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.ConfigPolicySchema">ConfigPolicySchema</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigGroupSchema.ValuesEntry"></a></p>
<h3><a class="header" href="#configgroupschemavaluesentry" id="configgroupschemavaluesentry">ConfigGroupSchema.ValuesEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#common.ConfigValueSchema">ConfigValueSchema</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigPolicy"></a></p>
<h3><a class="header" href="#configpolicy" id="configpolicy">ConfigPolicy</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>version</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>policy</td><td><a href="#common.Policy">Policy</a></td><td></td><td></td></tr>
<tr><td>mod_policy</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigPolicySchema"></a></p>
<h3><a class="header" href="#configpolicyschema" id="configpolicyschema">ConfigPolicySchema</a></h3>
<p><a name="common.ConfigSignature"></a></p>
<h3><a class="header" href="#configsignature" id="configsignature">ConfigSignature</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>signature_header</td><td><a href="#bytes">bytes</a></td><td></td><td>A marshaled SignatureHeader</td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td>Signature over the concatenation signatureHeader bytes and config bytes</td></tr>
</tbody></table>
<p><a name="common.ConfigUpdate"></a></p>
<h3><a class="header" href="#configupdate" id="configupdate">ConfigUpdate</a></h3>
<p>ConfigUpdate is used to submit a subset of config and to have the orderer apply to Config
it is always submitted inside a ConfigUpdateEnvelope which allows the addition of signatures
resulting in a new total configuration.  The update is applied as follows:</p>
<ol>
<li>The versions from all of the elements in the read_set is verified against the versions in the existing config.
If there is a mismatch in the read versions, then the config update fails and is rejected.</li>
<li>Any elements in the write_set with the same version as the read_set are ignored.</li>
<li>The corresponding mod_policy for every remaining element in the write_set is collected.</li>
<li>Each policy is checked against the signatures from the ConfigUpdateEnvelope, any failing to verify are rejected</li>
<li>The write_set is applied to the Config and the ConfigGroupSchema verifies that the updates were legal</li>
</ol>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel_id</td><td><a href="#string">string</a></td><td></td><td>Which channel this config update is for</td></tr>
<tr><td>read_set</td><td><a href="#common.ConfigGroup">ConfigGroup</a></td><td></td><td>ReadSet explicitly lists the portion of the config which was read, this should be sparse with only Version set</td></tr>
<tr><td>write_set</td><td><a href="#common.ConfigGroup">ConfigGroup</a></td><td></td><td>WriteSet lists the portion of the config which was written, this should included updated Versions</td></tr>
<tr><td>isolated_data</td><td><a href="#common.ConfigUpdate.IsolatedDataEntry">ConfigUpdate.IsolatedDataEntry</a></td><td>repeated</td><td>Data which is not to be reflected in the resulting Config, but is still needed for some other purpose. For instance, rscc_seed_data</td></tr>
</tbody></table>
<p><a name="common.ConfigUpdate.IsolatedDataEntry"></a></p>
<h3><a class="header" href="#configupdateisolateddataentry" id="configupdateisolateddataentry">ConfigUpdate.IsolatedDataEntry</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>key</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigUpdateEnvelope"></a></p>
<h3><a class="header" href="#configupdateenvelope" id="configupdateenvelope">ConfigUpdateEnvelope</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>config_update</td><td><a href="#bytes">bytes</a></td><td></td><td>A marshaled ConfigUpdate structure</td></tr>
<tr><td>signatures</td><td><a href="#common.ConfigSignature">ConfigSignature</a></td><td>repeated</td><td>Signatures over the config_update</td></tr>
</tbody></table>
<p><a name="common.ConfigValue"></a></p>
<h3><a class="header" href="#configvalue" id="configvalue">ConfigValue</a></h3>
<p>ConfigValue represents an individual piece of config data</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>version</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>mod_policy</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.ConfigValueSchema"></a></p>
<h3><a class="header" href="#configvalueschema" id="configvalueschema">ConfigValueSchema</a></h3>
<p><a name="common/common.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#commoncommonproto" id="commoncommonproto">common/common.proto</a></h2>
<p><a name="common.Block"></a></p>
<h3><a class="header" href="#block" id="block">Block</a></h3>
<p>This is finalized block structure to be shared among the orderer and peer
Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
the Metadata is not.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>header</td><td><a href="#common.BlockHeader">BlockHeader</a></td><td></td><td></td></tr>
<tr><td>data</td><td><a href="#common.BlockData">BlockData</a></td><td></td><td></td></tr>
<tr><td>metadata</td><td><a href="#common.BlockMetadata">BlockMetadata</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.BlockData"></a></p>
<h3><a class="header" href="#blockdata" id="blockdata">BlockData</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>data</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.BlockHeader"></a></p>
<h3><a class="header" href="#blockheader" id="blockheader">BlockHeader</a></h3>
<p>BlockHeader is the element of the block which forms the block chain
The block header is hashed using the configured chain hashing algorithm
over the ASN.1 encoding of the BlockHeader</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>number</td><td><a href="#uint64">uint64</a></td><td></td><td>The position in the blockchain</td></tr>
<tr><td>previous_hash</td><td><a href="#bytes">bytes</a></td><td></td><td>The hash of the previous block header</td></tr>
<tr><td>data_hash</td><td><a href="#bytes">bytes</a></td><td></td><td>The hash of the BlockData, by MerkleTree</td></tr>
</tbody></table>
<p><a name="common.BlockMetadata"></a></p>
<h3><a class="header" href="#blockmetadata-1" id="blockmetadata-1">BlockMetadata</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>metadata</td><td><a href="#bytes">bytes</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.ChannelHeader"></a></p>
<h3><a class="header" href="#channelheader" id="channelheader">ChannelHeader</a></h3>
<p>Header is a generic replay prevention and identity message to include in a signed payload</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>type</td><td><a href="#int32">int32</a></td><td></td><td>Header types 0-10000 are reserved and defined by HeaderType</td></tr>
<tr><td>version</td><td><a href="#int32">int32</a></td><td></td><td>Version indicates message protocol version</td></tr>
<tr><td>timestamp</td><td><a href="#google.protobuf.Timestamp">google.protobuf.Timestamp</a></td><td></td><td>Timestamp is the local time when the message was created by the sender</td></tr>
<tr><td>channel_id</td><td><a href="#string">string</a></td><td></td><td>Identifier of the channel this message is bound for</td></tr>
<tr><td>tx_id</td><td><a href="#string">string</a></td><td></td><td>An unique identifier that is used end-to-end. - set by higher layers such as end user or SDK - passed to the endorser (which will check for uniqueness) - as the header is passed along unchanged, it will be be retrieved by the committer (uniqueness check here as well) - to be stored in the ledger</td></tr>
<tr><td>epoch</td><td><a href="#uint64">uint64</a></td><td></td><td>The epoch in which this header was generated, where epoch is defined based on block height Epoch in which the response has been generated. This field identifies a logical window of time. A proposal response is accepted by a peer only if two conditions hold: 1. the epoch specified in the message is the current epoch 2. this message has been only seen once during this epoch (i.e. it hasn't been replayed)</td></tr>
<tr><td>extension</td><td><a href="#bytes">bytes</a></td><td></td><td>Extension that may be attached based on the header type</td></tr>
<tr><td>tls_cert_hash</td><td><a href="#bytes">bytes</a></td><td></td><td>If mutual TLS is employed, this represents the hash of the client's TLS certificate</td></tr>
</tbody></table>
<p><a name="common.Envelope"></a></p>
<h3><a class="header" href="#envelope-1" id="envelope-1">Envelope</a></h3>
<p>Envelope wraps a Payload with a signature so that the message may be authenticated</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>payload</td><td><a href="#bytes">bytes</a></td><td></td><td>A marshaled Payload</td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td>A signature by the creator specified in the Payload header</td></tr>
</tbody></table>
<p><a name="common.Header"></a></p>
<h3><a class="header" href="#header" id="header">Header</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel_header</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>signature_header</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.LastConfig"></a></p>
<h3><a class="header" href="#lastconfig" id="lastconfig">LastConfig</a></h3>
<p>LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>index</td><td><a href="#uint64">uint64</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.Metadata"></a></p>
<h3><a class="header" href="#metadata" id="metadata">Metadata</a></h3>
<p>Metadata is a common structure to be used to encode block metadata</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>value</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
<tr><td>signatures</td><td><a href="#common.MetadataSignature">MetadataSignature</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.MetadataSignature"></a></p>
<h3><a class="header" href="#metadatasignature" id="metadatasignature">MetadataSignature</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>signature_header</td><td><a href="#bytes">bytes</a></td><td></td><td>An encoded SignatureHeader</td></tr>
<tr><td>signature</td><td><a href="#bytes">bytes</a></td><td></td><td>The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header</td></tr>
</tbody></table>
<p><a name="common.OrdererBlockMetadata"></a></p>
<h3><a class="header" href="#ordererblockmetadata" id="ordererblockmetadata">OrdererBlockMetadata</a></h3>
<p>OrdererBlockMetadata defines metadata that is set by the ordering service.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>last_config</td><td><a href="#common.LastConfig">LastConfig</a></td><td></td><td></td></tr>
<tr><td>consenter_metadata</td><td><a href="#bytes">bytes</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.Payload"></a></p>
<h3><a class="header" href="#payload-1" id="payload-1">Payload</a></h3>
<p>Payload is the message contents (and header to allow for signing)</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>header</td><td><a href="#common.Header">Header</a></td><td></td><td>Header is included to provide identity and prevent replay</td></tr>
<tr><td>data</td><td><a href="#bytes">bytes</a></td><td></td><td>Data, the encoding of which is defined by the type in the header</td></tr>
</tbody></table>
<p><a name="common.SignatureHeader"></a></p>
<h3><a class="header" href="#signatureheader" id="signatureheader">SignatureHeader</a></h3>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>creator</td><td><a href="#bytes">bytes</a></td><td></td><td>Creator of the message, a marshaled msp.SerializedIdentity</td></tr>
<tr><td>nonce</td><td><a href="#bytes">bytes</a></td><td></td><td>Arbitrary number that may only be used once. Can be used to detect replay attacks.</td></tr>
</tbody></table>
<p><a name="common.BlockMetadataIndex"></a></p>
<h3><a class="header" href="#blockmetadataindex" id="blockmetadataindex">BlockMetadataIndex</a></h3>
<p>This enum enlists indexes of the block metadata array</p>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>SIGNATURES</td><td>0</td><td>Block metadata array position for block signatures</td></tr>
<tr><td>LAST_CONFIG</td><td>1</td><td>Block metadata array position to store last configuration block sequence number</td></tr>
<tr><td>TRANSACTIONS_FILTER</td><td>2</td><td>Block metadata array position to store serialized bit array filter of invalid transactions</td></tr>
<tr><td>ORDERER</td><td>3</td><td>Block metadata array position to store operational metadata for orderers e.g. For Kafka, this is where we store the last offset written to the local ledger</td></tr>
<tr><td>COMMIT_HASH</td><td>4</td><td>Block metadata array position to store the hash of TRANSACTIONS_FILTER, State Updates, and the COMMIT_HASH of the previous block</td></tr>
</tbody></table>
<p><a name="common.HeaderType"></a></p>
<h3><a class="header" href="#headertype" id="headertype">HeaderType</a></h3>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>MESSAGE</td><td>0</td><td>Used for messages which are signed but opaque</td></tr>
<tr><td>CONFIG</td><td>1</td><td>Used for messages which express the channel config</td></tr>
<tr><td>CONFIG_UPDATE</td><td>2</td><td>Used for transactions which update the channel config</td></tr>
<tr><td>ENDORSER_TRANSACTION</td><td>3</td><td>Used by the SDK to submit endorser based transactions</td></tr>
<tr><td>ORDERER_TRANSACTION</td><td>4</td><td>Used internally by the orderer for management</td></tr>
<tr><td>DELIVER_SEEK_INFO</td><td>5</td><td>Used as the type for Envelope messages submitted to instruct the Deliver API to seek</td></tr>
<tr><td>CHAINCODE_PACKAGE</td><td>6</td><td>Used for packaging chaincode artifacts for install</td></tr>
<tr><td>PEER_ADMIN_OPERATION</td><td>8</td><td>Used for invoking an administrative operation on a peer</td></tr>
</tbody></table>
<p><a name="common.Status"></a></p>
<h3><a class="header" href="#status" id="status">Status</a></h3>
<p>These status codes are intended to resemble selected HTTP status codes</p>
<table><thead><tr><th>Name</th><th>Number</th><th>Description</th></tr></thead><tbody>
<tr><td>UNKNOWN</td><td>0</td><td></td></tr>
<tr><td>SUCCESS</td><td>200</td><td></td></tr>
<tr><td>BAD_REQUEST</td><td>400</td><td></td></tr>
<tr><td>FORBIDDEN</td><td>403</td><td></td></tr>
<tr><td>NOT_FOUND</td><td>404</td><td></td></tr>
<tr><td>REQUEST_ENTITY_TOO_LARGE</td><td>413</td><td></td></tr>
<tr><td>INTERNAL_SERVER_ERROR</td><td>500</td><td></td></tr>
<tr><td>NOT_IMPLEMENTED</td><td>501</td><td></td></tr>
<tr><td>SERVICE_UNAVAILABLE</td><td>503</td><td></td></tr>
</tbody></table>
<p><a name="common/collection.proto"></a></p>
<p align="right"><a href="#top">Top</a></p>
<h2><a class="header" href="#commoncollectionproto" id="commoncollectionproto">common/collection.proto</a></h2>
<p><a name="common.CollectionConfig"></a></p>
<h3><a class="header" href="#collectionconfig" id="collectionconfig">CollectionConfig</a></h3>
<p>CollectionConfig defines the configuration of a collection object;
it currently contains a single, static type.
Dynamic collections are deferred.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>static_collection_config</td><td><a href="#common.StaticCollectionConfig">StaticCollectionConfig</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.CollectionConfigPackage"></a></p>
<h3><a class="header" href="#collectionconfigpackage" id="collectionconfigpackage">CollectionConfigPackage</a></h3>
<p>CollectionConfigPackage represents an array of CollectionConfig
messages; the extra struct is required because repeated oneof is
forbidden by the protobuf syntax</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>config</td><td><a href="#common.CollectionConfig">CollectionConfig</a></td><td>repeated</td><td></td></tr>
</tbody></table>
<p><a name="common.CollectionCriteria"></a></p>
<h3><a class="header" href="#collectioncriteria" id="collectioncriteria">CollectionCriteria</a></h3>
<p>CollectionCriteria defines an element of a private data that corresponds
to a certain transaction and collection</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>channel</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>tx_id</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>collection</td><td><a href="#string">string</a></td><td></td><td></td></tr>
<tr><td>namespace</td><td><a href="#string">string</a></td><td></td><td></td></tr>
</tbody></table>
<p><a name="common.CollectionPolicyConfig"></a></p>
<h3><a class="header" href="#collectionpolicyconfig" id="collectionpolicyconfig">CollectionPolicyConfig</a></h3>
<p>Collection policy configuration. Initially, the configuration can only
contain a SignaturePolicy. In the future, the SignaturePolicy may be a
more general Policy. Instead of containing the actual policy, the
configuration may in the future contain a string reference to a policy.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>signature_policy</td><td><a href="#common.SignaturePolicyEnvelope">SignaturePolicyEnvelope</a></td><td></td><td>Initially, only a signature policy is supported.</td></tr>
</tbody></table>
<p>Later, the SignaturePolicy will be replaced by a Policy. Policy policy = 1; A reference to a Policy is planned to be added later. string reference = 2; |</p>
<p><a name="common.StaticCollectionConfig"></a></p>
<h3><a class="header" href="#staticcollectionconfig" id="staticcollectionconfig">StaticCollectionConfig</a></h3>
<p>StaticCollectionConfig constitutes the configuration parameters of a
static collection object. Static collections are collections that are
known at chaincode instantiation time, and that cannot be changed.
Dynamic collections are deferred.</p>
<table><thead><tr><th>Field</th><th>Type</th><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td>name</td><td><a href="#string">string</a></td><td></td><td>the name of the collection inside the denoted chaincode</td></tr>
<tr><td>member_orgs_policy</td><td><a href="#common.CollectionPolicyConfig">CollectionPolicyConfig</a></td><td></td><td>a reference to a policy residing / managed in the config block to define which orgs have access to this collection’s private data</td></tr>
<tr><td>required_peer_count</td><td><a href="#int32">int32</a></td><td></td><td>The minimum number of peers private data will be sent to upon endorsement. The endorsement would fail if dissemination to at least this number of peers is not achieved.</td></tr>
<tr><td>maximum_peer_count</td><td><a href="#int32">int32</a></td><td></td><td>The maximum number of peers that private data will be sent to upon endorsement. This number has to be bigger than required_peer_count.</td></tr>
<tr><td>block_to_live</td><td><a href="#uint64">uint64</a></td><td></td><td>The number of blocks after which the collection data expires. For instance if the value is set to 10, a key last modified by block number 100 will be purged at block number 111. A zero value is treated same as MaxUint64</td></tr>
<tr><td>member_only_read</td><td><a href="#bool">bool</a></td><td></td><td>The member only read access denotes whether only collection member clients can read the private data (if set to true), or even non members can read the data (if set to false, for example if you want to implement more granular access logic in the chaincode)</td></tr>
<tr><td>member_only_write</td><td><a href="#bool">bool</a></td><td></td><td>The member only write access denotes whether only collection member clients can write the private data (if set to true), or even non members can write the data (if set to false, for example if you want to implement more granular access logic in the chaincode)</td></tr>
</tbody></table>
<h2><a class="header" href="#scalar-value-types" id="scalar-value-types">Scalar Value Types</a></h2>
<table><thead><tr><th>.proto Type</th><th>Notes</th><th>C++ Type</th><th>Java Type</th><th>Python Type</th></tr></thead><tbody>
<tr><td><a name="double" /> double</td><td></td><td>double</td><td>double</td><td>float</td></tr>
<tr><td><a name="float" /> float</td><td></td><td>float</td><td>float</td><td>float</td></tr>
<tr><td><a name="int32" /> int32</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.</td><td>int32</td><td>int</td><td>int</td></tr>
<tr><td><a name="int64" /> int64</td><td>Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.</td><td>int64</td><td>long</td><td>int/long</td></tr>
<tr><td><a name="uint32" /> uint32</td><td>Uses variable-length encoding.</td><td>uint32</td><td>int</td><td>int/long</td></tr>
<tr><td><a name="uint64" /> uint64</td><td>Uses variable-length encoding.</td><td>uint64</td><td>long</td><td>int/long</td></tr>
<tr><td><a name="sint32" /> sint32</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.</td><td>int32</td><td>int</td><td>int</td></tr>
<tr><td><a name="sint64" /> sint64</td><td>Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.</td><td>int64</td><td>long</td><td>int/long</td></tr>
<tr><td><a name="fixed32" /> fixed32</td><td>Always four bytes. More efficient than uint32 if values are often greater than 2^28.</td><td>uint32</td><td>int</td><td>int</td></tr>
<tr><td><a name="fixed64" /> fixed64</td><td>Always eight bytes. More efficient than uint64 if values are often greater than 2^56.</td><td>uint64</td><td>long</td><td>int/long</td></tr>
<tr><td><a name="sfixed32" /> sfixed32</td><td>Always four bytes.</td><td>int32</td><td>int</td><td>int</td></tr>
<tr><td><a name="sfixed64" /> sfixed64</td><td>Always eight bytes.</td><td>int64</td><td>long</td><td>int/long</td></tr>
<tr><td><a name="bool" /> bool</td><td></td><td>bool</td><td>boolean</td><td>boolean</td></tr>
<tr><td><a name="string" /> string</td><td>A string must always contain UTF-8 encoded or 7-bit ASCII text.</td><td>string</td><td>String</td><td>str/unicode</td></tr>
<tr><td><a name="bytes" /> bytes</td><td>May contain any arbitrary sequence of bytes.</td><td>string</td><td>ByteString</td><td>str</td></tr>
</tbody></table>
<h1><a class="header" href="#protos-file-tree" id="protos-file-tree">Protos File Tree</a></h1>
<pre><code>
.
├── ci
├── common
│   ├── collection.proto
│   ├── common.proto
│   ├── configtx.proto
│   ├── configuration.proto
│   ├── ledger.proto
│   └── policies.proto
├── discovery
│   └── protocol.proto
├── gossip
│   └── message.proto
├── ledger
│   ├── queryresult
│   │   └── kv_query_result.proto
│   └── rwset
│       ├── kvrwset
│       │   └── kv_rwset.proto
│       └── rwset.proto
├── msp
│   ├── identities.proto
│   ├── msp_config.proto
│   └── msp_principal.proto
├── orderer
│   ├── ab.proto
│   ├── cluster.proto
│   ├── configuration.proto
│   ├── etcdraft
│   │   ├── configuration.proto
│   │   └── metadata.proto
│   └── kafka.proto
├── peer
│   ├── chaincode_event.proto
│   ├── chaincode.proto
│   ├── chaincode_shim.proto
│   ├── configuration.proto
│   ├── events.proto
│   ├── lifecycle
│   │   ├── chaincode_definition.proto
│   │   ├── db.proto
│   │   └── lifecycle.proto
│   ├── peer.proto
│   ├── policy.proto
│   ├── proposal.proto
│   ├── proposal_response.proto
│   ├── query.proto
│   ├── resources.proto
│   ├── signed_cc_dep_spec.proto
│   └── transaction.proto
└── transientstore
    └── transientstore.proto

14 directories, 37 files

</code></pre>
<h1><a class="header" href="#protobuf-sources" id="protobuf-sources">Protobuf sources</a></h1>
<h2><a class="header" href="#srcpeertransactionproto" id="srcpeertransactionproto">src:./peer/transaction.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option java_outer_classname = &quot;TransactionPackage&quot;;

package protos;

import &quot;peer/proposal_response.proto&quot;;
import &quot;common/common.proto&quot;;

// This message is necessary to facilitate the verification of the signature
// (in the signature field) over the bytes of the transaction (in the
// transactionBytes field).
message SignedTransaction {
    // The bytes of the Transaction. NDD
    bytes transaction_bytes = 1;

    // Signature of the transactionBytes The public key of the signature is in
    // the header field of TransactionAction There might be multiple
    // TransactionAction, so multiple headers, but there should be same
    // transactor identity (cert) in all headers
    bytes signature = 2;
}

// ProcessedTransaction wraps an Envelope that includes a transaction along with an indication
// of whether the transaction was validated or invalidated by committing peer.
// The use case is that GetTransactionByID API needs to retrieve the transaction Envelope
// from block storage, and return it to a client, and indicate whether the transaction
// was validated or invalidated by committing peer. So that the originally submitted
// transaction Envelope is not modified, the ProcessedTransaction wrapper is returned.
message ProcessedTransaction {
    // An Envelope which includes a processed transaction
    common.Envelope transactionEnvelope = 1;

    // An indication of whether the transaction was validated or invalidated by committing peer
    int32 validationCode = 2;
}

// The transaction to be sent to the ordering service. A transaction contains
// one or more TransactionAction. Each TransactionAction binds a proposal to
// potentially multiple actions. The transaction is atomic meaning that either
// all actions in the transaction will be committed or none will.  Note that
// while a Transaction might include more than one Header, the Header.creator
// field must be the same in each.
// A single client is free to issue a number of independent Proposal, each with
// their header (Header) and request payload (ChaincodeProposalPayload).  Each
// proposal is independently endorsed generating an action
// (ProposalResponsePayload) with one signature per Endorser. Any number of
// independent proposals (and their action) might be included in a transaction
// to ensure that they are treated atomically.
message Transaction {

    // The payload is an array of TransactionAction. An array is necessary to
    // accommodate multiple actions per transaction
    repeated TransactionAction actions = 1;
}

// TransactionAction binds a proposal to its action.  The type field in the
// header dictates the type of action to be applied to the ledger.
message TransactionAction {

    // The header of the proposal action, which is the proposal header
    bytes header = 1;

    // The payload of the action as defined by the type in the header For
    // chaincode, it's the bytes of ChaincodeActionPayload
    bytes payload = 2;
}

//---------- Chaincode Transaction ------------

// ChaincodeActionPayload is the message to be used for the TransactionAction's
// payload when the Header's type is set to CHAINCODE.  It carries the
// chaincodeProposalPayload and an endorsed action to apply to the ledger.
message ChaincodeActionPayload {
    // This field contains the bytes of the ChaincodeProposalPayload message from
    // the original invocation (essentially the arguments) after the application
    // of the visibility function. The main visibility modes are &quot;full&quot; (the
    // entire ChaincodeProposalPayload message is included here), &quot;hash&quot; (only
    // the hash of the ChaincodeProposalPayload message is included) or
    // &quot;nothing&quot;.  This field will be used to check the consistency of
    // ProposalResponsePayload.proposalHash.  For the CHAINCODE type,
    // ProposalResponsePayload.proposalHash is supposed to be H(ProposalHeader ||
    // f(ChaincodeProposalPayload)) where f is the visibility function.
    bytes chaincode_proposal_payload = 1;

    // The list of actions to apply to the ledger
    ChaincodeEndorsedAction action = 2;
}

// ChaincodeEndorsedAction carries information about the endorsement of a
// specific proposal
message ChaincodeEndorsedAction {
    // This is the bytes of the ProposalResponsePayload message signed by the
    // endorsers.  Recall that for the CHAINCODE type, the
    // ProposalResponsePayload's extenstion field carries a ChaincodeAction
    bytes proposal_response_payload = 1;

    // The endorsement of the proposal, basically the endorser's signature over
    // proposalResponsePayload
    repeated Endorsement endorsements = 2;
}

enum TxValidationCode {
    VALID = 0;
    NIL_ENVELOPE = 1;
    BAD_PAYLOAD = 2;
    BAD_COMMON_HEADER = 3;
    BAD_CREATOR_SIGNATURE = 4;
    INVALID_ENDORSER_TRANSACTION = 5;
    INVALID_CONFIG_TRANSACTION = 6;
    UNSUPPORTED_TX_PAYLOAD = 7;
    BAD_PROPOSAL_TXID = 8;
    DUPLICATE_TXID = 9;
    ENDORSEMENT_POLICY_FAILURE = 10;
    MVCC_READ_CONFLICT = 11;
    PHANTOM_READ_CONFLICT = 12;
    UNKNOWN_TX_TYPE = 13;
    TARGET_CHAIN_NOT_FOUND = 14;
    MARSHAL_TX_ERROR = 15;
    NIL_TXACTION = 16;
    EXPIRED_CHAINCODE = 17;
    CHAINCODE_VERSION_CONFLICT = 18;
    BAD_HEADER_EXTENSION = 19;
    BAD_CHANNEL_HEADER = 20;
    BAD_RESPONSE_PAYLOAD = 21;
    BAD_RWSET = 22;
    ILLEGAL_WRITESET = 23;
    INVALID_WRITESET = 24;
    INVALID_CHAINCODE = 25;
    NOT_VALIDATED = 254;
    INVALID_OTHER_REASON = 255;
}

// Reserved entries in the key-level metadata map
enum MetaDataKeys {
    VALIDATION_PARAMETER = 0;
    VALIDATION_PARAMETER_V2 = 1;
}

</code></pre>
<h2><a class="header" href="#srcpeerconfigurationproto" id="srcpeerconfigurationproto">src:./peer/configuration.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

// AnchorPeers simply represents list of anchor peers which is used in ConfigurationItem
message AnchorPeers {
    repeated AnchorPeer anchor_peers = 1;
}

// AnchorPeer message structure which provides information about anchor peer, it includes host name,
// port number and peer certificate.
message AnchorPeer {
    string host = 1; // DNS host name of the anchor peer
    int32 port  = 2; // The port number
}

// APIResource represents an API resource in the peer whose ACL
// is determined by the policy_ref field
message APIResource {
    string policy_ref = 1; // The policy name to use for this API
}

// ACLs provides mappings for resources in a channel. APIResource encapsulates
// reference to a policy used to determine ACL for the resource
message ACLs {
    map&lt;string, APIResource&gt; acls = 1;
}

</code></pre>
<h2><a class="header" href="#srcpeersigned_cc_dep_specproto" id="srcpeersigned_cc_dep_specproto">src:./peer/signed_cc_dep_spec.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

import &quot;peer/proposal_response.proto&quot;;

// SignedChaincodeDeploymentSpec carries the CDS along with endorsements
message SignedChaincodeDeploymentSpec {
    // This is the bytes of the ChaincodeDeploymentSpec
    bytes chaincode_deployment_spec = 1;

    // This is the instantiation policy which is identical in structure
    // to endorsement policy.  This policy is checked by the VSCC at commit
    // time on the instantiation (all peers will get the same policy as it
    // will be part of the LSCC instantation record and will be part of the
    // hash as well)
    bytes instantiation_policy = 2;

    // The endorsements of the above deployment spec, the owner's signature over
    // chaincode_deployment_spec and Endorsement.endorser.
    repeated Endorsement owner_endorsements = 3;
}


</code></pre>
<h2><a class="header" href="#srcpeerchaincodeproto" id="srcpeerchaincodeproto">src:./peer/chaincode.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

import &quot;common/policies.proto&quot;;

//ChaincodeID contains the path as specified by the deploy transaction
//that created it as well as the hashCode that is generated by the
//system for the path. From the user level (ie, CLI, REST API and so on)
//deploy transaction is expected to provide the path and other requests
//are expected to provide the hashCode. The other value will be ignored.
//Internally, the structure could contain both values. For instance, the
//hashCode will be set when first generated using the path
message ChaincodeID {
    //deploy transaction will use the path
    string path = 1;

    //all other requests will use the name (really a hashcode) generated by
    //the deploy transaction
    string name = 2;

    //user friendly version name for the chaincode
    string version = 3;
}

// Carries the chaincode function and its arguments.
// UnmarshalJSON in transaction.go converts the string-based REST/JSON input to
// the []byte-based current ChaincodeInput structure.
message ChaincodeInput {
    repeated bytes args  = 1;
    map&lt;string, bytes&gt; decorations = 2;

    // is_init is used for the application to signal that an invocation is to be routed
    // to the legacy 'Init' function for compatibility with chaincodes which handled
    // Init in the old way.  New applications should manage their initialized state
    // themselves.
    bool is_init = 3;
}

// Carries the chaincode specification. This is the actual metadata required for
// defining a chaincode.
message ChaincodeSpec {

    enum Type {
        UNDEFINED = 0;
        GOLANG = 1;
        NODE = 2;
        CAR = 3;
        JAVA = 4;
    }

    Type type = 1;
    ChaincodeID chaincode_id = 2;
    ChaincodeInput input = 3;
    int32 timeout = 4;
}

// Specify the deployment of a chaincode.
// TODO: Define `codePackage`.
message ChaincodeDeploymentSpec {
    // Prevent removed tag re-use
    reserved 2, 4;
    reserved &quot;effective_date&quot;, &quot;exec_env&quot;;

    ChaincodeSpec chaincode_spec = 1;
    bytes code_package = 3;

}

// Carries the chaincode function and its arguments.
message ChaincodeInvocationSpec {
    // Prevent removed tag re-use
    reserved 2;
    reserved &quot;id_generation_alg&quot;;

    ChaincodeSpec chaincode_spec = 1;
}

// LifecycleEvent is used as the payload of the chaincode event emitted by LSCC
message LifecycleEvent {
    string chaincode_name = 1;
}

// CDSData is data stored in the LSCC on instantiation of a CC
// for CDSPackage.  This needs to be serialized for ChaincodeData
// hence the protobuf format
message CDSData {
    bytes hash = 1; // hash of ChaincodeDeploymentSpec.code_package
    bytes metadatahash = 2; // hash of ChaincodeID.name + ChaincodeID.version
}

// ChaincodeData defines the datastructure for chaincodes to be serialized by proto
// Type provides an additional check by directing to use a specific package after instantiation
// Data is Type specific (see CDSPackage and SignedCDSPackage)
message ChaincodeData {

    // Name of the chaincode
    string name = 1;

    // Version of the chaincode
    string version = 2;

    // Escc for the chaincode instance
    string escc = 3;

    // Vscc for the chaincode instance
    string vscc = 4;

    // Policy endorsement policy for the chaincode instance
    common.SignaturePolicyEnvelope policy = 5;

    // Data data specific to the package
    bytes data = 6;

    // Id of the chaincode that's the unique fingerprint for the CC This is not
    // currently used anywhere but serves as a good eyecatcher
    bytes id = 7;

    // InstantiationPolicy for the chaincode
    common.SignaturePolicyEnvelope instantiation_policy = 8;
}

</code></pre>
<h2><a class="header" href="#srcpeerproposal_responseproto" id="srcpeerproposal_responseproto">src:./peer/proposal_response.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option java_outer_classname = &quot;ProposalResponsePackage&quot;;

package protos;

import &quot;google/protobuf/timestamp.proto&quot;;

// A ProposalResponse is returned from an endorser to the proposal submitter.
// The idea is that this message contains the endorser's response to the
// request of a client to perform an action over a chaincode (or more
// generically on the ledger); the response might be success/error (conveyed in
// the Response field) together with a description of the action and a
// signature over it by that endorser.  If a sufficient number of distinct
// endorsers agree on the same action and produce signature to that effect, a
// transaction can be generated and sent for ordering.
message ProposalResponse {
    // Version indicates message protocol version
    int32 version = 1;

    // Timestamp is the time that the message
    // was created as  defined by the sender
    google.protobuf.Timestamp timestamp = 2;

    // A response message indicating whether the
    // endorsement of the action was successful
    Response response = 4;

    // The payload of response. It is the bytes of ProposalResponsePayload
    bytes payload = 5;

    // The endorsement of the proposal, basically
    // the endorser's signature over the payload
    Endorsement endorsement = 6;
}

// A response with a representation similar to an HTTP response that can
// be used within another message.
message Response {
    // A status code that should follow the HTTP status codes.
    int32 status = 1;

    // A message associated with the response code.
    string message = 2;

    // A payload that can be used to include metadata with this response.
    bytes payload = 3;
}

// ProposalResponsePayload is the payload of a proposal response.  This message
// is the &quot;bridge&quot; between the client's request and the endorser's action in
// response to that request. Concretely, for chaincodes, it contains a hashed
// representation of the proposal (proposalHash) and a representation of the
// chaincode state changes and events inside the extension field.
message ProposalResponsePayload {
    // Hash of the proposal that triggered this response. The hash is used to
    // link a response with its proposal, both for bookeeping purposes on an
    // asynchronous system and for security reasons (accountability,
    // non-repudiation). The hash usually covers the entire Proposal message
    // (byte-by-byte).
    bytes proposal_hash = 1;

    // Extension should be unmarshaled to a type-specific message. The type of
    // the extension in any proposal response depends on the type of the proposal
    // that the client selected when the proposal was initially sent out.  In
    // particular, this information is stored in the type field of a Header.  For
    // chaincode, it's a ChaincodeAction message
    bytes extension = 2;
}

// An endorsement is a signature of an endorser over a proposal response.  By
// producing an endorsement message, an endorser implicitly &quot;approves&quot; that
// proposal response and the actions contained therein. When enough
// endorsements have been collected, a transaction can be generated out of a
// set of proposal responses.  Note that this message only contains an identity
// and a signature but no signed payload. This is intentional because
// endorsements are supposed to be collected in a transaction, and they are all
// expected to endorse a single proposal response/action (many endorsements
// over a single proposal response)
message Endorsement {
    // Identity of the endorser (e.g. its certificate)
    bytes endorser = 1;

    // Signature of the payload included in ProposalResponse concatenated with
    // the endorser's certificate; ie, sign(ProposalResponse.payload + endorser)
    bytes signature = 2;
}

</code></pre>
<h2><a class="header" href="#srcpeerqueryproto" id="srcpeerqueryproto">src:./peer/query.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

// ChaincodeQueryResponse returns information about each chaincode that pertains
// to a query in lscc.go, such as GetChaincodes (returns all chaincodes
// instantiated on a channel), and GetInstalledChaincodes (returns all chaincodes
// installed on a peer)
message ChaincodeQueryResponse {
    repeated ChaincodeInfo chaincodes = 1;
}

// ChaincodeInfo contains general information about an installed/instantiated
// chaincode
message ChaincodeInfo {
    string name = 1;
    string version = 2;
    // the path as specified by the install/instantiate transaction
    string path = 3;
    // the chaincode function upon instantiation and its arguments. This will be
    // blank if the query is returning information about installed chaincodes.
    string input = 4;
    // the name of the ESCC for this chaincode. This will be
    // blank if the query is returning information about installed chaincodes.
    string escc = 5;
    // the name of the VSCC for this chaincode. This will be
    // blank if the query is returning information about installed chaincodes.
    string vscc = 6;
    // the chaincode unique id.
    // computed as: H(
    //                H(name || version) ||
    //                H(CodePackage)
    //              )
    bytes id = 7;
}

// ChannelQueryResponse returns information about each channel that pertains
// to a query in lscc.go, such as GetChannels (returns all channels for a
// given peer)
message ChannelQueryResponse {
    repeated ChannelInfo channels = 1;
}

// ChannelInfo contains general information about channels
message ChannelInfo {
    string channel_id = 1;
}

</code></pre>
<h2><a class="header" href="#srcpeerresourcesproto" id="srcpeerresourcesproto">src:./peer/resources.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

import &quot;common/configtx.proto&quot;;

// ChaincodeIdentifier identifies a piece of chaincode.  For a peer to accept invocations of
// this chaincode, the hash of the installed code must match, as must the version string
// included with the install command.
message ChaincodeIdentifier {
    bytes hash = 1;     // The hash of the chaincode bytes
    string version = 2; // A user friendly human readable name corresponding to the ID
}

// ChaincodeValidation instructs the peer how transactions for this chaincode should be
// validated.  The only validation mechanism which ships with fabric today is the standard
// 'vscc' validation mechanism.  This built in validation method utilizes an endorsement policy
// which checks that a sufficient number of signatures have been included.  The 'arguement'
// field encodes any parameters required by the validation implementation.
message ChaincodeValidation {
    string name = 1;    // Specifies which code to run to validate transactions, defaults to 'vscc'
    bytes argument = 2; // When 'vscc' a marshaled VSCCArgs
}

// VSCCArgs is passed (marshaled) as a parameter to the VSCC imlementation via the
// argument field of the ChaincodeValidation message.
message VSCCArgs {
    string endorsement_policy_ref = 1;  // A named reference to an endorsement policy,
                                        // for instance /Channel/Application/Writers
}

// ChaincodeEndorsement instructs the peer how transactions should be endorsed.  The only
// endorsement mechanism which ships with the fabric today is the standard 'escc' mechanism.
// This code simply simulates the proposal to generate a RW set, then signs the result
// using the peer's local signing identity.
message ChaincodeEndorsement {
    string name = 1; // Specifies what code to run for endorsements, defaults 'escc'
    // Eventually we may wish add an arg here, just like the ChaincodeValidation message, but
    // omitting now until there is a need for it.
}

// ConfigTree encapsulates channel and resources configuration of a channel.
// Both configurations are represented as common.Config
message ConfigTree {
    common.Config channel_config = 1;
    common.Config resources_config = 2;
}

</code></pre>
<h2><a class="header" href="#srcpeereventsproto" id="srcpeereventsproto">src:./peer/events.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option java_outer_classname = &quot;EventsPackage&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

import &quot;common/common.proto&quot;;
import &quot;ledger/rwset/rwset.proto&quot;;
import &quot;peer/chaincode_event.proto&quot;;
import &quot;peer/transaction.proto&quot;;

// FilteredBlock is a minimal set of information about a block
message FilteredBlock {
    string channel_id = 1;
    uint64 number = 2; // The position in the blockchain
    repeated FilteredTransaction filtered_transactions = 4;
}

// FilteredTransaction is a minimal set of information about a transaction
// within a block
message FilteredTransaction {
    string txid = 1;
    common.HeaderType type = 2;
    TxValidationCode tx_validation_code = 3;
    oneof Data {
        FilteredTransactionActions transaction_actions = 4;
    }
}

// FilteredTransactionActions is a wrapper for array of TransactionAction
// message from regular block
message FilteredTransactionActions {
    repeated FilteredChaincodeAction chaincode_actions = 1;
}

// FilteredChaincodeAction is a minimal set of information about an action
// within a transaction
message FilteredChaincodeAction {
    ChaincodeEvent chaincode_event = 1;
}

// BlockAndPrivateData contains Block and a map from tx_seq_in_block to rwset.TxPvtReadWriteSet
message BlockAndPrivateData {
    common.Block block = 1;
    // map from tx_seq_in_block to rwset.TxPvtReadWriteSet
    map&lt;uint64, rwset.TxPvtReadWriteSet&gt; private_data_map = 2;
}

// DeliverResponse
message DeliverResponse {
    oneof Type {
        common.Status status = 1;
        common.Block block = 2;
        FilteredBlock filtered_block = 3;
        BlockAndPrivateData block_and_private_data = 4;
    }
}

service Deliver {
    // Deliver first requires an Envelope of type ab.DELIVER_SEEK_INFO with
    // Payload data as a marshaled orderer.SeekInfo message,
    // then a stream of block replies is received
    rpc Deliver (stream common.Envelope) returns (stream DeliverResponse) {
    }
    // DeliverFiltered first requires an Envelope of type ab.DELIVER_SEEK_INFO with
    // Payload data as a marshaled orderer.SeekInfo message,
    // then a stream of **filtered** block replies is received
    rpc DeliverFiltered (stream common.Envelope) returns (stream DeliverResponse) {
    }
    // DeliverWithPrivateData first requires an Envelope of type ab.DELIVER_SEEK_INFO with
    // Payload data as a marshaled orderer.SeekInfo message,
    // then a stream of block and private data replies is received
    rpc DeliverWithPrivateData (stream common.Envelope) returns (stream DeliverResponse) {
    }
}

</code></pre>
<h2><a class="header" href="#srcpeerproposalproto" id="srcpeerproposalproto">src:./peer/proposal.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option java_outer_classname = &quot;ProposalPackage&quot;;

package protos;

import &quot;peer/chaincode.proto&quot;;
import &quot;peer/proposal_response.proto&quot;;

/*
The flow to get a generic transaction approved goes as follows:

1. client sends proposal to endorser
====================================

The proposal is basically a request to do something that will result on some
action with impact on the ledger; a proposal contains a header (with some
metadata describing it, such as the type, the identity of the invoker, the
time, the ID of the chain, a cryptographic nonce..) and an opaque payload that
depends on the type specified in the header. A proposal contains the following
messages:

SignedProposal
|\_ Signature                                    (signature on the Proposal message by the creator specified in the header)
 \_ Proposal
    |\_ Header                                   (the header for this proposal)
     \_ Payload                                  (the payload for this proposal)

2. endorser sends proposal response back to client
==================================================

The proposal response contains an endorser's response to a client's proposal. A
proposal response contains a success/error code, a response payload and a
signature (also referred to as endorsement) over the response payload. The
response payload contains a hash of the proposal (to securely link this
response to the corresponding proposal) and an opaque extension field that
depends on the type specified in the header of the corresponding proposal. A
proposal response contains the following messages:

ProposalResponse
|\_ Endorsement                                  (the endorser's signature over the whole response payload)
 \_ ProposalResponsePayload                      (the payload of the proposal response)

3. client assembles endorsements into a transaction
===================================================

A transaction message assembles one or more proposals and corresponding
responses into a message to be sent to orderers. After ordering, (batches of)
transactions are delivered to committing peers for validation and final
delivery into the ledger. A transaction contains one or more actions. Each of
them contains a header (same as that of the proposal that requested it) and an
opaque payload that depends on the type specified in the header.

SignedTransaction
|\_ Signature                                    (signature on the Transaction message by the creator specified in the header)
 \_ Transaction
     \_ TransactionAction (1...n)
        |\_ Header (1)                           (the header of the proposal that requested this action)
         \_ Payload (1)                          (the payload for this action)
*/

// This structure is necessary to sign the proposal which contains the header
// and the payload. Without this structure, we would have to concatenate the
// header and the payload to verify the signature, which could be expensive
// with large payload
//
// When an endorser receives a SignedProposal message, it should verify the
// signature over the proposal bytes. This verification requires the following
// steps:
// 1. Verification of the validity of the certificate that was used to produce
//    the signature.  The certificate will be available once proposalBytes has
//    been unmarshalled to a Proposal message, and Proposal.header has been
//    unmarshalled to a Header message. While this unmarshalling-before-verifying
//    might not be ideal, it is unavoidable because i) the signature needs to also
//    protect the signing certificate; ii) it is desirable that Header is created
//    once by the client and never changed (for the sake of accountability and
//    non-repudiation). Note also that it is actually impossible to conclusively
//    verify the validity of the certificate included in a Proposal, because the
//    proposal needs to first be endorsed and ordered with respect to certificate
//    expiration transactions. Still, it is useful to pre-filter expired
//    certificates at this stage.
// 2. Verification that the certificate is trusted (signed by a trusted CA) and
//    that it is allowed to transact with us (with respect to some ACLs);
// 3. Verification that the signature on proposalBytes is valid;
// 4. Detect replay attacks;
message SignedProposal {

    // The bytes of Proposal
    bytes proposal_bytes = 1;

  // Signaure over proposalBytes; this signature is to be verified against
  // the creator identity contained in the header of the Proposal message
  // marshaled as proposalBytes
    bytes signature = 2;
}

// A Proposal is sent to an endorser for endorsement.  The proposal contains:
// 1. A header which should be unmarshaled to a Header message.  Note that
//    Header is both the header of a Proposal and of a Transaction, in that i)
//    both headers should be unmarshaled to this message; and ii) it is used to
//    compute cryptographic hashes and signatures.  The header has fields common
//    to all proposals/transactions.  In addition it has a type field for
//    additional customization. An example of this is the ChaincodeHeaderExtension
//    message used to extend the Header for type CHAINCODE.
// 2. A payload whose type depends on the header's type field.
// 3. An extension whose type depends on the header's type field.
//
// Let us see an example. For type CHAINCODE (see the Header message),
// we have the following:
// 1. The header is a Header message whose extensions field is a
//    ChaincodeHeaderExtension message.
// 2. The payload is a ChaincodeProposalPayload message.
// 3. The extension is a ChaincodeAction that might be used to ask the
//    endorsers to endorse a specific ChaincodeAction, thus emulating the
//    submitting peer model.
message Proposal {

    // The header of the proposal. It is the bytes of the Header
    bytes header = 1;

    // The payload of the proposal as defined by the type in the proposal
    // header.
    bytes payload = 2;

    // Optional extensions to the proposal. Its content depends on the Header's
    // type field.  For the type CHAINCODE, it might be the bytes of a
    // ChaincodeAction message.
    bytes extension = 3;
}

//-------- the Chaincode Proposal -----------

/*
The flow to get a CHAINCODE transaction approved goes as follows:

1. client sends proposal to endorser
====================================

The proposal is basically a request to do something on a chaincode, that will
result on some action - some change in the state of a chaincode and/or some
data to be committed to the ledger; a proposal in general contains a header
(with some metadata describing it, such as the type, the identity of the
invoker, the time, the ID of the chain, a cryptographic nonce..) and a payload
(the chaincode ID, invocation arguments..). Optionally, it may contain actions
that the endorser may be asked to endorse, to emulate a submitting peer. A
chaincode proposal contains the following messages:

SignedProposal
|\_ Signature                                    (signature on the Proposal message by the creator specified in the header)
 \_ Proposal
    |\_ Header                                   (the header for this proposal)
    |\_ ChaincodeProposalPayload                 (the payload for this proposal)
     \_ ChaincodeAction                          (the actions for this proposal - optional for a proposal)

2. endorser sends proposal response back to client
==================================================

The proposal response contains an endorser's response to a client's proposal. A
proposal response contains a success/error code, a response payload and a
signature (also referred to as endorsement) over the response payload. The
response payload contains a hash of the proposal (to securely link this
response to the corresponding proposal), a description of the action resulting
from the proposal and the endorser's signature over its payload. Formally, a
chaincode proposal response contains the following messages:

ProposalResponse
|\_ Endorsement                                  (the endorser's signature over the whole response payload)
 \_ ProposalResponsePayload
     \_ ChaincodeAction                          (the actions for this proposal)

3. client assembles endorsements into a transaction
===================================================

A transaction message assembles one or more proposals and corresponding
responses into a message to be sent to orderers. After ordering, (batches of)
transactions are delivered to committing peers for validation and final
delivery into the ledger. A transaction contains one or more actions. Each of
them contains a header (same as that of the proposal that requested it), a
proposal payload (same as that of the proposal that requested it), a
description of the resulting action and signatures from each of the endorsers
that endorsed the action.

SignedTransaction
|\_ Signature                                    (signature on the Transaction message by the creator specified in the header)
 \_ Transaction
     \_ TransactionAction (1...n)
        |\_ Header (1)                           (the header of the proposal that requested this action)
         \_ ChaincodeActionPayload (1)
            |\_ ChaincodeProposalPayload (1)     (payload of the proposal that requested this action)
             \_ ChaincodeEndorsedAction (1)
                |\_ Endorsement (1...n)          (endorsers' signatures over the whole response payload)
                 \_ ProposalResponsePayload
                     \_ ChaincodeAction          (the actions for this proposal)
*/

// ChaincodeHeaderExtension is the Header's extentions message to be used when
// the Header's type is CHAINCODE.  This extensions is used to specify which
// chaincode to invoke and what should appear on the ledger.
message ChaincodeHeaderExtension {

    reserved 1;
    reserved &quot;payload_visbility&quot;;

    // The ID of the chaincode to target.
    ChaincodeID chaincode_id = 2;
}

// ChaincodeProposalPayload is the Proposal's payload message to be used when
// the Header's type is CHAINCODE.  It contains the arguments for this
// invocation.
message ChaincodeProposalPayload {

    // Input contains the arguments for this invocation. If this invocation
    // deploys a new chaincode, ESCC/VSCC are part of this field.
    // This is usually a marshaled ChaincodeInvocationSpec
    bytes input  = 1;

    // TransientMap contains data (e.g. cryptographic material) that might be used
    // to implement some form of application-level confidentiality. The contents
    // of this field are supposed to always be omitted from the transaction and
    // excluded from the ledger.
    map&lt;string, bytes&gt; TransientMap = 2;
}

// ChaincodeAction contains the actions the events generated by the execution
// of the chaincode.
message ChaincodeAction {
    reserved 5;
    reserved &quot;token_operations&quot;;

    // This field contains the read set and the write set produced by the
    // chaincode executing this invocation.
    bytes results = 1;

    // This field contains the events generated by the chaincode executing this
    // invocation.
    bytes events = 2;

    // This field contains the result of executing this invocation.
    Response response = 3;

    // This field contains the ChaincodeID of executing this invocation. Endorser
    // will set it with the ChaincodeID called by endorser while simulating proposal.
    // Committer will validate the version matching with latest chaincode version.
    // Adding ChaincodeID to keep version opens up the possibility of multiple
    // ChaincodeAction per transaction.
    ChaincodeID chaincode_id = 4;
}

</code></pre>
<h2><a class="header" href="#srcpeerpolicyproto" id="srcpeerpolicyproto">src:./peer/policy.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;

package protos;

import &quot;common/policies.proto&quot;;

// ApplicationPolicy captures the diffenrent policy types that
// are set and evaluted at the application level.
message ApplicationPolicy {
    oneof Type {
        // SignaturePolicy type is used if the policy is specified as
        // a combination (using threshold gates) of signatures from MSP
        // principals
        common.SignaturePolicyEnvelope signature_policy = 1;

        // ChannelConfigPolicyReference is used when the policy is
        // specified as a string that references a policy defined in
        // the configuration of the channel
        string channel_config_policy_reference = 2;
    }
}

</code></pre>
<h2><a class="header" href="#srcpeerlifecyclechaincode_definitionproto" id="srcpeerlifecyclechaincode_definitionproto">src:./peer/lifecycle/chaincode_definition.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer.lifecycle&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer/lifecycle&quot;;

package lifecycle;

// These protos are used for encoding chaincode definitions into the statedb
// in general, it should not be necessary for clients to utilize them.

// ChaincodeEndorsementInfo is (most) everything the peer needs to know in order
// to execute a chaincode
message ChaincodeEndorsementInfo {
    string version = 1;
    bool init_required = 2;
    string endorsement_plugin = 3;
}

// ValidationInfo is (most) everything the peer needs to know in order
// to validate a transaction
message ChaincodeValidationInfo {
    string validation_plugin = 1;
    bytes validation_parameter = 2;
}

// The notable omission in this file is the collection configuration info.
// It should be moved to this package, but... defering for now.

</code></pre>
<h2><a class="header" href="#srcpeerlifecyclelifecycleproto" id="srcpeerlifecyclelifecycleproto">src:./peer/lifecycle/lifecycle.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer.lifecycle&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer/lifecycle&quot;;

package lifecycle;

import &quot;common/collection.proto&quot;;

// InstallChaincodeArgs is the message used as the argument to
// '_lifecycle.InstallChaincode'.
message InstallChaincodeArgs {
    bytes chaincode_install_package = 1; // This should be a marshaled lifecycle.ChaincodePackage
}

// InstallChaincodeArgs is the message returned by
// '_lifecycle.InstallChaincode'.
message InstallChaincodeResult {
    string package_id = 1;
    string label = 2;
}

// QueryInstalledChaincodeArgs is the message used as arguments
// '_lifecycle.QueryInstalledChaincode'
message QueryInstalledChaincodeArgs {
    string package_id = 1;
}

// QueryInstalledChaincodeResult is the message returned by
// '_lifecycle.QueryInstalledChaincode'
message QueryInstalledChaincodeResult {
    string package_id = 1;
    string label = 2;
    map&lt;string, References&gt; references = 3;

    message References {
        repeated Chaincode chaincodes = 1;
    }

    message Chaincode {
        string name = 1;
        string version = 2;
    }
}

// GetInstalledChaincodePackageArgs is the message used as the argument to
// '_lifecycle.GetInstalledChaincodePackage'.
message GetInstalledChaincodePackageArgs {
    string package_id = 1;
}

// GetInstalledChaincodePackageResult is the message returned by
// '_lifecycle.GetInstalledChaincodePackage'.
message GetInstalledChaincodePackageResult {
    bytes chaincode_install_package = 1;
}

// QueryInstalledChaincodesArgs currently is an empty argument to
// '_lifecycle.QueryInstalledChaincodes'.   In the future, it may be
// extended to have parameters.
message QueryInstalledChaincodesArgs {
}

// QueryInstalledChaincodesResult is the message returned by
// '_lifecycle.QueryInstalledChaincodes'.  It returns a list of installed
// chaincodes, including a map of channel name to chaincode name and version
// pairs of chaincode definitions that reference this chaincode package.
message QueryInstalledChaincodesResult {
    message InstalledChaincode {
        string package_id = 1;
        string label = 2;
        map&lt;string, References&gt; references = 3;
    }

    message References {
        repeated Chaincode chaincodes = 1;
    }

    message Chaincode {
        string name = 1;
        string version = 2;
    }

    repeated InstalledChaincode installed_chaincodes = 1;
}

// ApproveChaincodeDefinitionForMyOrgArgs is the message used as arguments to
// `_lifecycle.ApproveChaincodeDefinitionForMyOrg`.
message ApproveChaincodeDefinitionForMyOrgArgs {
    int64 sequence = 1;
    string name = 2;
    string version = 3;
    string endorsement_plugin = 4;
    string validation_plugin = 5;
    bytes validation_parameter = 6;
    common.CollectionConfigPackage collections = 7;
    bool init_required = 8;
    ChaincodeSource source = 9;
}

message ChaincodeSource {
    message Unavailable {}

    message Local {
        string package_id = 1;
    }

    oneof Type {
        Unavailable unavailable = 1;
        Local local_package = 2;
    }
}

// ApproveChaincodeDefinitionForMyOrgResult is the message returned by
// `_lifecycle.ApproveChaincodeDefinitionForMyOrg`. Currently it returns
// nothing, but may be extended in the future.
message ApproveChaincodeDefinitionForMyOrgResult {
}

// CommitChaincodeDefinitionArgs is the message used as arguments to
// `_lifecycle.CommitChaincodeDefinition`.
message CommitChaincodeDefinitionArgs {
    int64 sequence = 1;
    string name = 2;
    string version = 3;
    string endorsement_plugin = 4;
    string validation_plugin = 5;
    bytes validation_parameter = 6;
    common.CollectionConfigPackage collections = 7;
    bool init_required = 8;
}

// CommitChaincodeDefinitionResult is the message returned by
// `_lifecycle.CommitChaincodeDefinition`. Currently it returns
// nothing, but may be extended in the future.
message CommitChaincodeDefinitionResult {
}

// CheckCommitReadinessArgs is the message used as arguments to
// `_lifecycle.CheckCommitReadiness`.
message CheckCommitReadinessArgs {
    int64 sequence = 1;
    string name = 2;
    string version = 3;
    string endorsement_plugin = 4;
    string validation_plugin = 5;
    bytes validation_parameter = 6;
    common.CollectionConfigPackage collections = 7;
    bool init_required = 8;
}

// CheckCommitReadinessResult is the message returned by
// `_lifecycle.CheckCommitReadiness`. It returns a map of
// orgs to their approval (true/false) for the definition 
// supplied as args.
message CheckCommitReadinessResult{
    map&lt;string, bool&gt; approvals = 1;
}

// QueryChaincodeDefinitionArgs is the message used as arguments to
// `_lifecycle.QueryChaincodeDefinition`.
message QueryChaincodeDefinitionArgs {
    string name = 1;
}

// QueryChaincodeDefinitionResult is the message returned by
// `_lifecycle.QueryChaincodeDefinition`.
message QueryChaincodeDefinitionResult {
    int64 sequence = 1;
    string version = 2;
    string endorsement_plugin = 3;
    string validation_plugin = 4;
    bytes validation_parameter = 5;
    common.CollectionConfigPackage collections = 6;
    bool init_required = 7;
    map&lt;string,bool&gt; approvals = 8;
}

// QueryChaincodeDefinitionsArgs is the message used as arguments to
// `_lifecycle.QueryChaincodeDefinitions`.
message QueryChaincodeDefinitionsArgs { }

// QueryChaincodeDefinitionsResult is the message returned by
// `_lifecycle.QueryChaincodeDefinitions`.
message QueryChaincodeDefinitionsResult {
    message ChaincodeDefinition {
        string name = 1;
        int64 sequence = 2;
        string version = 3;
        string endorsement_plugin = 4;
        string validation_plugin = 5;
        bytes validation_parameter = 6;
        common.CollectionConfigPackage collections = 7;
        bool init_required = 8;
    }
    repeated ChaincodeDefinition chaincode_definitions = 1;
}

</code></pre>
<h2><a class="header" href="#srcpeerlifecycledbproto" id="srcpeerlifecycledbproto">src:./peer/lifecycle/db.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer.lifecycle&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer/lifecycle&quot;;

package lifecycle;

// These protos are used for encoding data into the statedb
// in general, it should not be necessary for clients to utilize them.

// StateMetadata describes the keys in a namespace.  It is necessary because
// in collections, range scans are not possible during transactions which
// write.  Therefore we must track the keys in our namespace ourselves.
message StateMetadata {
    string datatype = 1;
    repeated string fields = 2;
}

// StateData encodes a particular field of a datatype
message StateData {
    oneof Type {
        int64 Int64 = 1;
        bytes Bytes = 2;
        string String = 3;
    }
}

</code></pre>
<h2><a class="header" href="#srcpeerchaincode_eventproto" id="srcpeerchaincode_eventproto">src:./peer/chaincode_event.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option java_outer_classname = &quot;ChaincodeEventPackage&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

//ChaincodeEvent is used for events and registrations that are specific to chaincode
//string type - &quot;chaincode&quot;
message ChaincodeEvent {
    string chaincode_id = 1;
    string tx_id = 2;
    string event_name = 3;
    bytes payload = 4;
}

</code></pre>
<h2><a class="header" href="#srcpeerchaincode_shimproto" id="srcpeerchaincode_shimproto">src:./peer/chaincode_shim.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

import &quot;peer/chaincode_event.proto&quot;;
import &quot;peer/proposal.proto&quot;;
import &quot;google/protobuf/timestamp.proto&quot;;

message ChaincodeMessage {
    enum Type {
        UNDEFINED = 0;
        REGISTER = 1;
        REGISTERED = 2;
        INIT = 3;
        READY = 4;
        TRANSACTION = 5;
        COMPLETED = 6;
        ERROR = 7;
        GET_STATE = 8;
        PUT_STATE = 9;
        DEL_STATE = 10;
        INVOKE_CHAINCODE = 11;
        RESPONSE = 13;
        GET_STATE_BY_RANGE = 14;
        GET_QUERY_RESULT = 15;
        QUERY_STATE_NEXT = 16;
        QUERY_STATE_CLOSE = 17;
        KEEPALIVE = 18;
        GET_HISTORY_FOR_KEY = 19;
        GET_STATE_METADATA = 20;
        PUT_STATE_METADATA = 21;
        GET_PRIVATE_DATA_HASH = 22;
    }

    Type type = 1;
    google.protobuf.Timestamp timestamp = 2;
    bytes payload = 3;
    string txid = 4;

    SignedProposal proposal = 5;

    //event emitted by chaincode. Used only with Init or Invoke.
    // This event is then stored (currently)
    //with Block.NonHashData.TransactionResult
    ChaincodeEvent chaincode_event = 6;

    //channel id
    string channel_id = 7;
}

// TODO: We need to finalize the design on chaincode container
// compatibility upon upgrade, see FAB-5777.

// GetState is the payload of a ChaincodeMessage. It contains a key which
// is to be fetched from the ledger. If the collection is specified, the key
// would be fetched from the collection (i.e., private state)
message GetState {
    string key = 1;
    string collection = 2;
}

message GetStateMetadata {
    string key = 1;
    string collection = 2;
}

// PutState is the payload of a ChaincodeMessage. It contains a key and value
// which needs to be written to the transaction's write set. If the collection is
// specified, the key and value would be written to the transaction's private
// write set.
message PutState {
    string key = 1;
    bytes value = 2;
    string collection = 3;
}

message PutStateMetadata {
    string key = 1;
    string collection = 3;
    StateMetadata metadata = 4;
}

// DelState is the payload of a ChaincodeMessage. It contains a key which
// needs to be recorded in the transaction's write set as a delete operation.
// If the collection is specified, the key needs to be recorded in the
// transaction's private write set as a delete operation.
message DelState {
    string key = 1;
    string collection = 2;
}

// GetStateByRange is the payload of a ChaincodeMessage. It contains a start key and
// a end key required to execute range query. If the collection is specified,
// the range query needs to be executed on the private data. The metadata hold
// the byte representation of QueryMetadata.
message GetStateByRange {
    string startKey = 1;
    string endKey = 2;
    string collection = 3;
    bytes metadata = 4;
}

// GetQueryResult is the payload of a ChaincodeMessage. It contains a query
// string in the form that is supported by the underlying state database.
// If the collection is specified, the query needs to be executed on the
// private data.  The metadata hold the byte representation of QueryMetadata.
message GetQueryResult {
    string query = 1;
    string collection = 2;
    bytes metadata = 3;
}

// QueryMetadata is the metadata of a GetStateByRange and GetQueryResult.
// It contains a pageSize which denotes the number of records to be fetched
// and a bookmark.
message QueryMetadata {
    int32 pageSize = 1;
    string bookmark = 2;
}

// GetHistoryForKey is the payload of a ChaincodeMessage. It contains a key
// for which the historical values need to be retrieved.
message GetHistoryForKey {
    string key = 1;
}

message QueryStateNext {
    string id = 1;
}

message QueryStateClose {
    string id = 1;
}

// QueryResultBytes hold the byte representation of a record returned by the peer.
message QueryResultBytes {
    bytes resultBytes = 1;
}

// QueryResponse is returned by the peer as a result of a GetStateByRange,
// GetQueryResult, and GetHistoryForKey. It holds a bunch of records in
// results field, a flag to denote whether more results need to be fetched from
// the peer in has_more field, transaction id in id field, and a QueryResponseMetadata
// in metadata field.
message QueryResponse {
    repeated QueryResultBytes results = 1;
    bool has_more = 2;
    string id = 3;
    bytes metadata = 4;
}

// QueryResponseMetadata is the metadata of a QueryResponse. It contains a count
// which denotes the number of records fetched from the ledger and a bookmark.
message QueryResponseMetadata {
    int32 fetched_records_count = 1;
    string bookmark = 2;
}

message StateMetadata {
    string metakey = 1;
    bytes value = 2;
}

message StateMetadataResult {
    repeated StateMetadata entries = 1;
}

// Interface that provides support to chaincode execution. ChaincodeContext
// provides the context necessary for the server to respond appropriately.
service ChaincodeSupport {
    rpc Register(stream ChaincodeMessage) returns (stream ChaincodeMessage);
}

</code></pre>
<h2><a class="header" href="#srcpeerpeerproto" id="srcpeerpeerproto">src:./peer/peer.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option java_package = &quot;org.hyperledger.fabric.protos.peer&quot;;
option go_package = &quot;github.com/hyperledger/fabric-protos-go/peer&quot;;

package protos;

import &quot;peer/proposal.proto&quot;;
import &quot;peer/proposal_response.proto&quot;;

service Endorser {
    rpc ProcessProposal(SignedProposal) returns (ProposalResponse);
}

</code></pre>
<h2><a class="header" href="#srcmspmsp_configproto" id="srcmspmsp_configproto">src:./msp/msp_config.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/msp&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.msp&quot;;
option java_outer_classname = &quot;MspConfigPackage&quot;;

package msp;

// MSPConfig collects all the configuration information for
// an MSP. The Config field should be unmarshalled in a way
// that depends on the Type
message MSPConfig {
    // Type holds the type of the MSP; the default one would
    // be of type FABRIC implementing an X.509 based provider
    int32 type = 1;

    // Config is MSP dependent configuration info
    bytes config = 2;
}

// FabricMSPConfig collects all the configuration information for
// a Fabric MSP.
// Here we assume a default certificate validation policy, where
// any certificate signed by any of the listed rootCA certs would
// be considered as valid under this MSP.
// This MSP may or may not come with a signing identity. If it does,
// it can also issue signing identities. If it does not, it can only
// be used to validate and verify certificates.
message FabricMSPConfig {
    // Name holds the identifier of the MSP; MSP identifier
    // is chosen by the application that governs this MSP.
    // For example, and assuming the default implementation of MSP,
    // that is X.509-based and considers a single Issuer,
    // this can refer to the Subject OU field or the Issuer OU field.
    string name = 1;

    // List of root certificates trusted by this MSP
    // they are used upon certificate validation (see
    // comment for IntermediateCerts below)
    repeated bytes root_certs = 2;

    // List of intermediate certificates trusted by this MSP;
    // they are used upon certificate validation as follows:
    // validation attempts to build a path from the certificate
    // to be validated (which is at one end of the path) and
    // one of the certs in the RootCerts field (which is at
    // the other end of the path). If the path is longer than
    // 2, certificates in the middle are searched within the
    // IntermediateCerts pool
    repeated bytes intermediate_certs = 3;

    // Identity denoting the administrator of this MSP
    repeated bytes admins = 4;

    // Identity revocation list
    repeated bytes revocation_list = 5;

    // SigningIdentity holds information on the signing identity
    // this peer is to use, and which is to be imported by the
    // MSP defined before
    SigningIdentityInfo signing_identity = 6;

    // OrganizationalUnitIdentifiers holds one or more
    // fabric organizational unit identifiers that belong to
    // this MSP configuration
    repeated FabricOUIdentifier organizational_unit_identifiers = 7;

    // FabricCryptoConfig contains the configuration parameters
    // for the cryptographic algorithms used by this MSP
    FabricCryptoConfig crypto_config = 8;

    // List of TLS root certificates trusted by this MSP.
    // They are returned by GetTLSRootCerts.
    repeated bytes tls_root_certs = 9;

    // List of TLS intermediate certificates trusted by this MSP;
    // They are returned by GetTLSIntermediateCerts.
    repeated bytes tls_intermediate_certs = 10;

    // fabric_node_ous contains the configuration to distinguish clients from peers from orderers
    // based on the OUs.
    FabricNodeOUs fabric_node_ous = 11;
}

// FabricCryptoConfig contains configuration parameters
// for the cryptographic algorithms used by the MSP
// this configuration refers to
message FabricCryptoConfig {

    // SignatureHashFamily is a string representing the hash family to be used
    // during sign and verify operations.
    // Allowed values are &quot;SHA2&quot; and &quot;SHA3&quot;.
    string signature_hash_family = 1;

    // IdentityIdentifierHashFunction is a string representing the hash function
    // to be used during the computation of the identity identifier of an MSP identity.
    // Allowed values are &quot;SHA256&quot;, &quot;SHA384&quot; and &quot;SHA3_256&quot;, &quot;SHA3_384&quot;.
    string identity_identifier_hash_function = 2;

}

// IdemixMSPConfig collects all the configuration information for
// an Idemix MSP.
message IdemixMSPConfig {
    // Name holds the identifier of the MSP
    string name = 1;

    // ipk represents the (serialized) issuer public key
    bytes ipk = 2;

    // signer may contain crypto material to configure a default signer
    IdemixMSPSignerConfig signer = 3;

    // revocation_pk is the public key used for revocation of credentials
    bytes revocation_pk = 4;

    // epoch represents the current epoch (time interval) used for revocation
    int64 epoch = 5;
}

// IdemixMSPSIgnerConfig contains the crypto material to set up an idemix signing identity
message IdemixMSPSignerConfig {
    // cred represents the serialized idemix credential of the default signer
    bytes cred = 1;

    // sk is the secret key of the default signer, corresponding to credential Cred
    bytes sk = 2;

    // organizational_unit_identifier defines the organizational unit the default signer is in
    string organizational_unit_identifier = 3;

    // role defines whether the default signer is admin, peer, member or client
    int32 role = 4;

    // enrollment_id contains the enrollment id of this signer
    string enrollment_id = 5;

    // credential_revocation_information contains a serialized CredentialRevocationInformation
    bytes credential_revocation_information = 6;
}

// SigningIdentityInfo represents the configuration information
// related to the signing identity the peer is to use for generating
// endorsements
message SigningIdentityInfo {
    // PublicSigner carries the public information of the signing
    // identity. For an X.509 provider this would be represented by
    // an X.509 certificate
    bytes public_signer = 1;

    // PrivateSigner denotes a reference to the private key of the
    // peer's signing identity
    KeyInfo private_signer = 2;
}

// KeyInfo represents a (secret) key that is either already stored
// in the bccsp/keystore or key material to be imported to the
// bccsp key-store. In later versions it may contain also a
// keystore identifier
message KeyInfo {
    // Identifier of the key inside the default keystore; this for
    // the case of Software BCCSP as well as the HSM BCCSP would be
    // the SKI of the key
    string key_identifier = 1;

    // KeyMaterial (optional) for the key to be imported; this is
    // properly encoded key bytes, prefixed by the type of the key
    bytes key_material = 2;
}

// FabricOUIdentifier represents an organizational unit and
// its related chain of trust identifier.
message FabricOUIdentifier {

    // Certificate represents the second certificate in a certification chain.
    // (Notice that the first certificate in a certification chain is supposed
    // to be the certificate of an identity).
    // It must correspond to the certificate of root or intermediate CA
    // recognized by the MSP this message belongs to.
    // Starting from this certificate, a certification chain is computed
    // and bound to the OrganizationUnitIdentifier specified
    bytes certificate = 1;

    // OrganizationUnitIdentifier defines the organizational unit under the
    // MSP identified with MSPIdentifier
    string organizational_unit_identifier = 2;
}

// FabricNodeOUs contains configuration to tell apart clients from peers from orderers
// based on OUs. If NodeOUs recognition is enabled then an msp identity
// that does not contain any of the specified OU will be considered invalid.
message FabricNodeOUs {
    // If true then an msp identity that does not contain any of the specified OU will be considered invalid.
    bool   enable = 1;

    // OU Identifier of the clients
    FabricOUIdentifier client_ou_identifier = 2;

    // OU Identifier of the peers
    FabricOUIdentifier peer_ou_identifier = 3;

    // OU Identifier of the admins
    FabricOUIdentifier admin_ou_identifier = 4;

    // OU Identifier of the orderers
    FabricOUIdentifier orderer_ou_identifier = 5;
}

</code></pre>
<h2><a class="header" href="#srcmspmsp_principalproto" id="srcmspmsp_principalproto">src:./msp/msp_principal.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/msp&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.common&quot;;

package common;

// msp_principal.proto contains proto messages defining the generalized
// MSP notion of identity called an MSPPrincipal.  It is used as part of
// the chain configuration, in particular as the identity parameters to
// the configuration.proto file.  This does not represent the MSP
// configuration for a chain, but is understood by MSPs

// MSPPrincipal aims to represent an MSP-centric set of identities.
// In particular, this structure allows for definition of
//  - a group of identities that are member of the same MSP
//  - a group of identities that are member of the same organization unit
//    in the same MSP
//  - a group of identities that are administering a specific MSP
//  - a specific identity
// Expressing these groups is done given two fields of the fields below
//  - Classification, that defines the type of classification of identities
//    in an MSP this principal would be defined on; Classification can take
//    three values:
//     (i)  ByMSPRole: that represents a classification of identities within
//          MSP based on one of the two pre-defined MSP rules, &quot;member&quot; and &quot;admin&quot;
//     (ii) ByOrganizationUnit: that represents a classification of identities
//          within MSP based on the organization unit an identity belongs to
//     (iii)ByIdentity that denotes that MSPPrincipal is mapped to a single
//          identity/certificate; this would mean that the Principal bytes
//          message
message MSPPrincipal {
    enum Classification {
        ROLE = 0;  // Represents the one of the dedicated MSP roles, the
        // one of a member of MSP network, and the one of an
        // administrator of an MSP network
        ORGANIZATION_UNIT = 1; // Denotes a finer grained (affiliation-based)
        // groupping of entities, per MSP affiliation
        // E.g., this can well be represented by an MSP's
        // Organization unit
        IDENTITY  = 2;    // Denotes a principal that consists of a single
        // identity
        ANONYMITY = 3; // Denotes a principal that can be used to enforce
        // an identity to be anonymous or nominal.
        COMBINED = 4; // Denotes a combined principal
    }

    // Classification describes the way that one should process
    // Principal. An Classification value of &quot;ByOrganizationUnit&quot; reflects
    // that &quot;Principal&quot; contains the name of an organization this MSP
    // handles. A Classification value &quot;ByIdentity&quot; means that
    // &quot;Principal&quot; contains a specific identity. Default value
    // denotes that Principal contains one of the groups by
    // default supported by all MSPs (&quot;admin&quot; or &quot;member&quot;).
    Classification principal_classification = 1;

    // Principal completes the policy principal definition. For the default
    // principal types, Principal can be either &quot;Admin&quot; or &quot;Member&quot;.
    // For the ByOrganizationUnit/ByIdentity values of Classification,
    // PolicyPrincipal acquires its value from an organization unit or
    // identity, respectively.
    // For the Combined Classification type, the Principal is a marshalled
    // CombinedPrincipal.
    bytes principal = 2;
}


// OrganizationUnit governs the organization of the Principal
// field of a policy principal when a specific organization unity members
// are to be defined within a policy principal.
message OrganizationUnit {

    // MSPIdentifier represents the identifier of the MSP this organization unit
    // refers to
    string msp_identifier = 1;

    // OrganizationUnitIdentifier defines the organizational unit under the
    // MSP identified with MSPIdentifier
    string organizational_unit_identifier = 2;

    // CertifiersIdentifier is the hash of certificates chain of trust
    // related to this organizational unit
    bytes certifiers_identifier = 3;
}

// MSPRole governs the organization of the Principal
// field of an MSPPrincipal when it aims to define one of the
// two dedicated roles within an MSP: Admin and Members.
message MSPRole {
    // MSPIdentifier represents the identifier of the MSP this principal
    // refers to
    string msp_identifier = 1;

    enum MSPRoleType {
        MEMBER = 0; // Represents an MSP Member
        ADMIN  = 1; // Represents an MSP Admin
        CLIENT = 2; // Represents an MSP Client
        PEER = 3; // Represents an MSP Peer
        ORDERER = 4; // Represents an MSP Orderer
    }

    // MSPRoleType defines which of the available, pre-defined MSP-roles
    // an identiy should posess inside the MSP with identifier MSPidentifier
    MSPRoleType role = 2;
}

// MSPIdentityAnonymity can be used to enforce an identity to be anonymous or nominal.
message MSPIdentityAnonymity {
    enum MSPIdentityAnonymityType {
        NOMINAL = 0; // Represents a nominal MSP Identity
        ANONYMOUS = 1; // Represents an anonymous MSP Identity
    }

    MSPIdentityAnonymityType anonymity_type = 1;
}

// CombinedPrincipal governs the organization of the Principal
// field of a policy principal when principal_classification has
// indicated that a combined form of principals is required
message CombinedPrincipal {
    // Principals refer to combined principals
    repeated MSPPrincipal principals = 1;
}

// TODO: Bring msp.SerializedIdentity from fabric/msp/identities.proto here. Reason below.
// SerializedIdentity represents an serialized version of an identity;
// this consists of an MSP-identifier this identity would correspond to
// and the bytes of the actual identity. A serialized form of
// SerializedIdentity would govern &quot;Principal&quot; field of a PolicyPrincipal
// of classification &quot;ByIdentity&quot;.

</code></pre>
<h2><a class="header" href="#srcmspidentitiesproto" id="srcmspidentitiesproto">src:./msp/identities.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/msp&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.msp&quot;;

package msp;

// This struct represents an Identity
// (with its MSP identifier) to be used
// to serialize it and deserialize it
message SerializedIdentity {
    // The identifier of the associated membership service provider
    string mspid = 1;

    // the Identity, serialized according to the rules of its MPS
    bytes id_bytes = 2;
}

// This struct represents an Idemix Identity
// to be used to serialize it and deserialize it.
// The IdemixMSP will first serialize an idemix identity to bytes using
// this proto, and then uses these bytes as id_bytes in SerializedIdentity
message SerializedIdemixIdentity {
    // nym_x is the X-component of the pseudonym elliptic curve point.
    // It is a []byte representation of an amcl.BIG
    // The pseudonym can be seen as a public key of the identity, it is used to verify signatures.
    bytes nym_x = 1;

    // nym_y is the Y-component of the pseudonym elliptic curve point.
    // It is a []byte representation of an amcl.BIG
    // The pseudonym can be seen as a public key of the identity, it is used to verify signatures.
    bytes nym_y = 2;

    // ou contains the organizational unit of the idemix identity
    bytes ou = 3;

    // role contains the role of this identity (e.g., ADMIN or MEMBER)
    bytes role = 4;

    // proof contains the cryptographic evidence that this identity is valid
    bytes proof = 5;
}

</code></pre>
<h2><a class="header" href="#srcledgerrwsetrwsetproto" id="srcledgerrwsetrwsetproto">src:./ledger/rwset/rwset.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/ledger/rwset&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.ledger.rwset&quot;;

package rwset;

// TxReadWriteSet encapsulates a read-write set for a transaction
// DataModel specifies the enum value of the data model
// ns_rwset field specifies a list of chaincode specific read-write set (one for each chaincode)
message TxReadWriteSet {
    enum DataModel {
        KV = 0;
    }
    DataModel data_model = 1;
    repeated NsReadWriteSet ns_rwset = 2;
}

// NsReadWriteSet encapsulates the read-write set for a chaincode
message NsReadWriteSet {
   string namespace = 1;
   bytes rwset = 2; // Data model specific serialized proto message (e.g., kvrwset.KVRWSet for KV and Document data models)
   repeated CollectionHashedReadWriteSet collection_hashed_rwset = 3;
}

// CollectionHashedReadWriteSet encapsulate the hashed representation for the private read-write set for a collection
message CollectionHashedReadWriteSet {
    string collection_name = 1;
    bytes hashed_rwset = 2; // Data model specific serialized proto message (e.g., kvrwset.HashedRWSet for KV and Document data models)
    bytes pvt_rwset_hash = 3; // Hash of entire private read-write set for a specific collection. This helps in authenticating the private read-write set efficiently
}

// TxPvtReadWriteSet encapsulate the private read-write set for a transaction
message TxPvtReadWriteSet {
    TxReadWriteSet.DataModel data_model = 1;
    repeated NsPvtReadWriteSet ns_pvt_rwset = 2;
}

// NsPvtReadWriteSet encapsulates the private read-write set for a chaincode
message NsPvtReadWriteSet {
   string namespace = 1;
   repeated CollectionPvtReadWriteSet collection_pvt_rwset = 2;
}

// CollectionPvtReadWriteSet encapsulates the private read-write set for a collection
message CollectionPvtReadWriteSet {
    string collection_name = 1;
    bytes rwset = 2; // Data model specific serialized proto message (e.g., kvrwset.KVRWSet for KV and Document data models)
}

</code></pre>
<h2><a class="header" href="#srcledgerrwsetkvrwsetkv_rwsetproto" id="srcledgerrwsetkvrwsetkv_rwsetproto">src:./ledger/rwset/kvrwset/kv_rwset.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/ledger/rwset/kvrwset&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.ledger.rwset.kvrwset&quot;;

package kvrwset;

// KVRWSet encapsulates the read-write set for a chaincode that operates upon a KV or Document data model
// This structure is used for both the public data and the private data
message KVRWSet {
    repeated KVRead reads = 1;
    repeated RangeQueryInfo range_queries_info = 2;
    repeated KVWrite writes = 3;
    repeated KVMetadataWrite metadata_writes = 4;
}

// HashedRWSet encapsulates hashed representation of a private read-write set for KV or Document data model
message HashedRWSet {
    repeated KVReadHash hashed_reads = 1;
    repeated KVWriteHash hashed_writes = 2;
    repeated KVMetadataWriteHash metadata_writes = 3;
}

// KVRead captures a read operation performed during transaction simulation
// A 'nil' version indicates a non-existing key read by the transaction
message KVRead {
    string key = 1;
    Version version = 2;
}

// KVWrite captures a write (update/delete) operation performed during transaction simulation
message KVWrite {
    string key = 1;
    bool is_delete = 2;
    bytes value = 3;
}

// KVMetadataWrite captures all the entries in the metadata associated with a key
message KVMetadataWrite {
    string key = 1;
    repeated KVMetadataEntry entries = 2;
}

// KVReadHash is similar to the KVRead in spirit. However, it captures the hash of the key instead of the key itself
// version is kept as is for now. However, if the version also needs to be privacy-protected, it would need to be the
// hash of the version and hence of 'bytes' type
message KVReadHash {
    bytes key_hash = 1;
    Version version = 2;
}

// KVWriteHash is similar to the KVWrite. It captures a write (update/delete) operation performed during transaction simulation
message KVWriteHash {
    bytes key_hash = 1;
    bool is_delete = 2;
    bytes value_hash = 3;
}

// KVMetadataWriteHash captures all the upserts to the metadata associated with a key hash
message KVMetadataWriteHash {
    bytes key_hash = 1;
    repeated KVMetadataEntry entries = 2;
}

// KVMetadataEntry captures a 'name'ed entry in the metadata of a key/key-hash.
message KVMetadataEntry {
    string name = 1;
    bytes value = 2;
}

// Version encapsulates the version of a Key
// A version of a committed key is maintained as the height of the transaction that committed the key.
// The height is represenetd as a tuple &lt;blockNum, txNum&gt; where the txNum is the position of the transaction
// (starting with 0) within block
message Version {
    uint64 block_num = 1;
    uint64 tx_num = 2;
}

// RangeQueryInfo encapsulates the details of a range query performed by a transaction during simulation.
// This helps protect transactions from phantom reads by varifying during validation whether any new items
// got committed within the given range between transaction simuation and validation
// (in addition to regular checks for updates/deletes of the existing items).
// readInfo field contains either the KVReads (for the items read by the range query) or a merkle-tree hash
// if the KVReads exceeds a pre-configured numbers
message RangeQueryInfo {
    string start_key = 1;
    string end_key = 2;
    bool itr_exhausted = 3;
    oneof reads_info {
        QueryReads raw_reads = 4;
        QueryReadsMerkleSummary reads_merkle_hashes = 5;
    }
}

// QueryReads encapsulates the KVReads for the items read by a transaction as a result of a query execution
message QueryReads {
    repeated KVRead kv_reads = 1;
}

// QueryReadsMerkleSummary encapsulates the Merkle-tree hashes for the QueryReads
// This allows to reduce the size of RWSet in the presence of query results
// by storing certain hashes instead of actual results.
// maxDegree field refers to the maximum number of children in the tree at any level
// maxLevel field contains the lowest level which has lesser nodes than maxDegree (starting from leaf level)
message QueryReadsMerkleSummary {
    uint32 max_degree = 1;
    uint32 max_level = 2;
    repeated bytes max_level_hashes = 3;
}

</code></pre>
<h2><a class="header" href="#srcledgerqueryresultkv_query_resultproto" id="srcledgerqueryresultkv_query_resultproto">src:./ledger/queryresult/kv_query_result.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

package queryresult;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/ledger/queryresult&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.ledger.queryresult&quot;;

import &quot;google/protobuf/timestamp.proto&quot;;


// KV -- QueryResult for range/execute query. Holds a key and corresponding value.
message KV {
    string namespace = 1;
    string key = 2;
    bytes value = 3;
}

// KeyModification -- QueryResult for history query. Holds a transaction ID, value,
// timestamp, and delete marker which resulted from a history query.
message KeyModification {
    string tx_id = 1;
    bytes value = 2;
    google.protobuf.Timestamp timestamp = 3;
    bool is_delete = 4;
}

</code></pre>
<h2><a class="header" href="#srcdiscoveryprotocolproto" id="srcdiscoveryprotocolproto">src:./discovery/protocol.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/discovery&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.discovery&quot;;

package discovery;

import &quot;gossip/message.proto&quot;;
import &quot;msp/msp_config.proto&quot;;

// Discovery defines a service that serves information about the fabric network
// like which peers, orderers, chaincodes, etc.
service Discovery {
    // Discover receives a signed request, and returns a response.
    rpc Discover (SignedRequest) returns (Response);
}

// SignedRequest contains a serialized Request in the payload field
// and a signature.
// The identity that is used to verify the signature
// can be extracted from the authentication field of type AuthInfo
// in the Request itself after deserializing it.
message SignedRequest {
    bytes payload   = 1;
    bytes signature = 2;
}

// Request contains authentication info about the client that sent the request
// and the queries it wishes to query the service
message Request {
    // authentication contains information that the service uses to check
    // the client's eligibility for the queries.
    AuthInfo authentication = 1;
    // queries
    repeated Query queries = 2;
}

message Response {
    // The results are returned in the same order of the queries
    repeated QueryResult results = 1;
}

// AuthInfo aggregates authentication information that the server uses
// to authenticate the client
message AuthInfo {
    // This is the identity of the client that is used to verify the signature
    // on the SignedRequest's payload.
    // It is a msp.SerializedIdentity in bytes form
    bytes client_identity = 1;

    // This is the hash of the client's TLS cert.
    // When the network is running with TLS, clients that don't include a certificate
    // will be denied access to the service.
    // Since the Request is encapsulated with a SignedRequest (which is signed),
    // this binds the TLS session to the enrollement identity of the client and
    // therefore both authenticates the client to the server,
    // and also prevents the server from relaying the request message to another server.
    bytes client_tls_cert_hash = 2;
}

// Query asks for information in the context of a specific channel
message Query {
    string channel = 1;
    oneof query {
        // ConfigQuery is used to query for the configuration of the channel,
        // such as FabricMSPConfig, and rorderer endpoints.
        // The client has to query a peer it trusts as it doesn't have means to self-verify
        // the authenticity of the returned result.
        // The result is returned in the form of ConfigResult.
        ConfigQuery config_query = 2;

        // PeerMembershipQuery queries for peers in a channel context,
        // and returns PeerMembershipResult
        PeerMembershipQuery peer_query = 3;

        // ChaincodeQuery queries for chaincodes by their name and version.
        // An empty version means any version can by returned.
        ChaincodeQuery cc_query = 4;

        // LocalPeerQuery queries for peers in a non channel context,
        // and returns PeerMembershipResult
        LocalPeerQuery local_peers = 5;
    }
}

// QueryResult contains a result for a given Query.
// The corresponding Query can be inferred by the index of the QueryResult from
// its enclosing Response message.
// QueryResults are ordered in the same order as the Queries are ordered in their enclosing Request.
message QueryResult {
    oneof result {
        // Error indicates failure or refusal to process the query
        Error error = 1;

        // ConfigResult contains the configuration of the channel,
        // such as FabricMSPConfig and orderer endpoints
        ConfigResult config_result = 2;

        // ChaincodeQueryResult contains information about chaincodes,
        // and their corresponding endorsers
        ChaincodeQueryResult cc_query_res = 3;

        // PeerMembershipResult contains information about peers,
        // such as their identity, endpoints, and channel related state.
        PeerMembershipResult members = 4;
    }
}

// ConfigQuery requests a ConfigResult
message ConfigQuery {

}

message ConfigResult {
    // msps is a map from MSP_ID to FabricMSPConfig
    map&lt;string, msp.FabricMSPConfig&gt; msps = 1;
    // orderers is a map from MSP_ID to endpoint lists of orderers
    map&lt;string, Endpoints&gt; orderers = 2;
}

// PeerMembershipQuery requests PeerMembershipResult.
// The filter field may be optionally populated in order
// for the peer membership to be filtered according to
// chaincodes that are installed on peers and collection
// access control policies.
message PeerMembershipQuery {
    ChaincodeInterest filter = 1;
}

// PeerMembershipResult contains peers mapped by their organizations (MSP_ID)
message PeerMembershipResult {
    map&lt;string, Peers&gt; peers_by_org = 1;
}

// ChaincodeQuery requests ChaincodeQueryResults for a given
// list of chaincode invocations.
// Each invocation is a separate one, and the endorsement policy
// is evaluated independantly for each given interest.
message ChaincodeQuery {
    repeated ChaincodeInterest interests = 1;
}

// ChaincodeInterest defines an interest about an endorsement
// for a specific single chaincode invocation.
// Multiple chaincodes indicate chaincode to chaincode invocations.
message ChaincodeInterest {
    repeated ChaincodeCall chaincodes = 1;
}

// ChaincodeCall defines a call to a chaincode.
// It may have collections that are related to the chaincode
message ChaincodeCall {
    string name = 1;
    repeated string collection_names = 2;
}

// ChaincodeQueryResult contains EndorsementDescriptors for
// chaincodes
message ChaincodeQueryResult {
    repeated EndorsementDescriptor content = 1;
}

// LocalPeerQuery queries for peers in a non channel context
message LocalPeerQuery {
}

// EndorsementDescriptor contains information about which peers can be used
// to request endorsement from, such that the endorsement policy would be fulfilled.
// Here is how to compute a set of peers to ask an endorsement from, given an EndorsementDescriptor:
// Let e: G --&gt; P be the endorsers_by_groups field that maps a group to a set of peers.
// Note that applying e on a group g yields a set of peers.
// 1) Select a layout l: G --&gt; N out of the layouts given.
//    l is the quantities_by_group field of a Layout, and it maps a group to an integer.
// 2) R = {}  (an empty set of peers)
// 3) For each group g in the layout l, compute n = l(g)
//    3.1) Denote P_g as a set of n random peers {p0, p1, ... p_n} selected from e(g)
//    3.2) R = R U P_g  (add P_g to R)
// 4) The set of peers R is the peers the client needs to request endorsements from
message EndorsementDescriptor {
    string chaincode = 1;
    // Specifies the endorsers, separated to groups.
    map&lt;string, Peers&gt; endorsers_by_groups = 2;

    // Specifies options of fulfulling the endorsement policy.
    // Each option lists the group names, and the amount of signatures needed
    // from each group.
    repeated Layout layouts = 3;
}

// Layout contains a mapping from a group name to number of peers
// that are needed for fulfilling an endorsement policy
message Layout {
    // Specifies how many non repeated signatures of each group
    // are needed for endorsement
    map&lt;string, uint32&gt; quantities_by_group = 1;
}

// Peers contains a list of Peer(s)
message Peers {
    repeated Peer peers = 1;
}

// Peer contains information about the peer such as its channel specific
// state, and membership information.
message Peer {
    // This is an Envelope of a GossipMessage with a gossip.StateInfo message
    gossip.Envelope state_info = 1;
    // This is an Envelope of a GossipMessage with a gossip.AliveMessage message
    gossip.Envelope membership_info = 2;

    // This is the msp.SerializedIdentity of the peer, represented in bytes.
    bytes identity = 3;
}

// Error denotes that something went wrong and contains the error message
message Error {
    string content = 1;
}

// Endpoints is a list of Endpoint(s)
message Endpoints {
    repeated Endpoint endpoint = 1;
}

// Endpoint is a combination of a host and a port
message Endpoint {
    string host = 1;
    uint32 port = 2;
}

</code></pre>
<h2><a class="header" href="#srcordererconfigurationproto" id="srcordererconfigurationproto">src:./orderer/configuration.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/orderer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.orderer&quot;;

package orderer;

// The orderer config is specified by the following convention:
//   For a configuration item with key &quot;Key&quot;
//   the encoded value is a a proto message of type &quot;Key&quot;
//   For example, for the configuration item of name &quot;ConsensusType&quot;
//   the encoded value is the proto message &quot;ConsensusType&quot;

message ConsensusType {
    // The consensus type: &quot;solo&quot;, &quot;kafka&quot; or &quot;etcdraft&quot;.
    string type = 1;
    // Opaque metadata, dependent on the consensus type.
    bytes metadata = 2;

    // State defines the orderer mode of operation, typically for consensus-type migration.
    // NORMAL is during normal operation, when consensus-type migration is not, and can not, take place.
    // MAINTENANCE is when the consensus-type can be changed.
    enum State {
        STATE_NORMAL = 0;
        STATE_MAINTENANCE = 1;
    }
    // The state signals the ordering service to go into maintenance mode, typically for consensus-type migration.
    State state = 3;
}

message BatchSize {
    // Simply specified as number of messages for now, in the future
    // we may want to allow this to be specified by size in bytes
    uint32 max_message_count = 1;
    // The byte count of the serialized messages in a batch cannot
    // exceed this value.
    uint32 absolute_max_bytes = 2;
    // The byte count of the serialized messages in a batch should not
    // exceed this value.
    uint32 preferred_max_bytes = 3;
}

message BatchTimeout {
    // Any duration string parseable by ParseDuration():
    // https://golang.org/pkg/time/#ParseDuration
    string timeout = 1;
}

// Carries a list of bootstrap brokers, i.e. this is not the exclusive set of
// brokers an ordering service
message KafkaBrokers {
    // Each broker here should be identified using the (IP|host):port notation,
    // e.g. 127.0.0.1:7050, or localhost:7050 are valid entries
    repeated string brokers = 1;
}

// ChannelRestrictions is the mssage which conveys restrictions on channel creation for an orderer
message ChannelRestrictions {
    uint64 max_count = 1; // The max count of channels to allow to be created, a value of 0 indicates no limit
}

</code></pre>
<h2><a class="header" href="#srcordererkafkaproto" id="srcordererkafkaproto">src:./orderer/kafka.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/orderer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.orderer&quot;;

package orderer;

// KafkaMessage is a wrapper type for the messages
// that the Kafka-based orderer deals with.
message KafkaMessage {
    oneof Type {
        KafkaMessageRegular regular = 1;
        KafkaMessageTimeToCut time_to_cut = 2;
        KafkaMessageConnect connect = 3;
    }
}

// KafkaMessageRegular wraps a marshalled envelope.
message KafkaMessageRegular {
    enum Class {
        UNKNOWN = 0;
        NORMAL = 1;
        CONFIG = 2;
    }
    bytes payload = 1;
    uint64 config_seq = 2;
    Class class = 3;
    int64 original_offset = 4;
}

// KafkaMessageTimeToCut is used to signal to the orderers
// that it is time to cut block &lt;block_number&gt;.
message KafkaMessageTimeToCut {
    uint64 block_number = 1;
}

// KafkaMessageConnect is posted by an orderer upon booting up.
// It is used to prevent the panic that would be caused if we
// were to consume an empty partition. It is ignored by all
// orderers when processing the partition.
message KafkaMessageConnect {
    bytes payload = 1;
}

// KafkaMetadata is encoded into the ORDERER block to keep track of
// Kafka-related metadata associated with this block.
message KafkaMetadata {
    // LastOffsetPersisted is the encoded value for the Metadata message
    // which is encoded in the ORDERER block metadata index for the case
    // of the Kafka-based orderer.
    int64 last_offset_persisted = 1;

    // LastOriginalOffsetProcessed is used to keep track of the newest
    // offset processed if a message is re-validated and re-ordered.
    // This value is used to deduplicate re-submitted messages from
    // multiple orderer so that we don't bother re-processing it again.
    int64 last_original_offset_processed = 2;

    // LastResubmittedConfigOffset is used to capture the newest offset of
    // CONFIG kafka message, which is revalidated and resubmitted. By comparing
    // this with LastOriginalOffsetProcessed, we could detemine whether there
    // are still CONFIG messages that have been resubmitted but NOT processed
    // yet. It's used as condition to block ingress messages, so we could reduce
    // the overhead of repeatedly resubmitting messages as config seq keeps
    // advancing.
    int64 last_resubmitted_config_offset = 3;
}

</code></pre>
<h2><a class="header" href="#srcordererabproto" id="srcordererabproto">src:./orderer/ab.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/orderer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.orderer&quot;;

package orderer;

import &quot;common/common.proto&quot;;

message BroadcastResponse {
    // Status code, which may be used to programatically respond to success/failure
    common.Status status = 1;
    // Info string which may contain additional information about the status returned
    string info = 2;
}

message SeekNewest { }

message SeekOldest { }

message SeekSpecified {
    uint64 number = 1;
}

message SeekPosition {
    oneof Type {
        SeekNewest newest = 1;
        SeekOldest oldest = 2;
        SeekSpecified specified = 3;
    }
}

// SeekInfo specifies the range of requested blocks to return
// If the start position is not found, an error is immediately returned
// Otherwise, blocks are returned until a missing block is encountered, then behavior is dictated
// by the SeekBehavior specified.
message SeekInfo {
   // If BLOCK_UNTIL_READY is specified, the reply will block until the requested blocks are available,
   // if FAIL_IF_NOT_READY is specified, the reply will return an error indicating that the block is not
   // found.  To request that all blocks be returned indefinitely as they are created, behavior should be
   // set to BLOCK_UNTIL_READY and the stop should be set to specified with a number of MAX_UINT64
    enum SeekBehavior {
        BLOCK_UNTIL_READY = 0;
        FAIL_IF_NOT_READY = 1;
    }

    // SeekErrorTolerance indicates to the server how block provider errors should be tolerated.  By default,
    // if the deliver service detects a problem in the underlying block source (typically, in the orderer,
    // a consenter error), it will begin to reject deliver requests.  This is to prevent a client from waiting
    // for blocks from an orderer which is stuck in an errored state.  This is almost always the desired behavior
    // and clients should stick with the default STRICT checking behavior.  However, in some scenarios, particularly
    // when attempting to recover from a crash or other corruption, it's desirable to force an orderer to respond
    // with blocks on a best effort basis, even if the backing consensus implementation is in an errored state.
    // In this case, set the SeekErrorResponse to BEST_EFFORT to ignore the consenter errors.
    enum SeekErrorResponse {
        STRICT = 0;
        BEST_EFFORT = 1;
    }
    SeekPosition start = 1;               // The position to start the deliver from
    SeekPosition stop = 2;                // The position to stop the deliver
    SeekBehavior behavior = 3;            // The behavior when a missing block is encountered
    SeekErrorResponse error_response = 4; // How to respond to errors reported to the deliver service
}

message DeliverResponse {
    oneof Type {
        common.Status status = 1;
        common.Block block = 2;
    }
}

service AtomicBroadcast {
    // broadcast receives a reply of Acknowledgement for each common.Envelope in order, indicating success or type of failure
    rpc Broadcast(stream common.Envelope) returns (stream BroadcastResponse);

    // deliver first requires an Envelope of type DELIVER_SEEK_INFO with Payload data as a mashaled SeekInfo message, then a stream of block replies is received.
    rpc Deliver(stream common.Envelope) returns (stream DeliverResponse);
}

</code></pre>
<h2><a class="header" href="#srcordererclusterproto" id="srcordererclusterproto">src:./orderer/cluster.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/orderer&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.orderer&quot;;

package orderer;

import &quot;common/common.proto&quot;;

// Cluster defines communication between cluster members.
service Cluster {
    // Step passes an implementation-specific message to another cluster member.
    rpc Step(stream StepRequest) returns (stream StepResponse);
}

// StepRequest wraps a message that is sent to a cluster member.
message StepRequest {
    oneof payload {
        // consensus_request is a consensus specific message.
        ConsensusRequest consensus_request = 1;
        // submit_request is a relay of a transaction.
        SubmitRequest submit_request = 2;
    }
}

// StepResponse is a message received from a cluster member.
message StepResponse {
    oneof payload {
        SubmitResponse submit_res = 1;
    }
}

// ConsensusRequest is a consensus specific message sent to a cluster member.
message ConsensusRequest {
    string channel = 1;
    bytes payload = 2;
    bytes metadata = 3;
}

// SubmitRequest wraps a transaction to be sent for ordering.
message SubmitRequest {
    string channel = 1;
    // last_validation_seq denotes the last
    // configuration sequence at which the
    // sender validated this message.
    uint64 last_validation_seq = 2;
    // content is the fabric transaction
    // that is forwarded to the cluster member.
    common.Envelope payload = 3;
}

// SubmitResponse returns a success
// or failure status to the sender.
message SubmitResponse {
    string channel = 1;
    // Status code, which may be used to programatically respond to success/failure.
    common.Status status = 2;
    // Info string which may contain additional information about the returned status.
    string info = 3;
}

</code></pre>
<h2><a class="header" href="#srcordereretcdraftconfigurationproto" id="srcordereretcdraftconfigurationproto">src:./orderer/etcdraft/configuration.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/orderer/etcdraft&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.orderer.etcdraft&quot;;

package etcdraft;

// ConfigMetadata is serialized and set as the value of ConsensusType.Metadata in
// a channel configuration when the ConsensusType.Type is set &quot;etcdraft&quot;.
message ConfigMetadata {
    repeated Consenter consenters = 1;
    Options options = 2;
}

// Consenter represents a consenting node (i.e. replica).
message Consenter {
    string host = 1;
    uint32 port = 2;
    bytes client_tls_cert = 3;
    bytes server_tls_cert = 4;
}

// Options to be specified for all the etcd/raft nodes. These can be modified on a
// per-channel basis.
message Options {
    string tick_interval = 1; // time duration format, e.g. 500ms
    uint32 election_tick = 2;
    uint32 heartbeat_tick = 3;
    uint32 max_inflight_blocks = 4;
    // Take snapshot when cumulative data exceeds certain size in bytes.
    uint32 snapshot_interval_size = 5;
}

</code></pre>
<h2><a class="header" href="#srcordereretcdraftmetadataproto" id="srcordereretcdraftmetadataproto">src:./orderer/etcdraft/metadata.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/orderer/etcdraft&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.orderer.etcdraft&quot;;

package etcdraft;

// BlockMetadata stores data used by the Raft OSNs when
// coordinating with each other, to be serialized into
// block meta dta field and used after failres and restarts.
message BlockMetadata {
    // Maintains a mapping between the cluster's OSNs
    // and their Raft IDs.
    repeated uint64 consenter_ids = 1;
    // Carries the Raft ID value that will be assigned
    // to the next OSN that will join this cluster.
    uint64 next_consenter_id = 2;
    // Index of etcd/raft entry for current block.
    uint64 raft_index = 3;
}

// ClusterMetadata encapsulates metadata that is exchanged among cluster nodes
message ClusterMetadata {
    // Indicates active nodes in cluster that are reacheable by Raft leader
    repeated uint64 active_nodes = 1;
}

</code></pre>
<h2><a class="header" href="#srcgossipmessageproto" id="srcgossipmessageproto">src:./gossip/message.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/gossip&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.gossip&quot;;

package gossip;

import &quot;common/collection.proto&quot;;

// Gossip
service Gossip {

    // GossipStream is the gRPC stream used for sending and receiving messages
    rpc GossipStream (stream Envelope) returns (stream Envelope);

    // Ping is used to probe a remote peer's aliveness
    rpc Ping (Empty) returns (Empty);
}


// Envelope contains a marshalled
// GossipMessage and a signature over it.
// It may also contain a SecretEnvelope
// which is a marshalled Secret
message Envelope {
    bytes payload   = 1;
    bytes signature = 2;
    SecretEnvelope secret_envelope = 3;
}

// SecretEnvelope is a marshalled Secret
// and a signature over it.
// The signature should be validated by the peer
// that signed the Envelope the SecretEnvelope
// came with
message SecretEnvelope {
    bytes payload   = 1;
    bytes signature = 2;
}

// Secret is an entity that might be omitted
// from an Envelope when the remote peer that is receiving
// the Envelope shouldn't know the secret's content.
message Secret {
    oneof content {
        string internalEndpoint = 1;
    }
}

// GossipMessage defines the message sent in a gossip network
message GossipMessage {

    // used mainly for testing, but will might be used in the future
    // for ensuring message delivery by acking
    uint64 nonce  = 1;

    // The channel of the message.
    // Some GossipMessages may set this to nil, because
    // they are cross-channels but some may not
    bytes channel = 2;


    enum Tag {
        UNDEFINED    = 0;
        EMPTY        = 1;
        ORG_ONLY     = 2;
        CHAN_ONLY    = 3;
        CHAN_AND_ORG = 4;
        CHAN_OR_ORG  = 5;
    }

    // determines to which peers it is allowed
    // to forward the message
    Tag tag = 3;

    oneof content {
        // Membership
        AliveMessage alive_msg = 5;
        MembershipRequest mem_req = 6;
        MembershipResponse mem_res = 7;

        // Contains a ledger block
        DataMessage data_msg = 8;

        // Used for push&amp;pull
        GossipHello hello = 9;
        DataDigest  data_dig = 10;
        DataRequest data_req = 11;
        DataUpdate  data_update = 12;

        // Empty message, used for pinging
        Empty empty = 13;

        // ConnEstablish, used for establishing a connection
        ConnEstablish conn = 14;

        // Used for relaying information
        // about state
        StateInfo state_info = 15;

        // Used for sending sets of StateInfo messages
        StateInfoSnapshot state_snapshot = 16;

        // Used for asking for StateInfoSnapshots
        StateInfoPullRequest state_info_pull_req = 17;

        //  Used to ask from a remote peer a set of blocks
        RemoteStateRequest state_request = 18;

        // Used to send a set of blocks to a remote peer
        RemoteStateResponse state_response = 19;

        // Used to indicate intent of peer to become leader
        LeadershipMessage leadership_msg = 20;

        // Used to learn of a peer's certificate
        PeerIdentity peer_identity = 21;

        Acknowledgement ack = 22;

        // Used to request private data
        RemotePvtDataRequest privateReq = 23;

        // Used to respond to private data requests
        RemotePvtDataResponse privateRes = 24;

        // Encapsulates private data used to distribute
        // private rwset after the endorsement
        PrivateDataMessage private_data = 25;
    }
}

// StateInfo is used for a peer to relay its state information
// to other peers
message StateInfo {
    PeerTime timestamp = 2;
    bytes pki_id       = 3;

    // channel_MAC is an authentication code that proves
    // that the peer that sent this message knows
    // the name of the channel.
    bytes channel_MAC  = 4;

    Properties properties = 5;
}

message Properties {
    uint64 ledger_height = 1;
    bool left_channel = 2;
    repeated Chaincode chaincodes = 3;
}

// StateInfoSnapshot is an aggregation of StateInfo messages
message StateInfoSnapshot {
    repeated Envelope elements = 1;
}

// StateInfoPullRequest is used to fetch a StateInfoSnapshot
// from a remote peer
message StateInfoPullRequest {
    // channel_MAC is an authentication code that proves
    // that the peer that sent this message knows
    // the name of the channel.
    bytes channel_MAC  = 1;
}

// ConnEstablish is the message used for the gossip handshake
// Whenever a peer connects to another peer, it handshakes
// with it by sending this message that proves its identity
message ConnEstablish {
    bytes pki_id          = 1;
    bytes identity        = 2;
    bytes tls_cert_hash   = 3;
}

// PeerIdentity defines the identity of the peer
// Used to make other peers learn of the identity
// of a certain peer
message PeerIdentity {
    bytes pki_id    = 1;
    bytes cert      = 2;
    bytes metadata  = 3;
}

// Messages related to pull mechanism

enum PullMsgType {
    UNDEFINED     = 0;
    BLOCK_MSG     = 1;
    IDENTITY_MSG  = 2;
}

// DataRequest is a message used for a peer to request
// certain data blocks from a remote peer
message DataRequest {
    uint64 nonce             = 1;
    repeated bytes digests  = 2;
    PullMsgType msg_type     = 3;
}

// GossipHello is the message that is used for the peer to initiate
// a pull round with another peer
message GossipHello {
    uint64 nonce         = 1;
    bytes metadata       = 2;
    PullMsgType msg_type = 3;
}

// DataUpdate is the final message in the pull phase
// sent from the receiver to the initiator
message DataUpdate {
    uint64 nonce                = 1;
    repeated Envelope data      = 2;
    PullMsgType msg_type        = 3;
}

// DataDigest is the message sent from the receiver peer
// to the initator peer and contains the data items it has
message DataDigest {
    uint64 nonce             = 1;
    repeated bytes digests  = 2; // Maybe change this to bitmap later on
    PullMsgType msg_type     = 3;
}


// Ledger block messages

// DataMessage is the message that contains a block
message DataMessage {
    Payload payload = 1;
}

// PrivateDataMessage message which includes private
// data information to distributed once transaction
// has been endorsed
message PrivateDataMessage {
    PrivatePayload payload = 1;
}

// Payload contains a block
message Payload {
    uint64 seq_num              = 1;
    bytes data                  = 2;
    repeated bytes private_data = 3;
}

// PrivatePayload payload to encapsulate private
// data with collection name to enable routing
// based on collection partitioning
message PrivatePayload {
    string collection_name      = 1;
    string namespace            = 2;
    string tx_id                = 3;
    bytes private_rwset         = 4;
    uint64 private_sim_height  = 5;
    common.CollectionConfigPackage collection_configs = 6;
}

// Membership messages

// AliveMessage is sent to inform remote peers
// of a peer's existence and activity
message AliveMessage {
    Member membership  = 1;
    PeerTime timestamp = 2;
    bytes identity     = 4;
}

// Leadership Message is sent during leader election to inform
// remote peers about intent of peer to proclaim itself as leader
message LeadershipMessage {
    bytes pki_id        = 1;
    PeerTime timestamp = 2;
    bool is_declaration = 3;
}

// PeerTime defines the logical time of a peer's life
message PeerTime {
    uint64 inc_num = 1;
    uint64 seq_num = 2;
}

// MembershipRequest is used to ask membership information
// from a remote peer
message MembershipRequest {
    Envelope self_information = 1;
    repeated bytes known         = 2;
}

// MembershipResponse is used for replying to MembershipRequests
message MembershipResponse {
    repeated Envelope alive = 1;
    repeated Envelope dead  = 2;
}

// Member holds membership-related information
// about a peer
message Member {
    string endpoint = 1;
    bytes  metadata = 2;
    bytes  pki_id    = 3;
}

// Empty is used for pinging and in tests
message Empty {}


// State transfer

// RemoteStateRequest is used to ask a set of blocks
// from a remote peer
message RemoteStateRequest {
    uint64 start_seq_num = 1;
    uint64 end_seq_num = 2;
}

// RemoteStateResponse is used to send a set of blocks
// to a remote peer
message RemoteStateResponse {
    repeated Payload payloads = 1;
}

// RemotePrivateDataRequest message used to request
// missing private rwset
message RemotePvtDataRequest {
    repeated PvtDataDigest digests = 1;
}

// PvtDataDigest defines a digest of private data
message PvtDataDigest {
    string tx_id = 1;
    string namespace = 2;
    string collection = 3;
    uint64 block_seq = 4;
    uint64 seq_in_block = 5;
}

// RemotePrivateData message to response on private
// data replication request
message RemotePvtDataResponse {
    repeated PvtDataElement elements = 1;
}

message PvtDataElement {
    PvtDataDigest digest = 1;
    // the payload is a marshaled kvrwset.KVRWSet
    repeated bytes payload = 2;
}

// PvtPayload augments private rwset data and tx index
// inside the block
message PvtDataPayload {
    uint64 tx_seq_in_block = 1;
    // Encodes marhslaed bytes of rwset.TxPvtReadWriteSet
    // defined in rwset.proto
    bytes payload = 2;
}

message Acknowledgement {
    string error = 1;
}

// Chaincode represents a Chaincode that is installed
// on a peer
message Chaincode {
    string name = 1;
    string version = 2;
    bytes metadata = 3;
}

</code></pre>
<h2><a class="header" href="#srctransientstoretransientstoreproto" id="srctransientstoretransientstoreproto">src:./transientstore/transientstore.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

package transientstore;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/transientstore&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.transientstore&quot;;

import &quot;ledger/rwset/rwset.proto&quot;;
import &quot;common/collection.proto&quot;;

// TxPvtReadWriteSetWithConfigInfo encapsulates the transaction's private
// read-write set and additional information about the configurations such as
// the latest collection config when the transaction is simulated
message TxPvtReadWriteSetWithConfigInfo {
    uint64 endorsed_at = 1;
    rwset.TxPvtReadWriteSet pvt_rwset = 2;
    map&lt;string, common.CollectionConfigPackage&gt; collection_configs = 3;
}

</code></pre>
<h2><a class="header" href="#srccommonconfigurationproto" id="srccommonconfigurationproto">src:./common/configuration.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/common&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.common&quot;;

package common;

// HashingAlgorithm is encoded into the configuration transaction as  a configuration item of type Chain
// with a Key of &quot;HashingAlgorithm&quot; and a Value of  HashingAlgorithm as marshaled protobuf bytes
message HashingAlgorithm {
    // Currently supported algorithms are: SHAKE256
    string name = 1;
}

// BlockDataHashingStructure is encoded into the configuration transaction as a configuration item of
// type Chain with a Key of &quot;BlockDataHashingStructure&quot; and a Value of HashingAlgorithm as marshaled protobuf bytes
message BlockDataHashingStructure {
    // width specifies the width of the Merkle tree to use when computing the BlockDataHash
    // in order to replicate flat hashing, set this width to MAX_UINT32
    uint32 width  = 1;
}

// OrdererAddresses is encoded into the configuration transaction as a configuration item of type Chain
// with a Key of &quot;OrdererAddresses&quot; and a Value of OrdererAddresses as marshaled protobuf bytes
message OrdererAddresses {
    repeated string addresses = 1;
}

// Consortium represents the consortium context in which the channel was created
message Consortium {
    string name = 1;
}


// Capabilities message defines the capabilities a particular binary must implement
// for that binary to be able to safely participate in the channel.  The capabilities
// message is defined at the /Channel level, the /Channel/Application level, and the
// /Channel/Orderer level.
//
// The /Channel level capabilties define capabilities which both the orderer and peer
// binaries must satisfy.  These capabilties might be things like a new MSP type,
// or a new policy type.
//
// The /Channel/Orderer level capabilties define capabilities which must be supported
// by the orderer, but which have no bearing on the behavior of the peer.  For instance
// if the orderer changes the logic for how it constructs new channels, only all orderers
// must agree on the new logic.  The peers do not need to be aware of this change as
// they only interact with the channel after it has been constructed.
//
// Finally, the /Channel/Application level capabilities define capabilities which the peer
// binary must satisfy, but which have no bearing on the orderer.  For instance, if the
// peer adds a new UTXO transaction type, or changes the chaincode lifecycle requirements,
// all peers must agree on the new logic.  However, orderers never inspect transactions
// this deeply, and therefore have no need to be aware of the change.
//
// The capabilities strings defined in these messages typically correspond to release
// binary versions (e.g. &quot;V1.1&quot;), and are used primarilly as a mechanism for a fully
// upgraded network to switch from one set of logic to a new one.
//
// Although for V1.1, the orderers must be upgraded to V1.1 prior to the rest of the
// network, going forward, because of the split between the /Channel, /Channel/Orderer
// and /Channel/Application capabilities.  It should be possible for the orderer and
// application networks to upgrade themselves independently (with the exception of any
// new capabilities defined at the /Channel level).
message Capabilities {
    map&lt;string, Capability&gt; capabilities = 1;
}

// Capability is an empty message for the time being.  It is defined as a protobuf
// message rather than a constant, so that we may extend capabilities with other fields
// if the need arises in the future.  For the time being, a capability being in the
// capabilities map requires that that capability be supported.
message Capability { }

</code></pre>
<h2><a class="header" href="#srccommonledgerproto" id="srccommonledgerproto">src:./common/ledger.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/common&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.common&quot;;

package common;

// Contains information about the blockchain ledger such as height, current
// block hash, and previous block hash.
message BlockchainInfo {
    uint64 height = 1;
    bytes currentBlockHash = 2;
    bytes previousBlockHash = 3;
}

</code></pre>
<h2><a class="header" href="#srccommonpoliciesproto" id="srccommonpoliciesproto">src:./common/policies.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/common&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.common&quot;;

package common;

import &quot;msp/msp_principal.proto&quot;;

// Policy expresses a policy which the orderer can evaluate, because there has been some desire expressed to support
// multiple policy engines, this is typed as a oneof for now
message Policy {
    enum PolicyType {
        UNKNOWN = 0; // Reserved to check for proper initialization
        SIGNATURE = 1;
        MSP = 2;
        IMPLICIT_META = 3;
    }
    int32 type = 1; // For outside implementors, consider the first 1000 types reserved, otherwise one of PolicyType
    bytes value = 2;
}

// SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
message SignaturePolicyEnvelope {
    int32 version = 1;
    SignaturePolicy rule = 2;
    repeated MSPPrincipal identities = 3;
}

// SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
// policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
// to express AND as well as OR, as well as of course N out of the following M policies
// SignedBy implies that the signature is from a valid certificate which is signed by the trusted
// authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
// and will be the CA for more traditional certificates
message SignaturePolicy {
    message NOutOf {
        int32 n = 1;
        repeated SignaturePolicy rules = 2;
    }
    oneof Type {
        int32 signed_by = 1;
        NOutOf n_out_of = 2;
    }
}

// ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration
// It is implicit because the rule is generate implicitly based on the number of sub policies
// It is meta because it depends only on the result of other policies
// When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy
// of name sub_policy, evaluates the collection and applies the rule.
// For example, with 4 sub-groups, and a policy name of &quot;foo&quot;, ImplicitMetaPolicy retrieves
// each sub-group, retrieves policy &quot;foo&quot; for each subgroup, evaluates it, and, in the case of ANY
// 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures.
message ImplicitMetaPolicy {
    enum Rule {
        ANY = 0;      // Requires any of the sub-policies be satisfied, if no sub-policies exist, always returns true
        ALL = 1;      // Requires all of the sub-policies be satisfied
        MAJORITY = 2; // Requires a strict majority (greater than half) of the sub-policies be satisfied
    }
    string sub_policy = 1;
    Rule rule = 2;
}

</code></pre>
<h2><a class="header" href="#srccommonconfigtxproto" id="srccommonconfigtxproto">src:./common/configtx.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/common&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.common&quot;;

package common;

import &quot;common/common.proto&quot;;
import &quot;common/policies.proto&quot;;

// ConfigEnvelope is designed to contain _all_ configuration for a chain with no dependency
// on previous configuration transactions.
//
// It is generated with the following scheme:
//   1. Retrieve the existing configuration
//   2. Note the config properties (ConfigValue, ConfigPolicy, ConfigGroup) to be modified
//   3. Add any intermediate ConfigGroups to the ConfigUpdate.read_set (sparsely)
//   4. Add any additional desired dependencies to ConfigUpdate.read_set (sparsely)
//   5. Modify the config properties, incrementing each version by 1, set them in the ConfigUpdate.write_set
//      Note: any element not modified but specified should already be in the read_set, so may be specified sparsely
//   6. Create ConfigUpdate message and marshal it into ConfigUpdateEnvelope.update and encode the required signatures
//     a) Each signature is of type ConfigSignature
//     b) The ConfigSignature signature is over the concatenation of signature_header and the ConfigUpdate bytes (which includes a ChainHeader)
//   5. Submit new Config for ordering in Envelope signed by submitter
//     a) The Envelope Payload has data set to the marshaled ConfigEnvelope
//     b) The Envelope Payload has a header of type Header.Type.CONFIG_UPDATE
//
// The configuration manager will verify:
//   1. All items in the read_set exist at the read versions
//   2. All items in the write_set at a different version than, or not in, the read_set have been appropriately signed according to their mod_policy
//   3. The new configuration satisfies the ConfigSchema
message ConfigEnvelope {
    Config config = 1;        // A marshaled Config structure
    Envelope last_update = 2; // The last CONFIG_UPDATE message which generated this current configuration
                              // Note that CONFIG_UPDATE has a Payload.Data of a Marshaled ConfigUpdate
}

message ConfigGroupSchema {
    map&lt;string, ConfigGroupSchema&gt; groups = 1;
    map&lt;string, ConfigValueSchema&gt; values = 2;
    map&lt;string, ConfigPolicySchema&gt; policies = 3;
}

message ConfigValueSchema {}

message ConfigPolicySchema {}

// Config represents the config for a particular channel
message Config {
    // Prevent removed tag re-use
    reserved 3;
    reserved &quot;type&quot;;

    uint64 sequence = 1;
    ConfigGroup channel_group = 2; // channel_group is a bad name for this, it should be changed to root when API breakage is allowed
}

message ConfigUpdateEnvelope {
    bytes config_update = 1;                 // A marshaled ConfigUpdate structure
    repeated ConfigSignature signatures = 2; // Signatures over the config_update
}

// ConfigUpdate is used to submit a subset of config and to have the orderer apply to Config
// it is always submitted inside a ConfigUpdateEnvelope which allows the addition of signatures
// resulting in a new total configuration.  The update is applied as follows:
// 1. The versions from all of the elements in the read_set is verified against the versions in the existing config.
//    If there is a mismatch in the read versions, then the config update fails and is rejected.
// 2. Any elements in the write_set with the same version as the read_set are ignored.
// 3. The corresponding mod_policy for every remaining element in the write_set is collected.
// 4. Each policy is checked against the signatures from the ConfigUpdateEnvelope, any failing to verify are rejected
// 5. The write_set is applied to the Config and the ConfigGroupSchema verifies that the updates were legal
message ConfigUpdate {
    // Prevent removed tag re-use
    reserved 4;
    reserved &quot;type&quot;;

    string channel_id = 1;                // Which channel this config update is for
    ConfigGroup read_set = 2;             // ReadSet explicitly lists the portion of the config which was read, this should be sparse with only Version set
    ConfigGroup write_set = 3;            // WriteSet lists the portion of the config which was written, this should included updated Versions
    map&lt;string, bytes&gt; isolated_data = 5; // Data which is not to be reflected in the resulting Config, but is still needed for some other purpose.  For instance, rscc_seed_data
}

// ConfigGroup is the hierarchical data structure for holding config
message ConfigGroup {
    uint64 version = 1;
    map&lt;string,ConfigGroup&gt; groups = 2;
    map&lt;string,ConfigValue&gt; values = 3;
    map&lt;string,ConfigPolicy&gt; policies = 4;
    string mod_policy = 5;
}

// ConfigValue represents an individual piece of config data
message ConfigValue {
    uint64 version = 1;
    bytes value = 2;
    string mod_policy = 3;
}

message ConfigPolicy {
    uint64 version = 1;
    Policy policy = 2;
    string mod_policy = 3;
}

message ConfigSignature {
    bytes signature_header = 1; // A marshaled SignatureHeader
    bytes signature = 2;        // Signature over the concatenation signatureHeader bytes and config bytes
}

</code></pre>
<h2><a class="header" href="#srccommoncommonproto" id="srccommoncommonproto">src:./common/common.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/common&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.common&quot;;

package common;

import &quot;google/protobuf/timestamp.proto&quot;;

// These status codes are intended to resemble selected HTTP status codes
enum Status {
    UNKNOWN = 0;
    SUCCESS = 200;
    BAD_REQUEST = 400;
    FORBIDDEN = 403;
    NOT_FOUND = 404;
    REQUEST_ENTITY_TOO_LARGE = 413;
    INTERNAL_SERVER_ERROR = 500;
    NOT_IMPLEMENTED = 501;
    SERVICE_UNAVAILABLE = 503;
}

enum HeaderType {
    reserved 7, 9;
    reserved &quot;PEER_RESOURCE_UPDATE&quot;, &quot;TOKEN_TRANSACTION&quot;;

    MESSAGE = 0;                     // Used for messages which are signed but opaque
    CONFIG = 1;                      // Used for messages which express the channel config
    CONFIG_UPDATE = 2;               // Used for transactions which update the channel config
    ENDORSER_TRANSACTION = 3;        // Used by the SDK to submit endorser based transactions
    ORDERER_TRANSACTION = 4;         // Used internally by the orderer for management
    DELIVER_SEEK_INFO = 5;           // Used as the type for Envelope messages submitted to instruct the Deliver API to seek
    CHAINCODE_PACKAGE = 6;           // Used for packaging chaincode artifacts for install
    PEER_ADMIN_OPERATION = 8;        // Used for invoking an administrative operation on a peer
}

// This enum enlists indexes of the block metadata array
enum BlockMetadataIndex {
    SIGNATURES = 0;                  // Block metadata array position for block signatures
    LAST_CONFIG = 1;                 // Block metadata array position to store last configuration block sequence number
    TRANSACTIONS_FILTER = 2;         // Block metadata array position to store serialized bit array filter of invalid transactions
    ORDERER = 3 [deprecated=true];   /* Block metadata array position to store operational metadata for orderers
                                        e.g. For Kafka, this is where we store the last offset written to the local ledger */
    COMMIT_HASH = 4;                 /* Block metadata array position to store the hash of TRANSACTIONS_FILTER, State Updates,
                                        and the COMMIT_HASH of the previous block */
}

// LastConfig is the encoded value for the Metadata message which is encoded in the LAST_CONFIGURATION block metadata index
message LastConfig {
    uint64 index  = 1;
}

// Metadata is a common structure to be used to encode block metadata
message Metadata {
    bytes value = 1;
    repeated MetadataSignature signatures = 2;
}

message MetadataSignature {
    bytes signature_header = 1; // An encoded SignatureHeader
    bytes signature = 2;       // The signature over the concatenation of the Metadata value bytes, signatureHeader, and block header
}

message Header {
    bytes channel_header = 1;
    bytes signature_header = 2;
}

// Header is a generic replay prevention and identity message to include in a signed payload
message ChannelHeader {
    int32 type = 1; // Header types 0-10000 are reserved and defined by HeaderType

    // Version indicates message protocol version
    int32 version = 2;

    // Timestamp is the local time when the message was created
    // by the sender
    google.protobuf.Timestamp timestamp = 3;

    // Identifier of the channel this message is bound for
    string channel_id = 4;

    // An unique identifier that is used end-to-end.
    //  -  set by higher layers such as end user or SDK
    //  -  passed to the endorser (which will check for uniqueness)
    //  -  as the header is passed along unchanged, it will be
    //     be retrieved by the committer (uniqueness check here as well)
    //  -  to be stored in the ledger
    string tx_id = 5;

    // The epoch in which this header was generated, where epoch is defined based on block height
    // Epoch in which the response has been generated. This field identifies a
    // logical window of time. A proposal response is accepted by a peer only if
    // two conditions hold:
    // 1. the epoch specified in the message is the current epoch
    // 2. this message has been only seen once during this epoch (i.e. it hasn't
    //    been replayed)
    uint64 epoch = 6;

    // Extension that may be attached based on the header type
    bytes extension = 7;

    // If mutual TLS is employed, this represents
    // the hash of the client's TLS certificate
    bytes tls_cert_hash = 8;
}

message SignatureHeader {
    // Creator of the message, a marshaled msp.SerializedIdentity
    bytes creator = 1;

    // Arbitrary number that may only be used once. Can be used to detect replay attacks.
    bytes nonce = 2;
}

// Payload is the message contents (and header to allow for signing)
message Payload {

    // Header is included to provide identity and prevent replay
    Header header = 1;

    // Data, the encoding of which is defined by the type in the header
    bytes data = 2;
}

// Envelope wraps a Payload with a signature so that the message may be authenticated
message Envelope {
    // A marshaled Payload
    bytes payload = 1;

    // A signature by the creator specified in the Payload header
    bytes signature = 2;
}

// This is finalized block structure to be shared among the orderer and peer
// Note that the BlockHeader chains to the previous BlockHeader, and the BlockData hash is embedded
// in the BlockHeader.  This makes it natural and obvious that the Data is included in the hash, but
// the Metadata is not.
message Block {
    BlockHeader header = 1;
    BlockData data = 2;
    BlockMetadata metadata = 3;
}

// BlockHeader is the element of the block which forms the block chain
// The block header is hashed using the configured chain hashing algorithm
// over the ASN.1 encoding of the BlockHeader
message BlockHeader {
    uint64 number = 1; // The position in the blockchain
    bytes previous_hash = 2; // The hash of the previous block header
    bytes data_hash = 3; // The hash of the BlockData, by MerkleTree
}

message BlockData {
    repeated bytes data = 1;
}

message BlockMetadata {
    repeated bytes metadata = 1;
}

// OrdererBlockMetadata defines metadata that is set by the ordering service.
message OrdererBlockMetadata {
    LastConfig last_config = 1;
    bytes consenter_metadata = 2;
}

</code></pre>
<h2><a class="header" href="#srccommoncollectionproto" id="srccommoncollectionproto">src:./common/collection.proto</a></h2>
<pre><code class="language-proto">
// Copyright the Hyperledger Fabric contributors. All rights reserved.
//
// SPDX-License-Identifier: Apache-2.0

syntax = &quot;proto3&quot;;

option go_package = &quot;github.com/hyperledger/fabric-protos-go/common&quot;;
option java_package = &quot;org.hyperledger.fabric.protos.common&quot;;

package common;

import &quot;common/policies.proto&quot;;

// CollectionConfigPackage represents an array of CollectionConfig
// messages; the extra struct is required because repeated oneof is
// forbidden by the protobuf syntax
message CollectionConfigPackage {
    repeated CollectionConfig config = 1;
}

// CollectionConfig defines the configuration of a collection object;
// it currently contains a single, static type.
// Dynamic collections are deferred.
message CollectionConfig {
    oneof payload {
        StaticCollectionConfig static_collection_config = 1;
    }
}


// StaticCollectionConfig constitutes the configuration parameters of a
// static collection object. Static collections are collections that are
// known at chaincode instantiation time, and that cannot be changed.
// Dynamic collections are deferred.
message StaticCollectionConfig {
    // the name of the collection inside the denoted chaincode
    string name = 1;
    // a reference to a policy residing / managed in the config block
    // to define which orgs have access to this collection’s private data
    CollectionPolicyConfig member_orgs_policy = 2;
    // The minimum number of peers private data will be sent to upon
    // endorsement. The endorsement would fail if dissemination to at least
    // this number of peers is not achieved.
    int32 required_peer_count = 3;
    // The maximum number of peers that private data will be sent to
    // upon endorsement. This number has to be bigger than required_peer_count.
    int32 maximum_peer_count = 4;
    // The number of blocks after which the collection data expires.
    // For instance if the value is set to 10, a key last modified by block number 100
    // will be purged at block number 111. A zero value is treated same as MaxUint64
    uint64 block_to_live = 5;
    // The member only read access denotes whether only collection member clients
    // can read the private data (if set to true), or even non members can
    // read the data (if set to false, for example if you want to implement more granular
    // access logic in the chaincode)
    bool member_only_read = 6;
    // The member only write access denotes whether only collection member clients
    // can write the private data (if set to true), or even non members can
    // write the data (if set to false, for example if you want to implement more granular
    // access logic in the chaincode)
    bool member_only_write = 7;
}


// Collection policy configuration. Initially, the configuration can only
// contain a SignaturePolicy. In the future, the SignaturePolicy may be a
// more general Policy. Instead of containing the actual policy, the
// configuration may in the future contain a string reference to a policy.
message CollectionPolicyConfig {
    oneof payload {
        // Initially, only a signature policy is supported.
        SignaturePolicyEnvelope signature_policy = 1;
        // Later, the SignaturePolicy will be replaced by a Policy.
        //        Policy policy = 1;
        // A reference to a Policy is planned to be added later.
//        string reference = 2;
    }
}


// CollectionCriteria defines an element of a private data that corresponds
// to a certain transaction and collection
message CollectionCriteria {
    string channel = 1;
    string tx_id = 2;
    string collection = 3;
    string namespace = 4;
}

</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../dlt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../dlt/hl-sawtooth.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../dlt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../dlt/hl-sawtooth.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
